!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	planarity.h	/^	t_adjl_sparse_rep   *A;$/;"	m	struct:graph_sparse_rep
A	sumlines.c	231;"	d	file:
ABORT	gtools.h	81;"	d
ABORT	gtools.h	83;"	d
ACCUM	nausparse.c	47;"	d	file:
ACCUM	nautinv.c	61;"	d	file:
ACTION	testg.c	279;"	d	file:
ACTIVE	nausparse.c	656;"	d	file:
ADDEDGE	watercluster2.c	2511;"	d	file:
ADDELEMENT	nauty.h	528;"	d
ADDELEMENT	nauty.h	538;"	d
ADDELEMENT	showg.c	186;"	d	file:
ADDELEMENT0	nauty.h	515;"	d
ADDELEMENT1	nauty.h	505;"	d
ADDONEARC	nauty.h	534;"	d
ADDONEARC	nauty.h	544;"	d
ADDONEARC0	nauty.h	523;"	d
ADDONEARC1	nauty.h	511;"	d
ADDONEEDGE	nauty.h	535;"	d
ADDONEEDGE	nauty.h	545;"	d
ADDONEEDGE0	nauty.h	524;"	d
ADDONEEDGE1	nauty.h	512;"	d
ADDTONEXTLEVEL	traces.c	454;"	d	file:
ALLBITS	nauty.h	697;"	d
ALLBITS	nauty.h	711;"	d
ALLBITS	nauty.h	720;"	d
ALLMASK	nauty.h	791;"	d
ALLOCS	nauty.h	985;"	d
ALLOCS	nauty.h	989;"	d
ALLOCS	showg.c	113;"	d	file:
ALLOW_INTERRUPT	dreadnaut.c	309;"	d	file:
ALLOW_INTERRUPT	dreadnaut.c	310;"	d	file:
ALLOW_INTERRUPT	gtools.h	38;"	d
ANSIPROT	nauty.h	1168;"	d
ARG_ILLEGAL	gtools.h	147;"	d
ARG_ILLEGAL	showg.c	101;"	d	file:
ARG_MISSING	gtools.h	145;"	d
ARG_MISSING	showg.c	99;"	d	file:
ARG_OK	gtools.h	144;"	d
ARG_OK	showg.c	98;"	d	file:
ARG_TOOBIG	gtools.h	146;"	d
ARG_TOOBIG	showg.c	100;"	d	file:
ASSERT	planarity.h	36;"	d
ATONCE	nauthread1.c	14;"	d	file:
ATONCE	nauthread2.c	15;"	d	file:
AUTOMPROC	dreadnaut.c	218;"	d	file:
Allocate_Traces_Structures	traces.c	/^void Allocate_Traces_Structures(int n) {$/;"	f
Allocate_refine_Structures	traces.c	/^void Allocate_refine_Structures(int n) {$/;"	f
Aswitch	multig.c	/^static boolean Gswitch,Tswitch,Aswitch,Bswitch;$/;"	v	file:
AutomCount	traces.c	806;"	d	file:
B	gtools.c	61;"	d	file:
B	showg.c	66;"	d	file:
BADLIM	cubhamg.c	82;"	d	file:
BE	planarity.h	76;"	d
BEGET1	gtools.c	2266;"	d	file:
BEGET2	gtools.c	2267;"	d	file:
BEGET4	gtools.c	2269;"	d	file:
BEPUT1	gtools.c	2191;"	d	file:
BEPUT2	gtools.c	2192;"	d	file:
BEPUT4	gtools.c	2194;"	d	file:
BIAS6	gtools.h	114;"	d
BIAS6	showg.c	81;"	d	file:
BILDBOOG	watercluster2.c	159;"	d	file:
BILDBOOG_UNDIR	watercluster2.c	156;"	d	file:
BITMASK	nauty.h	696;"	d
BITMASK	nauty.h	710;"	d
BITMASK	nauty.h	719;"	d
BITMASK	nauty.h	785;"	d
BITMASK	nauty.h	788;"	d
BITMASK	showg.c	180;"	d	file:
BITT	nauty.h	500;"	d
BITT	nauty.h	502;"	d
BLUE	twohamg.c	40;"	d	file:
BOOG	watercluster2.c	/^typedef int BOOG[2];$/;"	t	file:
BOOLTYPE	testg.c	129;"	d	file:
Brows	multig.c	/^static int Brows;$/;"	v	file:
Bswitch	multig.c	/^static boolean Gswitch,Tswitch,Aswitch,Bswitch;$/;"	v	file:
C6MASK	gtools.h	119;"	d
C6MASK	showg.c	86;"	d	file:
CANONGNIL	nauty.h	855;"	d
CANONPROC	dreadnaut.c	236;"	d	file:
CATMSG0	gtools.h	188;"	d
CATMSG1	gtools.h	189;"	d
CATMSG2	gtools.h	190;"	d
CATMSG3	gtools.h	191;"	d
CATMSG4	gtools.h	192;"	d
CATMSG5	gtools.h	193;"	d
CATMSG6	gtools.h	194;"	d
CC	makefile	/^CC=gcc$/;"	m
CCLOCKW	planarity.h	73;"	d
CCOBJ	makefile	/^CCOBJ=${CC} -c ${CFLAGS} -o $@$/;"	m
CELLCODE	nausparse.c	1546;"	d	file:
CELLSTART	nausparse.c	655;"	d	file:
CFLAGS	makefile	/^CFLAGS=-O4 -fPIC  -mpopcnt$/;"	m
CHANGE	cubhamg.c	1097;"	d	file:
CHECK_SWG	nausparse.h	35;"	d
CHOISE	genquarticg.c	/^{ accept,reject,undef } CHOISE;$/;"	t	typeref:enum:__anon9	file:
CLEANUP	naugraph.c	31;"	d	file:
CLEANUP	nausparse.c	37;"	d	file:
CLEANUP	nautil.c	77;"	d	file:
CLEANUP	nautinv.c	57;"	d	file:
CLEANUP	traces.c	351;"	d	file:
CLK_TCK	naututil.h	247;"	d
CLK_TCK	naututil.h	250;"	d
CLOCKW	planarity.h	74;"	d
CMASK	testg.c	134;"	d	file:
CMASK	testg.c	135;"	d	file:
COMPARE	testg.c	284;"	d	file:
COMPUTED	testg.c	229;"	d	file:
CONDNL	nautil.c	312;"	d	file:
CONDYNFREE	nauty.h	1035;"	d
CONSOLWIDTH	nauty.h	929;"	d
CONTINUE	sumlines.c	53;"	d	file:
COPYBOOG	watercluster2.c	113;"	d	file:
COPYNODE	traces.c	356;"	d	file:
COPYPART	traces.c	449;"	d	file:
COUNT	nausparse.c	1187;"	d	file:
COUNT	sumlines.c	52;"	d	file:
COUNTER_FMT	nauty.h	441;"	d
COUNTER_FMT	nauty.h	446;"	d
COUNTER_FMT_RAW	nauty.h	442;"	d
COUNTER_FMT_RAW	nauty.h	447;"	d
CPUDEFS	naututil.h	242;"	d
CPUDEFS	naututil.h	258;"	d
CPUTIME	naututil.h	252;"	d
CPUTIME	naututil.h	259;"	d
CPUTIME	naututil.h	266;"	d
CSIZE	watercluster2.c	233;"	d	file:
CURRORBITSIZES	traces.c	472;"	d	file:
CUTV	planarity.h	71;"	d
CYCHIT	traces.c	802;"	d	file:
CYCLES	traces.c	793;"	d	file:
CYCOLR	traces.c	795;"	d	file:
CYCPOS	traces.c	801;"	d	file:
CYCREP	traces.c	804;"	d	file:
CYLGTH	traces.c	797;"	d	file:
CYMULT	traces.c	798;"	d	file:
Candidate	traces.c	/^typedef struct Candidate {$/;"	s	file:
Candidate	traces.c	/^} Candidate;$/;"	t	typeref:struct:Candidate	file:
CanonIndices	traces.c	807;"	d	file:
CellMarkers1	traces.c	810;"	d	file:
CellMarkers2	traces.c	811;"	d	file:
CheckForAutomorphisms	traces.c	/^int CheckForAutomorphisms(Candidate *CurrCand, Candidate *NextCand,$/;"	f
CheckForMatching	traces.c	/^int CheckForMatching(Candidate *CurrCand, Candidate *NextCand, Partition *Part, struct TracesVars* tv, struct TracesInfo* ti, int m, int n) {$/;"	f
CheckForSingAutomorphisms	traces.c	/^int CheckForSingAutomorphisms(Candidate *CurrCand, Partition *NextPart, Candidate *NextCand,$/;"	f
Check_degree_one	traces.c	/^int Check_degree_one(sparsegraph *sg, Candidate *Cand, Partition *Part, int n) {$/;"	f
CodeClassify	traces.c	/^void CodeClassify(int Level, int code, int cell) {$/;"	f
CompStage0	traces.c	/^int CompStage0(Partition *CurrPart, Partition *NextPart, Candidate *CurrCand, Candidate *NextCand,$/;"	f
CompStage1	traces.c	/^int CompStage1(Partition *CurrPart, Partition *NextPart, Candidate *CurrCand, Candidate *NextCand,$/;"	f
CompStage2	traces.c	/^int CompStage2(Partition *CurrPart, Partition *NextPart, Candidate *CurrCand, Candidate *NextCand,$/;"	f
Complete	traces.c	/^void Complete(sparsegraph *sg_orig, Candidate *Cand, Partition *Part, int cell, TracesVars *tv,$/;"	f
ComputeFontsize	dretodot.c	/^double ComputeFontsize(int vtx) {$/;"	f
CopyCand	traces.c	/^void CopyCand(Candidate *W, Candidate *V,int n, int *lab, int *invlab) {$/;"	f
CreateRandColors	dretodot.c	/^void CreateRandColors(int n)$/;"	f
CurrVertices	dretodot.c	/^int CurrVertices[MAXN];$/;"	v
D	sumlines.c	189;"	d	file:
D6BODYLEN	gtools.h	56;"	d
D6LEN	gtools.h	58;"	d
D6LEN	showg.c	61;"	d	file:
DEB	naututil.c	2381;"	d	file:
DEBUG	hamheuristic.c	25;"	d	file:
DEBUG	twohamg.c	32;"	d	file:
DEFAULT	sumlines.c	48;"	d	file:
DEFAULTOPTIONS	nauty.h	945;"	d
DEFAULTOPTIONS_DENSEGRAPH	nauty.h	948;"	d
DEFAULTOPTIONS_DIGRAPH	nauty.h	940;"	d
DEFAULTOPTIONS_GRAPH	nauty.h	937;"	d
DEFAULTOPTIONS_SPARSEDIGRAPH	nausparse.h	82;"	d
DEFAULTOPTIONS_SPARSEGRAPH	nausparse.h	79;"	d
DEFAULTOPTIONS_TRACES	traces.h	45;"	d
DEFAULT_WORDSIZE	nauty.h	27;"	d
DEFEXT	naututil.h	200;"	d
DELELEMENT	nauty.h	529;"	d
DELELEMENT	nauty.h	539;"	d
DELELEMENT0	nauty.h	516;"	d
DELELEMENT1	nauty.h	506;"	d
DENSE_MODE	dreadnaut.c	191;"	d	file:
DFS_parent	planarity.h	/^    int          DFS_parent;$/;"	m	struct:ver_edge
DIE	planarity.h	37;"	d
DIGRAPH6	gtools.h	137;"	d
DIGRAPH6	showg.c	94;"	d	file:
DIGRAPH6_HEADER	gtools.h	123;"	d
DIGRAPH6_HEADER	showg.c	90;"	d	file:
DIST	nausparse.c	1548;"	d	file:
DOPROMPT	naututil.h	225;"	d
DOPROMPT	naututil.h	227;"	d
DOUT	sumlines.c	139;"	d	file:
DOUT	sumlines.c	146;"	d	file:
DOUT	sumlines.c	153;"	d	file:
DUNNO	cubhamg.c	78;"	d	file:
DYNALLOC1	nauty.h	1020;"	d
DYNALLOC1	showg.c	116;"	d	file:
DYNALLOC2	nauty.h	1024;"	d
DYNALLOC2	showg.c	120;"	d	file:
DYNALLSTAT	nauty.h	1018;"	d
DYNALLSTAT	showg.c	115;"	d	file:
DYNFREE	nauty.h	1033;"	d
DYNFREE	showg.c	124;"	d	file:
DYNREALLOC	nauty.h	1029;"	d
DYNREALLOC	showg.c	125;"	d	file:
DistStack	dretodot.c	/^int DistStack[MAXN];$/;"	v
DontWrite	gentreeg.c	/^DontWrite(FILE *f, int vpar[], int n)$/;"	f	file:
ECHUNKSIZE	naututil.c	101;"	d	file:
EDGECODE	gtools.h	134;"	d
EDGECODE_HEADER	gtools.h	127;"	d
EMPTYGRAPH	nauty.h	536;"	d
EMPTYGRAPH	nauty.h	546;"	d
EMPTYGRAPH0	nauty.h	525;"	d
EMPTYGRAPH1	nauty.h	513;"	d
EMPTYSET	nauty.h	532;"	d
EMPTYSET	nauty.h	542;"	d
EMPTYSET	nauty.h	551;"	d
EMPTYSET	nauty.h	552;"	d
EMPTYSET0	nauty.h	519;"	d
EMPTYSET1	nauty.h	509;"	d
ENDFILE	sumlines.c	56;"	d	file:
ERRFILE	naututil.h	196;"	d
ERRFILE	nauty.h	1039;"	d
ERROR	sumlines.c	50;"	d	file:
EXEEXT	makefile	/^EXEEXT=$/;"	m
EXIT	naututil.h	199;"	d
EXITFROMSTAGE0EXPATH1	traces.c	501;"	d	file:
EXITFROMSTAGE0EXPATH2	traces.c	490;"	d	file:
EXITFROMSTAGE0REFINE	traces.c	477;"	d	file:
EXTDEF_CLASS	nauty.h	1043;"	d
EXTDEF_CLASS	nauty.h	1050;"	d
EXTDEF_TYPE	nauty.h	1045;"	d
EXTDEF_TYPE	nauty.h	1047;"	d
EXTDEF_TYPE	nauty.h	1051;"	d
EXTPROC	nauty.h	1169;"	d
Edge_Delete	traces.c	/^void Edge_Delete(int vertex, int sons, Candidate *Cand, TracesVars *tv) {$/;"	f
ElmHitCll	traces.c	5402;"	d	file:
ElmHitCll	traces.c	800;"	d	file:
ExpPathInfo	traces.c	/^typedef struct ExpPathInfo {$/;"	s	file:
ExpPathInfo	traces.c	/^} ExpPathInfo;$/;"	t	typeref:struct:ExpPathInfo	file:
ExperimentalStep	traces.c	/^void ExperimentalStep(Partition *NextPart, Candidate *NextCand,$/;"	f
F	sumlines.c	190;"	d	file:
FALSE	cubhamg.c	75;"	d	file:
FALSE	nauty.h	794;"	d
FALSE	nauty.h	796;"	d
FALSE	planarity.h	29;"	d
FALSE	planarity.h	31;"	d
FALSE	showg.c	189;"	d	file:
FALSE	sumlines.c	170;"	d	file:
FDOPEN_DEC	gtools.h	23;"	d
FINAL	sumlines.c	49;"	d	file:
FIND_PAROP	watercluster2.c	3422;"	d	file:
FIND_SPLIT_CELLS	traces.c	428;"	d	file:
FIRSTBIT	nauty.h	681;"	d
FIRSTBIT	nauty.h	707;"	d
FIRSTBIT	nauty.h	718;"	d
FIRSTBIT	nauty.h	725;"	d
FIRSTBIT	nauty.h	728;"	d
FIRSTBIT	nauty.h	731;"	d
FIRSTBIT	nauty.h	734;"	d
FIRSTBIT	nauty.h	737;"	d
FIRSTBIT	nauty.h	740;"	d
FIRSTBIT	nauty.h	784;"	d
FIRSTBIT	nauty.h	787;"	d
FIRSTBIT	showg.c	177;"	d	file:
FIRSTBITNZ	nauty.h	726;"	d
FIRSTBITNZ	nauty.h	727;"	d
FIRSTBITNZ	nauty.h	732;"	d
FIRSTBITNZ	nauty.h	733;"	d
FIRSTBITNZ	nauty.h	738;"	d
FIRSTBITNZ	nauty.h	739;"	d
FIRSTBITNZ	nauty.h	744;"	d
FISHTAIL	twohamg.c	33;"	d	file:
FLIPELEMENT	nauty.h	530;"	d
FLIPELEMENT	nauty.h	540;"	d
FLIPELEMENT0	nauty.h	517;"	d
FLIPELEMENT1	nauty.h	507;"	d
FLOCKFILE	gtools.h	101;"	d
FLOCKFILE	gtools.h	107;"	d
FLUSHANDPROMPT	dreadnaut.c	129;"	d	file:
FONT_NAME	dretodot.c	85;"	d	file:
FORALLELEMENTS	watercluster2.c	253;"	d	file:
FORALLELEMENTS_BOUND	watercluster2.c	254;"	d	file:
FOUT	sumlines.c	140;"	d	file:
FOUT	sumlines.c	147;"	d	file:
FOUT	sumlines.c	154;"	d	file:
FREECAND	traces.c	443;"	d	file:
FREEPART	traces.c	437;"	d	file:
FREES	nauty.h	987;"	d
FREES	nauty.h	991;"	d
FREES	showg.c	112;"	d	file:
FSA	genspecialg.c	286;"	d	file:
FSB	genspecialg.c	287;"	d	file:
FSC	genspecialg.c	288;"	d	file:
FSD	genspecialg.c	289;"	d	file:
FSEEK_VER	gtools.c	18;"	d	file:
FSEEK_VER	gtools.c	26;"	d	file:
FTELL_DEC	gtools.h	22;"	d
FTELL_VER	gtools.c	19;"	d	file:
FTELL_VER	gtools.c	27;"	d	file:
FUNLOCKFILE	gtools.h	102;"	d
FUNLOCKFILE	gtools.h	108;"	d
FUZZ1	nausparse.c	52;"	d	file:
FUZZ1	nautinv.c	67;"	d	file:
FUZZ1	naututil.c	122;"	d	file:
FUZZ1	traces.c	344;"	d	file:
FUZZ2	gtnauty.c	19;"	d	file:
FUZZ2	nausparse.c	53;"	d	file:
FUZZ2	nautinv.c	68;"	d	file:
FUZZ2	naututil.c	123;"	d	file:
FUZZ2	traces.c	345;"	d	file:
FirstNeighbour	traces.c	/^int FirstNeighbour(int vtx, Candidate *Cand, Partition *Part, int* Markers, int mark, int *ngh, int n) {$/;"	f
FixBase	traces.c	/^int FixBase(int *fix, struct TracesVars *tv, Candidate *Cand, int from, int to) {$/;"	f
FixedBase	traces.c	/^boolean FixedBase(int *fix, struct TracesVars *tv, Candidate *Cand, int from, int to) {$/;"	f
FreeList	traces.c	/^int FreeList(Candidate *List, int cond) {$/;"	f
G6BODYLEN	gtools.h	50;"	d
G6LEN	gtools.h	52;"	d
G6LEN	showg.c	59;"	d	file:
GENG_MAIN	geng.c	/^GENG_MAIN(int argc, char *argv[])$/;"	f
GENG_MAIN	gentourng.c	/^GENG_MAIN(int argc, char *argv[])$/;"	f
GENTREEG_MAIN	gentreeg.c	/^GENTREEG_MAIN(int argc, char *argv[])$/;"	f
GETC	gtools.h	103;"	d
GETC	gtools.h	109;"	d
GETHELP	gtools.h	183;"	d
GETKRAN	naurng.h	34;"	d
GETKRAN	rng.h	34;"	d
GETNW	naututil.c	109;"	d	file:
GETNW	naututil.c	113;"	d	file:
GETNWC	naututil.c	110;"	d	file:
GETNWC	naututil.c	114;"	d	file:
GETNWL	naututil.c	111;"	d	file:
GETNWL	naututil.c	115;"	d	file:
GETTYPE	watercluster2.c	152;"	d	file:
GLOB_BRACE	sumlines.c	240;"	d	file:
GLOB_FLAGS	sumlines.c	251;"	d	file:
GLOB_NOMATCH	sumlines.c	248;"	d	file:
GLOB_TILDE	sumlines.c	244;"	d	file:
GMP	sumlines.c	5;"	d	file:
GRAPH6	gtools.h	129;"	d
GRAPH6	showg.c	92;"	d	file:
GRAPH6_HEADER	gtools.h	121;"	d
GRAPH6_HEADER	showg.c	88;"	d	file:
GRAPHROW	nauty.h	533;"	d
GRAPHROW	nauty.h	543;"	d
GRAPHROW	showg.c	187;"	d	file:
GRAPHROW0	nauty.h	522;"	d
GRAPHROW1	nauty.h	510;"	d
GRAPHSIZE	nauthread1.c	15;"	d	file:
GRAPHSIZE	nauthread2.c	16;"	d	file:
GROUPSIZE	testg.c	131;"	d	file:
GROUPTEST_NOT	multig.c	55;"	d	file:
GROUPTEST_NOT	vcolg.c	41;"	d	file:
GTOOLSH	makefile	/^GTOOLSH=gtools.h nauty.h naututil.h nausparse.h naurng.h$/;"	m
GarbList	traces.c	/^static TLS_ATTR Candidate *GarbList, *SpOrd, *SpCyc, *SpSwp;$/;"	v	file:
Gen	gentreeg.c	/^Gen( int level, int p, int s, int cL, int h, int l, int n, int f, int g )$/;"	f	file:
Gswitch	directg.c	/^static boolean Gswitch,Vswitch,ntgroup,ntisol,digraph6;$/;"	v	file:
Gswitch	multig.c	/^static boolean Gswitch,Tswitch,Aswitch,Bswitch;$/;"	v	file:
H	dreadnaut.c	2418;"	d	file:
H	sumlines.c	196;"	d	file:
HABORT	cubhamg.c	80;"	d	file:
HAS	sumlines.c	122;"	d	file:
HAS_HEADER	gtools.h	139;"	d
HAS_HEADER	showg.c	96;"	d	file:
HAS_MATH_INF	nauty.h	22;"	d
HAS_STDIO_UNLOCK	nauty.h	24;"	d
HAVE_CLZ	nauty.h	51;"	d
HAVE_CLZL	nauty.h	52;"	d
HAVE_CLZLL	nauty.h	53;"	d
HAVE_CONST	nauty.h	33;"	d
HAVE_ERRNO_H	gtools.h	15;"	d
HAVE_FORK	gtools.h	31;"	d
HAVE_FSEEKO	gtools.h	35;"	d
HAVE_GETRUSAGE	naututil.h	16;"	d
HAVE_GETTIMEOFDAY	naututil.h	17;"	d
HAVE_HWPOPCMT	nauty.h	63;"	d
HAVE_ISATTY	naututil.h	13;"	d
HAVE_MMPOP32	nauty.h	67;"	d
HAVE_MMPOP64	nauty.h	68;"	d
HAVE_PERROR	gtools.h	16;"	d
HAVE_PID_T	gtools.h	26;"	d
HAVE_PIPE	gtools.h	17;"	d
HAVE_POPCNT	nauty.h	64;"	d
HAVE_POPCNTL	nauty.h	65;"	d
HAVE_POPCNTLL	nauty.h	66;"	d
HAVE_POPEN	gtools.h	20;"	d
HAVE_PTHREADS	gtools.h	32;"	d
HAVE_PTHREAD_H	gtools.h	33;"	d
HAVE_PUTENV	gtools.h	29;"	d
HAVE_SETENV	gtools.h	30;"	d
HAVE_SIGACTION	gtools.h	36;"	d
HAVE_SIGNAL_H	gtools.h	34;"	d
HAVE_SIGPROCMASK	gtools.h	37;"	d
HAVE_STDDEF_H	nauty.h	17;"	d
HAVE_STDLIB_H	nauty.h	18;"	d
HAVE_STRING_H	nauty.h	19;"	d
HAVE_SYSTYPES_H	nauty.h	16;"	d
HAVE_TIME	naututil.h	15;"	d
HAVE_TIMES	naututil.h	14;"	d
HAVE_TLS	nauty.h	37;"	d
HAVE_UNISTD_H	nauty.h	15;"	d
HAVE_WAIT	gtools.h	18;"	d
HAVE_WAIT_H	gtools.h	19;"	d
HELP	gtools.h	173;"	d
HELP	sumlines.c	253;"	d	file:
HELPTEXT	NRswitchg.c	5;"	d	file:
HELPTEXT	addedgeg.c	5;"	d	file:
HELPTEXT	amtog.c	5;"	d	file:
HELPTEXT	biplabg.c	5;"	d	file:
HELPTEXT	blisstog.c	5;"	d	file:
HELPTEXT	catg.c	5;"	d	file:
HELPTEXT	checks6.c	5;"	d	file:
HELPTEXT	complg.c	5;"	d	file:
HELPTEXT	converseg.c	5;"	d	file:
HELPTEXT	copyg.c	5;"	d	file:
HELPTEXT	deledgeg.c	5;"	d	file:
HELPTEXT	delptg.c	5;"	d	file:
HELPTEXT	directg.c	6;"	d	file:
HELPTEXT	dreadnaut.c	116;"	d	file:
HELPTEXT	dretodot.c	10;"	d	file:
HELPTEXT	dretog.c	5;"	d	file:
HELPTEXT	genbg.c	9;"	d	file:
HELPTEXT	geng.c	12;"	d	file:
HELPTEXT	genquarticg.c	48;"	d	file:
HELPTEXT	genrang.c	8;"	d	file:
HELPTEXT	genspecialg.c	7;"	d	file:
HELPTEXT	gentourng.c	6;"	d	file:
HELPTEXT	gentreeg.c	9;"	d	file:
HELPTEXT	hamheuristic.c	5;"	d	file:
HELPTEXT	labelg.c	5;"	d	file:
HELPTEXT	linegraphg.c	5;"	d	file:
HELPTEXT	listg.c	7;"	d	file:
HELPTEXT	multig.c	7;"	d	file:
HELPTEXT	newedgeg.c	5;"	d	file:
HELPTEXT	planarg.c	5;"	d	file:
HELPTEXT	ranlabg.c	5;"	d	file:
HELPTEXT	shortg.c	6;"	d	file:
HELPTEXT	showg.c	10;"	d	file:
HELPTEXT	subdivideg.c	5;"	d	file:
HELPTEXT	sumlines.c	13;"	d	file:
HELPTEXT	testg.c	9;"	d	file:
HELPTEXT	twohamg.c	5;"	d	file:
HELPTEXT	vcolg.c	7;"	d	file:
HI	testg.c	232;"	d	file:
HITCELL	nausparse.c	658;"	d	file:
HITS	nausparse.c	1186;"	d	file:
HITS	nausparse.c	657;"	d	file:
HMSOUT1	sumlines.c	142;"	d	file:
HMSOUT1	sumlines.c	149;"	d	file:
HMSOUT1	sumlines.c	156;"	d	file:
HMSOUT2	sumlines.c	143;"	d	file:
HMSOUT2	sumlines.c	150;"	d	file:
HMSOUT2	sumlines.c	157;"	d	file:
HitCls	traces.c	5400;"	d	file:
HitCls	traces.c	794;"	d	file:
HitCount	traces.c	799;"	d	file:
HitVtx	traces.c	5401;"	d	file:
HitVtx	traces.c	796;"	d	file:
ID	testg.c	235;"	d	file:
ID_PERMNODE	schreier.c	15;"	d	file:
IFLE1BITS	genbg.c	241;"	d	file:
IF_CPU	planarity.c	2521;"	d	file:
IF_CPU	planarity.c	4621;"	d	file:
IF_CPU	planarity.c	5866;"	d	file:
IF_CPU	planarity.c	6224;"	d	file:
IF_CPU	planarity.c	6973;"	d	file:
IF_CPU	planarity.c	8105;"	d	file:
IF_CPU	planarity.c	8928;"	d	file:
IF_DEB	planarity.c	10158;"	d	file:
IF_DEB	planarity.c	1046;"	d	file:
IF_DEB	planarity.c	1218;"	d	file:
IF_DEB	planarity.c	1476;"	d	file:
IF_DEB	planarity.c	2112;"	d	file:
IF_DEB	planarity.c	2517;"	d	file:
IF_DEB	planarity.c	2812;"	d	file:
IF_DEB	planarity.c	3009;"	d	file:
IF_DEB	planarity.c	34;"	d	file:
IF_DEB	planarity.c	3536;"	d	file:
IF_DEB	planarity.c	3722;"	d	file:
IF_DEB	planarity.c	3854;"	d	file:
IF_DEB	planarity.c	4297;"	d	file:
IF_DEB	planarity.c	4611;"	d	file:
IF_DEB	planarity.c	5862;"	d	file:
IF_DEB	planarity.c	604;"	d	file:
IF_DEB	planarity.c	6220;"	d	file:
IF_DEB	planarity.c	6836;"	d	file:
IF_DEB	planarity.c	6969;"	d	file:
IF_DEB	planarity.c	7448;"	d	file:
IF_DEB	planarity.c	8099;"	d	file:
IF_DEB	planarity.c	8700;"	d	file:
IF_DEB	planarity.c	8924;"	d	file:
IF_DEB_ADJL	planarity.c	3855;"	d	file:
IF_DEB_BE	planarity.c	3011;"	d	file:
IF_DEB_CHECK_EMBED	planarity.c	4615;"	d	file:
IF_DEB_CHECK_EMBED	planarity.c	8101;"	d	file:
IF_DEB_CHECK_OBS	planarity.c	4620;"	d	file:
IF_DEB_CHECK_OBS	planarity.c	5865;"	d	file:
IF_DEB_DFS	planarity.c	6970;"	d	file:
IF_DEB_EDGES	planarity.c	2520;"	d	file:
IF_DEB_EDGES	planarity.c	6223;"	d	file:
IF_DEB_EDGES	planarity.c	8927;"	d	file:
IF_DEB_EMBED	planarity.c	3010;"	d	file:
IF_DEB_EMBED	planarity.c	4298;"	d	file:
IF_DEB_EMBED	planarity.c	4614;"	d	file:
IF_DEB_EMBED	planarity.c	8100;"	d	file:
IF_DEB_EMBED_LOOPS	planarity.c	4613;"	d	file:
IF_DEB_EMBED_MULT	planarity.c	4612;"	d	file:
IF_DEB_FACES	planarity.c	4616;"	d	file:
IF_DEB_FACES	planarity.c	8102;"	d	file:
IF_DEB_MINOR	planarity.c	5867;"	d	file:
IF_DEB_OBS	planarity.c	4619;"	d	file:
IF_DEB_OBS	planarity.c	5864;"	d	file:
IF_DEB_PROPER_FACE	planarity.c	10159;"	d	file:
IF_DEB_PROPER_FACE	planarity.c	1478;"	d	file:
IF_DEB_SCE	planarity.c	1477;"	d	file:
IF_DEB_SCE	planarity.c	3012;"	d	file:
IF_DEB_SCE	planarity.c	4618;"	d	file:
IF_DEB_SCE	planarity.c	8104;"	d	file:
IF_DEB_TREE	planarity.c	2519;"	d	file:
IF_DEB_TREE	planarity.c	6222;"	d	file:
IF_DEB_TREE	planarity.c	6838;"	d	file:
IF_DEB_TREE	planarity.c	6972;"	d	file:
IF_DEB_TREE	planarity.c	7450;"	d	file:
IF_DEB_TREE	planarity.c	8926;"	d	file:
IF_VERB	planarity.c	10160;"	d	file:
IF_VERB	planarity.c	1047;"	d	file:
IF_VERB	planarity.c	1219;"	d	file:
IF_VERB	planarity.c	1479;"	d	file:
IF_VERB	planarity.c	2113;"	d	file:
IF_VERB	planarity.c	2518;"	d	file:
IF_VERB	planarity.c	2813;"	d	file:
IF_VERB	planarity.c	3013;"	d	file:
IF_VERB	planarity.c	3537;"	d	file:
IF_VERB	planarity.c	35;"	d	file:
IF_VERB	planarity.c	3723;"	d	file:
IF_VERB	planarity.c	3856;"	d	file:
IF_VERB	planarity.c	4299;"	d	file:
IF_VERB	planarity.c	4617;"	d	file:
IF_VERB	planarity.c	5863;"	d	file:
IF_VERB	planarity.c	605;"	d	file:
IF_VERB	planarity.c	6221;"	d	file:
IF_VERB	planarity.c	6837;"	d	file:
IF_VERB	planarity.c	6971;"	d	file:
IF_VERB	planarity.c	7449;"	d	file:
IF_VERB	planarity.c	8103;"	d	file:
IF_VERB	planarity.c	8701;"	d	file:
IF_VERB	planarity.c	8925;"	d	file:
INBOUNDS	testg.c	240;"	d	file:
INBOUNDS0	testg.c	238;"	d	file:
INCR	sumlines.c	164;"	d	file:
INCSPARSE6	gtools.h	135;"	d
INFILE	dreadnaut.c	137;"	d	file:
INFINITY	nauty.h	812;"	d
INFTY_UCHAR	watercluster2.c	87;"	d	file:
INITRANBYTIME	naurng.h	37;"	d
INITRANBYTIME	rng.h	37;"	d
INITSEED	naututil.h	276;"	d
INITSEED	naututil.h	284;"	d
INSERT_ARGS	testg.c	283;"	d	file:
INTERSECT	nauty.h	557;"	d
INTTYPE	testg.c	130;"	d	file:
INTVECTOR	testg.c	132;"	d	file:
INVARPROC	dreadnaut.c	242;"	d	file:
INVARPROCNAME	dreadnaut.c	243;"	d	file:
INVARPROCNAME	dreadnaut.c	246;"	d	file:
INVARPROCNAME_SG	dreadnaut.c	251;"	d	file:
INVARPROCNAME_SG	dreadnaut.c	254;"	d	file:
INVARPROC_SG	dreadnaut.c	250;"	d	file:
INVERSE	testg.c	228;"	d	file:
INVLAB	nausparse.c	240;"	d	file:
INVLAB	nausparse.c	309;"	d	file:
ISCONSTRAINT	testg.c	227;"	d	file:
ISDIGIT	naututil.c	118;"	d	file:
ISDIGOK	testg.c	236;"	d	file:
ISELEMENT	nauty.h	531;"	d
ISELEMENT	nauty.h	541;"	d
ISELEMENT	showg.c	185;"	d	file:
ISELEMENT0	nauty.h	518;"	d
ISELEMENT1	nauty.h	508;"	d
ISKEY	testg.c	226;"	d	file:
ISMARKED	genspecialg.c	44;"	d	file:
ISMARKED	watercluster2.c	179;"	d	file:
ISMARKED1	nausparse.c	82;"	d	file:
ISMARKED2	nausparse.c	88;"	d	file:
ISMARKED_COLOUR	watercluster2.c	240;"	d	file:
ISNEEDED	testg.c	224;"	d	file:
ISNOTMARKED	genspecialg.c	45;"	d	file:
ISNOTMARKED1	nausparse.c	83;"	d	file:
ISNOTMARKED2	nausparse.c	89;"	d	file:
I_B	testg.c	176;"	d	file:
I_C	testg.c	212;"	d	file:
I_D	testg.c	158;"	d	file:
I_E	testg.c	172;"	d	file:
I_F	testg.c	190;"	d	file:
I_H	testg.c	208;"	d	file:
I_I	testg.c	198;"	d	file:
I_J	testg.c	202;"	d	file:
I_K	testg.c	206;"	d	file:
I_L	testg.c	154;"	d	file:
I_M	testg.c	166;"	d	file:
I_Q	testg.c	214;"	d	file:
I_S	testg.c	170;"	d	file:
I_T	testg.c	204;"	d	file:
I_U	testg.c	162;"	d	file:
I_Y	testg.c	194;"	d	file:
I_Z	testg.c	180;"	d	file:
I_a	testg.c	182;"	d	file:
I_b	testg.c	210;"	d	file:
I_c	testg.c	188;"	d	file:
I_d	testg.c	156;"	d	file:
I_e	testg.c	152;"	d	file:
I_g	testg.c	192;"	d	file:
I_i	testg.c	196;"	d	file:
I_j	testg.c	200;"	d	file:
I_m	testg.c	164;"	d	file:
I_n	testg.c	150;"	d	file:
I_o	testg.c	184;"	d	file:
I_r	testg.c	174;"	d	file:
I_s	testg.c	168;"	d	file:
I_t	testg.c	186;"	d	file:
I_u	testg.c	160;"	d	file:
I_z	testg.c	178;"	d	file:
Individualize	traces.c	/^void Individualize(Partition *NextPart, Candidate *NextCand, int K, int Tc, int Cl, int Pos) {$/;"	f
Initialize_Traces_Statistics	traces.c	/^void Initialize_Traces_Statistics (TracesStats *stats_arg, int n) {$/;"	f
Initialize_Traces_Time_Variables	traces.c	/^void Initialize_Traces_Time_Variables (TracesVars *tv) {$/;"	f
Initialize_Traces_Variables	traces.c	/^void Initialize_Traces_Variables(TracesVars *tv, TracesOptions *options_arg,$/;"	f
KK	naurng.c	48;"	d	file:
KK	rng.c	43;"	d	file:
KRAN	naurng.h	30;"	d
KRAN	rng.h	30;"	d
L	makefile	/^L=-DWORDSIZE=64$/;"	m
L	sumlines.c	232;"	d	file:
L1	makefile	/^L1=-DMAXN=WORDSIZE -DWORDSIZE=64$/;"	m
LABELONLY	nauty.h	892;"	d
LABELORG	listg.c	50;"	d	file:
LABELORG	showg.c	861;"	d	file:
LCHILD	splay.c	167;"	d	file:
LCHILD	sumlines.c	514;"	d	file:
LD	sumlines.c	195;"	d	file:
LDFLAGS	makefile	/^LDFLAGS= $/;"	m
LEGET1	gtools.c	2354;"	d	file:
LEGET2	gtools.c	2355;"	d	file:
LEGET4	gtools.c	2357;"	d	file:
LEV1	genquarticg.c	19;"	d	file:
LEV2	genquarticg.c	20;"	d	file:
LEVELPROC	dreadnaut.c	224;"	d	file:
LGHATTR	traces.c	803;"	d	file:
LINE	traces.c	376;"	d	file:
LINELEN	listg.c	51;"	d	file:
LINELEN	showg.c	862;"	d	file:
LL	naurng.c	49;"	d	file:
LL	rng.c	44;"	d	file:
LL	sumlines.c	234;"	d	file:
LO	testg.c	231;"	d	file:
LOK	makefile	/^LOK=1         # 0 if no 64-bit integers$/;"	m
LONG_LONG_COUNTERS	nauty.h	440;"	d
LONG_LONG_COUNTERS	nauty.h	445;"	d
LOOKUP_ARGS	splay.c	107;"	d	file:
LR	sumlines.c	235;"	d	file:
M	gtools.c	62;"	d	file:
M	naugraph.c	36;"	d	file:
M	naugraph.c	38;"	d	file:
M	nausparse.c	42;"	d	file:
M	nausparse.c	44;"	d	file:
M	nautaux.c	30;"	d	file:
M	nautaux.c	32;"	d	file:
M	nautil.c	82;"	d	file:
M	nautil.c	84;"	d	file:
M	nautinv.c	48;"	d	file:
M	nautinv.c	50;"	d	file:
M	naututil.c	88;"	d	file:
M	naututil.c	90;"	d	file:
M	nauty.c	105;"	d	file:
M	nauty.c	107;"	d	file:
M	showg.c	67;"	d	file:
M	sumlines.c	191;"	d	file:
MAKEIMAGE	watercluster2.c	1465;"	d	file:
MALLOC_DEC	nauty.h	20;"	d
MAPLE_MATRIX	listg.c	39;"	d	file:
MARK	genspecialg.c	42;"	d	file:
MARK	watercluster2.c	181;"	d	file:
MARK1	nausparse.c	80;"	d	file:
MARK2	nausparse.c	86;"	d	file:
MARK_COLOUR	watercluster2.c	239;"	d	file:
MARK_EMBED	planarity.h	85;"	d
MARK_EXT_FACE	planarity.h	86;"	d
MARK_EXT_FACE_L	planarity.h	87;"	d
MARK_EXT_FACE_R	planarity.h	88;"	d
MARK_MINORS	planarity.h	90;"	d
MARK_X_Y_PATH	planarity.h	89;"	d
MASH	naugraph.c	27;"	d	file:
MASH	nausparse.c	33;"	d	file:
MASH	nautil.c	73;"	d	file:
MASH	nautinv.c	53;"	d	file:
MASH	traces.c	349;"	d	file:
MASH1	traces.c	350;"	d	file:
MASHCOMM	traces.c	347;"	d	file:
MASHNONCOMM	traces.c	348;"	d	file:
MAXA	cubhamg.c	83;"	d	file:
MAXARG	gtools.h	149;"	d
MAXARG	showg.c	103;"	d	file:
MAXARGS	genspecialg.c	35;"	d	file:
MAXBYTE	gtools.h	115;"	d
MAXBYTE	showg.c	82;"	d	file:
MAXCLIQUE	nautinv.c	70;"	d	file:
MAXDE	planarity.h	68;"	d
MAXDIFFS	naucompare.c	11;"	d	file:
MAXE	genquarticg.c	27;"	d	file:
MAXE	planarity.h	67;"	d
MAXES	cubhamg.c	183;"	d	file:
MAXFORMATS	sumlines.c	203;"	d	file:
MAXIFILES	naututil.h	198;"	d
MAXKEYS	testg.c	246;"	d	file:
MAXLINELEN	naucompare.c	10;"	d	file:
MAXLINELEN	sumlines.c	198;"	d	file:
MAXLREG	genrang.c	36;"	d	file:
MAXM	nauty.h	466;"	d
MAXM	nauty.h	468;"	d
MAXME	directg.c	43;"	d	file:
MAXN	cubhamg.c	58;"	d	file:
MAXN	genbg.c	152;"	d	file:
MAXN	genbg.c	153;"	d	file:
MAXN	geng.c	389;"	d	file:
MAXN	genquarticg.c	18;"	d	file:
MAXN	gentourng.c	176;"	d	file:
MAXN	gentreeg.c	48;"	d	file:
MAXN	gtools.h	45;"	d
MAXN	nauty.h	465;"	d
MAXN	nautyex1.c	7;"	d	file:
MAXN	poptest.c	9;"	d	file:
MAXN	showg.c	57;"	d	file:
MAXN1	genbg.c	156;"	d	file:
MAXNE	cubhamg.c	74;"	d	file:
MAXNE	directg.c	39;"	d	file:
MAXNE	multig.c	41;"	d	file:
MAXNE	vcolg.c	29;"	d	file:
MAXNV	directg.c	38;"	d	file:
MAXNV	multig.c	40;"	d	file:
MAXNV	vcolg.c	28;"	d	file:
MAXOUTLEN	gentreeg.c	122;"	d	file:
MAXP	genquarticg.c	28;"	d	file:
MAXPAROPS	watercluster2.c	143;"	d	file:
MAXPAR_ORBSIZE	watercluster2.c	142;"	d	file:
MAXRAN	naurng.h	28;"	d
MAXRAN	rng.h	28;"	d
MAXREG	naututil.h	192;"	d
MAXSAFE	naurng.h	33;"	d
MAXSAFE	rng.h	33;"	d
MAXVALUES	sumlines.c	200;"	d	file:
MAX_BOGEN	watercluster2.c	86;"	d	file:
MAX_LEVELS	traces.c	9541;"	d	file:
MAYBEPROCESS	watercluster2.c	282;"	d	file:
MAYBEPROCESS	watercluster2.c	284;"	d	file:
MINOR_A	planarity.h	/^    MINOR_A,$/;"	e	enum:__anon2
MINOR_B	planarity.h	/^    MINOR_B,$/;"	e	enum:__anon2
MINOR_C	planarity.h	/^    MINOR_C,$/;"	e	enum:__anon2
MINOR_D	planarity.h	/^    MINOR_D,$/;"	e	enum:__anon2
MINOR_E	planarity.h	/^    MINOR_E,$/;"	e	enum:__anon2
MINOR_E1	planarity.h	/^    MINOR_E1,$/;"	e	enum:__anon2
MINOR_E2	planarity.h	/^    MINOR_E2,$/;"	e	enum:__anon2
MINOR_E3	planarity.h	/^    MINOR_E3,$/;"	e	enum:__anon2
MINOR_E4	planarity.h	/^    MINOR_E4,$/;"	e	enum:__anon2
MINOR_E5	planarity.h	/^    MINOR_E5,$/;"	e	enum:__anon2
MIN_EMBED_MARK	planarity.h	91;"	d
MIN_SCHREIER	gtnauty.c	27;"	d	file:
MM	naurng.c	50;"	d	file:
MM	rng.c	45;"	d	file:
MSK0808	nauty.h	572;"	d
MSK0808	nauty.h	590;"	d
MSK0808	nauty.h	608;"	d
MSK0824	nauty.h	571;"	d
MSK0824	nauty.h	589;"	d
MSK0824	nauty.h	607;"	d
MSK0840	nauty.h	569;"	d
MSK0840	nauty.h	587;"	d
MSK0840	nauty.h	605;"	d
MSK0856	nauty.h	567;"	d
MSK0856	nauty.h	585;"	d
MSK0856	nauty.h	603;"	d
MSK15C	nauty.h	575;"	d
MSK15C	nauty.h	593;"	d
MSK15C	nauty.h	611;"	d
MSK16	nauty.h	578;"	d
MSK16	nauty.h	596;"	d
MSK16	nauty.h	614;"	d
MSK1616	nauty.h	570;"	d
MSK1616	nauty.h	588;"	d
MSK1616	nauty.h	606;"	d
MSK1632	nauty.h	568;"	d
MSK1632	nauty.h	586;"	d
MSK1632	nauty.h	604;"	d
MSK1648	nauty.h	566;"	d
MSK1648	nauty.h	584;"	d
MSK1648	nauty.h	602;"	d
MSK31C	nauty.h	574;"	d
MSK31C	nauty.h	592;"	d
MSK31C	nauty.h	610;"	d
MSK32	nauty.h	577;"	d
MSK32	nauty.h	595;"	d
MSK32	nauty.h	613;"	d
MSK3232	nauty.h	565;"	d
MSK3232	nauty.h	583;"	d
MSK3232	nauty.h	601;"	d
MSK63C	nauty.h	573;"	d
MSK63C	nauty.h	591;"	d
MSK63C	nauty.h	609;"	d
MSK64	nauty.h	576;"	d
MSK64	nauty.h	594;"	d
MSK64	nauty.h	612;"	d
MSK8	nauty.h	579;"	d
MSK8	nauty.h	597;"	d
MSK8	nauty.h	615;"	d
MTOOBIG	nauty.h	854;"	d
MULTIPLY	nauty.h	860;"	d
MakeCanTree	traces.c	/^void MakeCanTree(int v1, sparsegraph *sg_orig, int n, Candidate *Cand, Partition *Part, struct TracesVars* tv) {$/;"	f
MakeDiscrete	traces.c	/^void MakeDiscrete(Partition *Part, int cell) {$/;"	f
MakeTree	traces.c	/^void MakeTree(int v1, int v2, sparsegraph *sg, int n, struct TracesVars* tv, boolean forceautom) {$/;"	f
NAUABORTED	nauty.h	856;"	d
NAUKILLED	nauty.h	857;"	d
NAURNG_H	naurng.h	39;"	d
NAUTY1O	makefile	/^NAUTY1O=nauty1.o nautil1.o nausparse.o naugraph1.o schreier.o naurng.o$/;"	m
NAUTYL1O	makefile	/^NAUTYL1O=nautyL1.o nautilL1.o nausparseL.o naugraphL1.o schreierL.o naurng.o$/;"	m
NAUTYLO	makefile	/^NAUTYLO=nautyL.o nautilL.o nausparseL.o naugraphL.o schreierL.o naurng.o$/;"	m
NAUTYO	makefile	/^NAUTYO=nauty.o nautil.o nausparse.o naugraph.o schreier.o naurng.o$/;"	m
NAUTYREQUIRED	nauty.h	452;"	d
NAUTYS1O	makefile	/^NAUTYS1O=nautyS1.o nautilS1.o nausparseS.o naugraphS1.o schreierS.o naurng.o$/;"	m
NAUTYSO	makefile	/^NAUTYSO=nautyS.o nautilS.o nausparseS.o naugraphS.o schreierS.o naurng.o$/;"	m
NAUTYVERSION	nauty.h	455;"	d
NAUTYVERSION	nauty.h	458;"	d
NAUTYVERSION	nauty.h	461;"	d
NAUTYVERSIONID	nauty.h	451;"	d
NAUTYW1O	makefile	/^NAUTYW1O=nautyW1.o nautilW1.o nausparseW.o naugraphW1.o schreierW.o naurng.o$/;"	m
NAUTYWO	makefile	/^NAUTYWO=nautyW.o nautilW.o nausparseW.o naugraphW.o schreierW.o naurng.o$/;"	m
NAUTY_ABORTED	nauty.c	79;"	d	file:
NAUTY_ABORTED	traces.c	50;"	d	file:
NAUTY_INFINITY	nauty.h	800;"	d
NAUTY_INFINITY	nauty.h	802;"	d
NAUTY_KILLED	nauty.c	80;"	d	file:
NAUTY_KILLED	traces.c	51;"	d	file:
NAUTY_PGM	genbg.c	151;"	d	file:
NAUTY_PGM	geng.c	386;"	d	file:
NAUTY_PGM	gentourng.c	173;"	d	file:
NBR_MINORS	planarity.h	/^    NBR_MINORS$/;"	e	enum:__anon2
NEEDED	testg.c	225;"	d	file:
NEWPARTSPINE	traces.c	412;"	d	file:
NEWPOPC	poptest.c	29;"	d	file:
NEWPOPC	poptest.c	32;"	d	file:
NEWPOPC	poptest.c	35;"	d	file:
NEWPOPC	poptest.c	38;"	d	file:
NEWPOPC	poptest.c	41;"	d	file:
NEWPOPC	poptest.c	44;"	d	file:
NEXTEL	watercluster2.c	252;"	d	file:
NEXTLINE	traces.c	363;"	d	file:
NEXTRAN	naurng.h	29;"	d
NEXTRAN	rng.h	29;"	d
NIL	planarity.h	70;"	d
NILFUNCTION	nauty.h	933;"	d
NILGRAPH	nauty.h	935;"	d
NILSET	nauty.h	934;"	d
NILSIGN	planarity.h	72;"	d
NNTCELL	nausparse.c	1185;"	d	file:
NO	cubhamg.c	79;"	d	file:
NO	hamheuristic.c	31;"	d	file:
NO	twohamg.c	43;"	d	file:
NOBIP	genrang.c	896;"	d	file:
NODENSEYET	dreadnaut.c	197;"	d	file:
NODEPROC	dreadnaut.c	212;"	d	file:
NODIGRAPHSYET	gtools.h	141;"	d
NOLIMIT	gtools.h	150;"	d
NOLIMIT	showg.c	104;"	d	file:
NOSPARSEYET	dreadnaut.c	195;"	d	file:
NOTHING	twohamg.c	46;"	d	file:
NOTRACESYET	dreadnaut.c	199;"	d	file:
NOTSUBSET	nauty.h	555;"	d
NOT_PRESENT	testg.c	288;"	d	file:
NOT_READY	watercluster2.c	204;"	d	file:
NO_LIMIT	cubhamg.c	93;"	d	file:
NP	planarity.h	34;"	d
NRswitch	NRswitchg.c	/^NRswitch(graph *g, int m, int n, int v, graph *h)$/;"	f
NSFCells	traces.c	808;"	d	file:
NShape	dretodot.c	/^NodeShape NShape[MAXN];$/;"	v
NTOOBIG	nauty.h	853;"	d
NUMCONSTRAINTS	testg.c	222;"	d	file:
NUMERIC	sumlines.c	54;"	d	file:
NUMINVARS	dreadnaut.c	283;"	d	file:
NUMINVARS	labelg.c	87;"	d	file:
NUMINVARS	shortg.c	136;"	d	file:
NUMIRRED	quarticirred28.h	316;"	d
NUMLIMITS	twohamg.c	95;"	d	file:
NUMMAXNODES	cubhamg.c	98;"	d	file:
NUMSPECIALS	naucompare.c	42;"	d	file:
NewCandidate	traces.c	/^struct Candidate *NewCandidate(int n, Candidate **GarbList, int Mrk) {$/;"	f
NewListelem	dretodot.c	/^struct list *NewListelem(int el)$/;"	f
NewPartSpine	traces.c	/^void NewPartSpine(int Lev, int n) {$/;"	f
NewPartition	traces.c	/^struct Partition *NewPartition(int n) {$/;"	f
NextNeighbour	traces.c	/^int NextNeighbour(int vtx, Candidate *Cand, Partition *Part, int* Markers, int mark, int *ngh, int n) {$/;"	f
NodeShape	dretodot.c	/^typedef struct NodeShape {$/;"	s	file:
NodeShape	dretodot.c	/^} NodeShape;$/;"	t	typeref:struct:NodeShape	file:
NonSingDeg	traces.c	/^int NonSingDeg(int vtx, Candidate *Cand, Partition *Part) {$/;"	f
NonSingDegPlus1	traces.c	/^int NonSingDegPlus1(Candidate *Cand, Partition *Part, int cell, TracesVars *tv) {$/;"	f
NonSingDegPlus2	traces.c	/^void NonSingDegPlus2(Candidate *Cand, Partition *Part, int cell, TracesVars *tv) {$/;"	f
OFF_T_VER	gtools.c	20;"	d	file:
OFF_T_VER	gtools.c	28;"	d	file:
OLDEXTDEFS	nauty.h	79;"	d
ONE_WORD_SETS	genbg.c	158;"	d	file:
ONE_WORD_SETS	geng.c	396;"	d	file:
ONE_WORD_SETS	gentourng.c	183;"	d	file:
ONE_WORD_SETS	naugraph.c	23;"	d	file:
ONE_WORD_SETS	nautaux.c	25;"	d	file:
ONE_WORD_SETS	nautil.c	64;"	d	file:
ONE_WORD_SETS	nautinv.c	44;"	d	file:
ONE_WORD_SETS	naututil.c	83;"	d	file:
ONE_WORD_SETS	nauty.c	71;"	d	file:
OPENOUT	naututil.h	234;"	d
OPTCALL	nauty.c	110;"	d	file:
ORBITSIZES	traces.c	467;"	d	file:
OUTPROC	callgeng.c	/^OUTPROC(FILE *outfile, graph *g, int n)$/;"	f
P	sumlines.c	194;"	d	file:
PAIRORBJOIN	traces.c	655;"	d	file:
PATHCOUNTS_NOT	multig.c	60;"	d	file:
PERMSTACK	traces.c	792;"	d	file:
PLANARCODE	gtools.h	131;"	d
PLANARCODEANY	gtools.h	136;"	d
PLANARCODEBE	gtools.h	133;"	d
PLANARCODEBE_HEADER	gtools.h	126;"	d
PLANARCODELE	gtools.h	132;"	d
PLANARCODELE_HEADER	gtools.h	125;"	d
PLANARCODE_HEADER	gtools.h	124;"	d
PM	dreadnaut.c	126;"	d	file:
PNCODE	schreier.c	45;"	d	file:
POP	cubhamg.c	162;"	d	file:
POP	twohamg.c	88;"	d	file:
POPCOUNT	nauty.h	748;"	d
POPCOUNT	nauty.h	753;"	d
POPCOUNT	nauty.h	754;"	d
POPCOUNT	nauty.h	757;"	d
POPCOUNT	nauty.h	758;"	d
POPCOUNT	nauty.h	768;"	d
POPCOUNT	nauty.h	769;"	d
POPCOUNT	nauty.h	772;"	d
POPCOUNT	nauty.h	773;"	d
POPCOUNT	nauty.h	776;"	d
POPCOUNT	nauty.h	777;"	d
POPCOUNT	nauty.h	783;"	d
POPCOUNT	nauty.h	786;"	d
POPCOUNTMAC	nauty.h	677;"	d
POPCOUNTMAC	nauty.h	705;"	d
POPCOUNTMAC	nauty.h	717;"	d
POPCOUNTMAC	poptest.c	25;"	d	file:
POPEN_DEC	gtools.h	21;"	d
POSBILD	watercluster2.c	161;"	d	file:
PREPAREMARKS1	nausparse.c	101;"	d	file:
PREPAREMARKS1	nausparse.c	94;"	d	file:
PREPAREMARKS2	nausparse.c	104;"	d	file:
PREPAREMARKS2	nausparse.c	97;"	d	file:
PREREQ	testg.c	230;"	d	file:
PRESENT	testg.c	287;"	d	file:
PRINTCAND	traces.c	367;"	d	file:
PRINTCANDBIG	traces.c	371;"	d	file:
PRINTCANDF	traces.c	369;"	d	file:
PRINTCHAR	traces.c	365;"	d	file:
PRINTF2	traces.c	680;"	d	file:
PRINTF2_2	traces.c	681;"	d	file:
PRINTF2_3	traces.c	682;"	d	file:
PRINTF2_4	traces.c	683;"	d	file:
PRINT_CANDIDATE	traces.c	549;"	d	file:
PRINT_CANDIDATEPLUS	traces.c	565;"	d	file:
PRINT_COUNTER	nauty.h	449;"	d
PRINT_EXPPATHSTEP	traces.c	581;"	d	file:
PRINT_FROM_VERB	traces.c	605;"	d	file:
PRINT_INDEX	traces.c	639;"	d	file:
PRINT_INDIV_VERB	traces.c	628;"	d	file:
PRINT_LINE	traces.c	533;"	d	file:
PRINT_LINE_PLUS	traces.c	539;"	d	file:
PRINT_NOTMIN_VERB	traces.c	617;"	d	file:
PRINT_REFINE_VERB	traces.c	625;"	d	file:
PRINT_RETURN	traces.c	601;"	d	file:
PRINT_SKIPPED_VERB	traces.c	621;"	d	file:
PROMPTFILE	naututil.h	194;"	d
PRUNEMULT	geng.c	425;"	d	file:
PRUNEMULT	gentourng.c	202;"	d	file:
PUSH	cubhamg.c	163;"	d	file:
PUSH	twohamg.c	87;"	d	file:
PUT1	planarg.c	37;"	d	file:
PUT2	planarg.c	38;"	d	file:
PUT4	planarg.c	39;"	d	file:
PUTC	gtools.h	104;"	d
PUTC	gtools.h	105;"	d
PUTC	gtools.h	110;"	d
PUTC	gtools.h	111;"	d
PUTC	nauty.h	952;"	d
PUTC	nauty.h	956;"	d
PUTC	nauty.h	958;"	d
PUTENV_DEC	gtools.h	27;"	d
PUTHELPTEXT	gtools.h	167;"	d
PUTHELPTEXT	gtools.h	170;"	d
PUTINT	nauty.c	1097;"	d	file:
PUTORBITS	dreadnaut.c	299;"	d	file:
PUTORBITS	dreadnaut.c	301;"	d	file:
PUTSTR	nauty.c	1098;"	d	file:
PUTVERSION	gtools.h	178;"	d
P_	nauty.h	82;"	d
Partition	traces.c	/^typedef struct Partition {$/;"	s	file:
Partition	traces.c	/^} Partition;$/;"	t	typeref:struct:Partition	file:
Place	traces.c	/^void Place(int vtx, Candidate *Cand, Partition *Part) {$/;"	f
Prefix	traces.c	/^boolean Prefix(Candidate *Cand1, Candidate *Cand2, int k) {$/;"	f
Preprocess	traces.c	/^int Preprocess(sparsegraph *sg,$/;"	f
Preprocess_refine	traces.c	/^int Preprocess_refine(sparsegraph *sg,$/;"	f
PrintBlissGraph	traces.c	/^void PrintBlissGraph(int n) {$/;"	f
PrintPartition	traces.c	/^void PrintPartition(int *v, int *cls, int n, int l, int line) {$/;"	f
PrintVect	traces.c	/^void PrintVect(int *v, int z, int n, int l) {$/;"	f
PrintWeightedGraph1	traces.c	/^void PrintWeightedGraph1(sparsegraph *g_arg, int n, char msg[30]) {$/;"	f
PrintWeightedGraph2	traces.c	/^void PrintWeightedGraph2(int n, char msg[30]) {$/;"	f
QDIGRAPH	testg.c	122;"	d	file:
QDIGRAPH	testg.c	124;"	d	file:
QUALITY	rng.c	68;"	d	file:
QUALITY	watercluster2.c	170;"	d	file:
QUALITY_P1	watercluster2.c	172;"	d	file:
QUALITY_P2	watercluster2.c	174;"	d	file:
QUEUE	nausparse.c	1547;"	d	file:
QUEUE	nausparse.c	591;"	d	file:
R	sumlines.c	233;"	d	file:
RANPERM	cubhamg.c	70;"	d	file:
RANREAL	naurng.h	31;"	d
RANREAL	rng.h	31;"	d
RCHILD	splay.c	168;"	d	file:
RCHILD	sumlines.c	515;"	d	file:
READY	watercluster2.c	203;"	d	file:
REALLOCS	nauty.h	986;"	d
REALLOCS	nauty.h	990;"	d
RED	twohamg.c	41;"	d	file:
REFPROC	dreadnaut.c	230;"	d	file:
RESETMARKS	genspecialg.c	46;"	d	file:
RESETMARKS	watercluster2.c	177;"	d	file:
RESETMARKS1	nausparse.c	92;"	d	file:
RESETMARKS1	nausparse.c	99;"	d	file:
RESETMARKS2	nausparse.c	102;"	d	file:
RESETMARKS2	nausparse.c	95;"	d	file:
RESETMARKS_COLOUR	watercluster2.c	235;"	d	file:
RESETSTACK	cubhamg.c	164;"	d	file:
RL	sumlines.c	236;"	d	file:
RNG_QUALITY	naurng.c	68;"	d	file:
RR	sumlines.c	237;"	d	file:
Ranks	dretodot.c	/^int Ranks[MAXN];$/;"	v
RemoveFromLevel	traces.c	/^void RemoveFromLevel(int from, int to, int strategy, boolean reinit) {$/;"	f
ResetAutom	traces.c	/^void ResetAutom(int q, int n, struct TracesVars *tv) {$/;"	f
S	makefile	/^S=-DWORDSIZE=16$/;"	m
S1	makefile	/^S1=-DMAXN=WORDSIZE -DWORDSIZE=16$/;"	m
SAFECFLAGS	makefile	/^SAFECFLAGS=-O4 -fPIC$/;"	m
SAMETRACE_CHECK	traces.c	401;"	d	file:
SCAN_ARGS	testg.c	278;"	d	file:
SCE	planarity.h	77;"	d
SCHREIERFAILS	schreier.h	32;"	d
SCHREIER_DEFAULT	dreadnaut.c	138;"	d	file:
SEEK_CUR	gtools.c	10;"	d	file:
SEEK_CUR	showg.c	196;"	d	file:
SEEK_CUR	showg.c	201;"	d	file:
SEEK_END	gtools.c	11;"	d	file:
SEEK_END	showg.c	197;"	d	file:
SEEK_SET	gtools.c	9;"	d	file:
SEEK_SET	showg.c	195;"	d	file:
SETBT	nauty.h	480;"	d
SETBT	nauty.h	487;"	d
SETBT	nauty.h	494;"	d
SETBT	showg.c	184;"	d	file:
SETDIFF	nauty.h	559;"	d
SETENV_DEC	gtools.h	28;"	d
SETEQUIV	watercluster2.c	165;"	d	file:
SETMARK	traces.c	354;"	d	file:
SETOP	watercluster2.c	151;"	d	file:
SETPAIRS	traces.c	663;"	d	file:
SETPAIRSAUT	traces.c	669;"	d	file:
SETPAIRSAUTANDTREE	traces.c	676;"	d	file:
SETPAIRSAUTANDTREE_PREPROC	traces.c	8964;"	d	file:
SETPAIRSAUTANDTREE_PREPROC_REFINE	traces.c	9200;"	d	file:
SETVAL	twohamg.c	59;"	d	file:
SETWD	nauty.h	479;"	d
SETWD	nauty.h	486;"	d
SETWD	nauty.h	493;"	d
SETWD	showg.c	183;"	d	file:
SETWORDSNEEDED	nauty.h	482;"	d
SETWORDSNEEDED	nauty.h	489;"	d
SETWORDSNEEDED	nauty.h	496;"	d
SETWORD_FORMAT	nauty.h	620;"	d
SETWORD_FORMAT	nauty.h	623;"	d
SETWORD_FORMAT	nauty.h	626;"	d
SETWORD_FORMAT	nauty.h	632;"	d
SETWORD_FORMAT	nauty.h	635;"	d
SETWORD_FORMAT	nauty.h	638;"	d
SETWORD_FORMAT	nauty.h	644;"	d
SETWORD_FORMAT	nauty.h	647;"	d
SETWORD_FORMAT	nauty.h	650;"	d
SETWORD_FORMAT	nauty.h	656;"	d
SETWORD_FORMAT	nauty.h	659;"	d
SETWORD_FORMAT	nauty.h	662;"	d
SETWORD_INT	nauty.h	402;"	d
SETWORD_INT	nauty.h	414;"	d
SETWORD_INT	nauty.h	424;"	d
SETWORD_LONG	nauty.h	417;"	d
SETWORD_LONG	nauty.h	428;"	d
SETWORD_LONGLONG	nauty.h	431;"	d
SETWORD_SHORT	nauty.h	408;"	d
SET_C_COLLATION	gtools.h	87;"	d
SET_C_COLLATION	gtools.h	89;"	d
SET_C_COLLATION	gtools.h	92;"	d
SET_C_COLLATION	gtools.h	95;"	d
SET_C_COLLATION	gtools.h	97;"	d
SG_ALLOC	nausparse.h	58;"	d
SG_DECL	nausparse.h	76;"	d
SG_FREE	nausparse.h	69;"	d
SG_INIT	nausparse.h	55;"	d
SG_MINWEIGHT	nausparse.h	31;"	d
SG_VDE	nausparse.h	50;"	d
SG_WEIGHT	nausparse.h	29;"	d
SG_WEIGHT_FMT	nausparse.h	30;"	d
SHELL	makefile	/^SHELL=\/bin\/sh$/;"	m
SILENT	sumlines.c	55;"	d	file:
SIZE	nausparse.c	1184;"	d	file:
SIZELEN	gtools.h	48;"	d
SIZELEN	showg.c	64;"	d	file:
SIZEOF_INT	nauty.h	28;"	d
SIZEOF_INT128	nauty.h	31;"	d
SIZEOF_LONG	nauty.h	29;"	d
SIZEOF_LONG_LONG	nauty.h	30;"	d
SMALL	makefile	/^SMALL=-DMAXN=WORDSIZE$/;"	m
SMALLISHN	gtools.h	117;"	d
SMALLISHN	showg.c	84;"	d	file:
SMALLN	gtools.h	116;"	d
SMALLN	showg.c	83;"	d	file:
SORTCOMMAND	shortg.c	100;"	d	file:
SORTCOMMAND	shortg.c	92;"	d	file:
SORTCOMMANDT	shortg.c	104;"	d	file:
SORTCOMMANDT	shortg.c	96;"	d	file:
SORTPROG	gtools.h	24;"	d
SORT_FUNCTYPE	sorttemplates.c	66;"	d	file:
SORT_MEDIAN_OF_3	sorttemplates.c	41;"	d	file:
SORT_MINMEDIAN9	sorttemplates.c	62;"	d	file:
SORT_MINPARTITION	sorttemplates.c	58;"	d	file:
SORT_NAME	dreadnaut.c	132;"	d	file:
SORT_NAME	dretodot.c	47;"	d	file:
SORT_NAME	gtnauty.c	33;"	d	file:
SORT_NAME	nausparse.c	505;"	d	file:
SORT_NAME	nausparse.c	511;"	d	file:
SORT_NAME	nausparse.c	516;"	d	file:
SORT_NAME	nautil.c	448;"	d	file:
SORT_NAME	naututil.c	126;"	d	file:
SORT_NAME	sorttemplates.c	/^SORT_NAME(SORT_TYPE1 *x, SORT_TYPE2 *y, int n)$/;"	f
SORT_NAME	sorttemplates.c	/^SORT_NAME(SORT_TYPE1 *x, int n)$/;"	f
SORT_NAME	sorttemplates.c	442;"	d	file:
SORT_NAME	traces.c	33;"	d	file:
SORT_NAME	traces.c	44;"	d	file:
SORT_NAME	vcolg.c	235;"	d	file:
SORT_NEWKEY	gtools.h	25;"	d
SORT_OF_SORT	dreadnaut.c	131;"	d	file:
SORT_OF_SORT	dretodot.c	44;"	d	file:
SORT_OF_SORT	gtnauty.c	32;"	d	file:
SORT_OF_SORT	nausparse.c	504;"	d	file:
SORT_OF_SORT	nausparse.c	510;"	d	file:
SORT_OF_SORT	nausparse.c	515;"	d	file:
SORT_OF_SORT	nautil.c	447;"	d	file:
SORT_OF_SORT	naututil.c	125;"	d	file:
SORT_OF_SORT	sorttemplates.c	443;"	d	file:
SORT_OF_SORT	traces.c	32;"	d	file:
SORT_OF_SORT	traces.c	43;"	d	file:
SORT_OF_SORT	vcolg.c	234;"	d	file:
SORT_SWAP1	sorttemplates.c	69;"	d	file:
SORT_SWAP2	sorttemplates.c	70;"	d	file:
SORT_TYPE1	dreadnaut.c	133;"	d	file:
SORT_TYPE1	dretodot.c	45;"	d	file:
SORT_TYPE1	gtnauty.c	34;"	d	file:
SORT_TYPE1	nausparse.c	506;"	d	file:
SORT_TYPE1	nausparse.c	512;"	d	file:
SORT_TYPE1	nausparse.c	517;"	d	file:
SORT_TYPE1	nautil.c	445;"	d	file:
SORT_TYPE1	naututil.c	127;"	d	file:
SORT_TYPE1	sorttemplates.c	444;"	d	file:
SORT_TYPE1	traces.c	34;"	d	file:
SORT_TYPE1	traces.c	46;"	d	file:
SORT_TYPE1	vcolg.c	236;"	d	file:
SORT_TYPE2	dreadnaut.c	134;"	d	file:
SORT_TYPE2	dretodot.c	46;"	d	file:
SORT_TYPE2	gtnauty.c	35;"	d	file:
SORT_TYPE2	nausparse.c	507;"	d	file:
SORT_TYPE2	nausparse.c	518;"	d	file:
SORT_TYPE2	nautil.c	446;"	d	file:
SORT_TYPE2	sorttemplates.c	445;"	d	file:
SORT_TYPE2	traces.c	35;"	d	file:
SORT_TYPE2	traces.c	45;"	d	file:
SORT_TYPE2	traces.c	47;"	d	file:
SORT_TYPE2	vcolg.c	237;"	d	file:
SPARSE6	gtools.h	130;"	d
SPARSE6	showg.c	93;"	d	file:
SPARSE6_HEADER	gtools.h	122;"	d
SPARSE6_HEADER	showg.c	89;"	d	file:
SPARSEREP	dreadnaut.c	194;"	d	file:
SPARSE_MODE	dreadnaut.c	192;"	d	file:
SPECIALGENERATORS	traces.c	642;"	d	file:
SPLAY	splay.c	/^SPLAY(SPLAYNODE *p)$/;"	f	file:
SPLAY	splay.c	111;"	d	file:
SPLAYNODE	testg.c	273;"	d	file:
SPLAYNODESIZE	splay.c	103;"	d	file:
SPLAYNODESIZE	testg.c	277;"	d	file:
SPLAY_DELETE	splay.c	/^SPLAY_DELETE(SPLAYNODE **to_root, SPLAYNODE *p)$/;"	f
SPLAY_DELETE	splay.c	115;"	d	file:
SPLAY_DUMP	splay.c	/^SPLAY_DUMP(SPLAYNODE *p DUMP_ARGS)$/;"	f
SPLAY_INSERT	splay.c	/^SPLAY_INSERT(SPLAYNODE **to_root  INSERT_ARGS)$/;"	f
SPLAY_INSERT	splay.c	114;"	d	file:
SPLAY_LOOKUP	splay.c	/^SPLAY_LOOKUP(SPLAYNODE **to_root  LOOKUP_ARGS)$/;"	f
SPLAY_LOOKUP	splay.c	113;"	d	file:
SPLAY_SCAN	splay.c	/^SPLAY_SCAN(SPLAYNODE *root SCAN_ARGS)$/;"	f
SPLAY_SCAN	splay.c	112;"	d	file:
SS	dreadnaut.c	127;"	d	file:
SS	traces.c	352;"	d	file:
STACKISEMPTY	twohamg.c	89;"	d	file:
START	nausparse.c	1183;"	d	file:
START	watercluster2.c	2078;"	d	file:
SWAP	genspecialg.c	36;"	d	file:
SWBOOLEAN	gtools.h	152;"	d
SWBOOLEAN	showg.c	106;"	d	file:
SWCHUNK0	nauty.h	698;"	d
SWCHUNK0	nauty.h	712;"	d
SWCHUNK0	nauty.h	721;"	d
SWCHUNK1	nauty.h	699;"	d
SWCHUNK1	nauty.h	713;"	d
SWCHUNK2	nauty.h	700;"	d
SWCHUNK3	nauty.h	701;"	d
SWG_ALLOC	nausparse.h	63;"	d
SWG_DECL	nausparse.h	77;"	d
SWG_FREE	nausparse.h	74;"	d
SWG_INIT	nausparse.h	57;"	d
SWG_VDE	nausparse.h	52;"	d
SWINT	gtools.h	153;"	d
SWINT	showg.c	107;"	d	file:
SWITCHPAR_ORBSIZE	watercluster2.c	141;"	d	file:
SWLONG	gtools.h	155;"	d
SWRANGE	gtools.h	157;"	d
SWRANGE	showg.c	109;"	d	file:
SWREAL	gtools.h	159;"	d
SWREALRANGE	gtools.h	161;"	d
SWSEQUENCE	gtools.h	163;"	d
SYMBOL	testg.c	223;"	d	file:
SYS_UNIX	nauty.h	86;"	d
S_A	splay.c	94;"	d	file:
S_L	splay.c	95;"	d	file:
S_LL	splay.c	97;"	d	file:
S_LR	splay.c	98;"	d	file:
S_R	splay.c	96;"	d	file:
S_RL	splay.c	99;"	d	file:
S_RR	splay.c	100;"	d	file:
SelectNextLevel	traces.c	/^boolean SelectNextLevel(int n, struct TracesVars *tv, struct TracesInfo *ti) {$/;"	f
Select_from_CStack	traces.c	/^int Select_from_CStack(int *cls, int CStackInd) {$/;"	f
SetAutom	traces.c	/^void SetAutom(int q, int n, struct TracesVars *tv) {$/;"	f
SingNonSing	traces.c	812;"	d	file:
SpCyc	traces.c	/^static TLS_ATTR Candidate *GarbList, *SpOrd, *SpCyc, *SpSwp;$/;"	v	file:
SpOrd	traces.c	/^static TLS_ATTR Candidate *GarbList, *SpOrd, *SpCyc, *SpSwp;$/;"	v	file:
SpPart1	traces.c	/^static TLS_ATTR Partition *SpPart1, *SpPart2;$/;"	v	file:
SpPart2	traces.c	/^static TLS_ATTR Partition *SpPart1, *SpPart2;$/;"	v	file:
SpSwp	traces.c	/^static TLS_ATTR Candidate *GarbList, *SpOrd, *SpCyc, *SpSwp;$/;"	v	file:
SpineFL	traces.c	/^static TLS_ATTR TracesSpine *SpineTL, *SpineFL, *SpineTL_tl;$/;"	v	file:
SpineTL	traces.c	/^static TLS_ATTR TracesSpine *SpineTL, *SpineFL, *SpineTL_tl;$/;"	v	file:
SpineTL_tl	traces.c	/^static TLS_ATTR TracesSpine *SpineTL, *SpineFL, *SpineTL_tl;$/;"	v	file:
TAKEBIT	nauty.h	562;"	d
TE	planarity.h	75;"	d
TESTP	schreier.c	48;"	d	file:
TESTPROGS	makefile	/^TESTPROGS=dreadtest dreadtestS dreadtestS1 dreadtest4K dreadtest1 dreadtestW dreadtestW1 dreadtestL1 dreadtestL$/;"	m
THREADLIB	makefile	/^THREADLIB=-lpthread$/;"	m
THREADS	nauthread1.c	13;"	d	file:
THREADS	nauthread2.c	14;"	d	file:
TIMEOUT	hamheuristic.c	33;"	d	file:
TIMEOUT	twohamg.c	45;"	d	file:
TIMESWORDSIZE	nauty.h	481;"	d
TIMESWORDSIZE	nauty.h	488;"	d
TIMESWORDSIZE	nauty.h	495;"	d
TIMESWORDSIZE	showg.c	182;"	d	file:
TLS_ATTR	nauty.h	38;"	d
TMP	dreadnaut.c	189;"	d	file:
TMP	nausparse.c	27;"	d	file:
TMP	schreier.c	42;"	d	file:
TOCOUNT	testg.c	276;"	d	file:
TOPBIT6	gtools.h	118;"	d
TOPBIT6	showg.c	85;"	d	file:
TOSPLAY	testg.c	274;"	d	file:
TOVALUE	testg.c	275;"	d	file:
TRACES_MODE	dreadnaut.c	193;"	d	file:
TRACE_CHECK	traces.c	378;"	d	file:
TRUE	cubhamg.c	76;"	d	file:
TRUE	nauty.h	795;"	d
TRUE	nauty.h	797;"	d
TRUE	planarity.h	30;"	d
TRUE	planarity.h	32;"	d
TRUE	showg.c	190;"	d	file:
TRUE	sumlines.c	171;"	d	file:
TT	naurng.c	74;"	d	file:
TT	rng.c	73;"	d	file:
TargetCell	traces.c	/^boolean TargetCell(Candidate *TargCand, Partition *Part, int n, struct TracesVars* tv, int Lv) {$/;"	f
TargetCellExpPath	traces.c	/^int TargetCellExpPath(Candidate *TargCand, Partition *Part, struct TracesVars* tv) {$/;"	f
TargetCellExpPathSmall	traces.c	/^int TargetCellExpPathSmall(Candidate *TargCand, Partition *Part, struct TracesVars* tv) {$/;"	f
TargetCellFirstPath	traces.c	/^boolean TargetCellFirstPath(Candidate *TargCand, Partition *Part, struct TracesVars* tv) {$/;"	f
TargetCellFirstPathSmall	traces.c	/^boolean TargetCellFirstPathSmall(Candidate *TargCand, Partition *Part, struct TracesVars* tv) {$/;"	f
TargetCellSmall	traces.c	/^boolean TargetCellSmall(Candidate *TargCand, Partition *Part, int n, struct TracesVars* tv, int Lv) {$/;"	f
TempOrbSize	traces.c	805;"	d	file:
TempOrbits	traces.c	/^static TLS_ATTR int *TempOrbits = NULL;$/;"	v	file:
Traces	traces.c	/^Traces(sparsegraph *g_arg, int *lab, int *ptn,$/;"	f
TracesInfo	traces.c	/^typedef struct TracesInfo {$/;"	s	file:
TracesInfo	traces.c	/^} TracesInfo;$/;"	t	typeref:struct:TracesInfo	file:
TracesOptions	traces.h	/^typedef struct TracesOptions {$/;"	s
TracesOptions	traces.h	/^} TracesOptions;$/;"	t	typeref:struct:TracesOptions
TracesSpine	traces.c	/^typedef struct TracesSpine {$/;"	s	file:
TracesSpine	traces.c	/^} TracesSpine;$/;"	t	typeref:struct:TracesSpine	file:
TracesStats	traces.h	/^typedef struct TracesStats {$/;"	s
TracesStats	traces.h	/^} TracesStats;$/;"	t	typeref:struct:TracesStats
TracesVars	traces.c	/^typedef struct TracesVars {$/;"	s	file:
TracesVars	traces.c	/^} TracesVars;$/;"	t	typeref:struct:TracesVars	file:
TreeFyTwo	traces.c	/^boolean TreeFyTwo(int From, Candidate *Cand1, Candidate *Cand2, Partition *Part, int n,$/;"	f
TreeNodes	traces.c	809;"	d	file:
Tswitch	multig.c	/^static boolean Gswitch,Tswitch,Aswitch,Bswitch;$/;"	v	file:
Tswitch	vcolg.c	/^static boolean Tswitch;$/;"	v	file:
UNION	nauty.h	558;"	d
UNIQUE	sumlines.c	51;"	d	file:
UNKNOWN_TYPE	gtools.h	138;"	d
UNKNOWN_TYPE	showg.c	95;"	d	file:
UNMARK	genspecialg.c	43;"	d	file:
UNMARK1	nausparse.c	81;"	d	file:
UNMARK2	nausparse.c	87;"	d	file:
UNMARKED	watercluster2.c	180;"	d	file:
UNSETVAL	twohamg.c	61;"	d	file:
UPDATEMIN	traces.c	653;"	d	file:
UPDATENUMBER	watercluster2.c	167;"	d	file:
UPDATE_LINELGTH	traces.c	524;"	d	file:
UPROC	nauty.h	823;"	d
USAGE	NRswitchg.c	3;"	d	file:
USAGE	addedgeg.c	3;"	d	file:
USAGE	amtog.c	3;"	d	file:
USAGE	biplabg.c	3;"	d	file:
USAGE	blisstog.c	3;"	d	file:
USAGE	catg.c	3;"	d	file:
USAGE	checks6.c	3;"	d	file:
USAGE	complg.c	3;"	d	file:
USAGE	converseg.c	3;"	d	file:
USAGE	copyg.c	3;"	d	file:
USAGE	deledgeg.c	3;"	d	file:
USAGE	delptg.c	3;"	d	file:
USAGE	directg.c	3;"	d	file:
USAGE	dreadnaut.c	114;"	d	file:
USAGE	dretodot.c	8;"	d	file:
USAGE	dretog.c	3;"	d	file:
USAGE	genbg.c	5;"	d	file:
USAGE	geng.c	8;"	d	file:
USAGE	genquarticg.c	45;"	d	file:
USAGE	genrang.c	4;"	d	file:
USAGE	genspecialg.c	3;"	d	file:
USAGE	gentourng.c	3;"	d	file:
USAGE	gentreeg.c	6;"	d	file:
USAGE	hamheuristic.c	3;"	d	file:
USAGE	labelg.c	3;"	d	file:
USAGE	linegraphg.c	3;"	d	file:
USAGE	listg.c	3;"	d	file:
USAGE	multig.c	3;"	d	file:
USAGE	newedgeg.c	3;"	d	file:
USAGE	planarg.c	3;"	d	file:
USAGE	ranlabg.c	3;"	d	file:
USAGE	shortg.c	3;"	d	file:
USAGE	showg.c	8;"	d	file:
USAGE	subdivideg.c	3;"	d	file:
USAGE	sumlines.c	10;"	d	file:
USAGE	testg.c	6;"	d	file:
USAGE	twohamg.c	3;"	d	file:
USAGE	vcolg.c	3;"	d	file:
USERDEFNAME	testg.c	118;"	d	file:
USE_ANSICONTROLS	nauty.h	40;"	d
U_AUTOM	dreadnaut.c	205;"	d	file:
U_CANON	dreadnaut.c	209;"	d	file:
U_LEVEL	dreadnaut.c	206;"	d	file:
U_NODE	dreadnaut.c	204;"	d	file:
U_REF	dreadnaut.c	208;"	d	file:
U_TCELL	dreadnaut.c	207;"	d	file:
V	planarity.h	/^        t_ver_sparse_rep    *V;$/;"	m	struct:graph_sparse_rep
V	sumlines.c	193;"	d	file:
VAL	testg.c	233;"	d	file:
VALTYPE	testg.c	234;"	d	file:
VOUT	sumlines.c	141;"	d	file:
VOUT	sumlines.c	148;"	d	file:
VOUT	sumlines.c	155;"	d	file:
VSORTCOMMAND1	shortg.c	101;"	d	file:
VSORTCOMMAND1	shortg.c	93;"	d	file:
VSORTCOMMAND2	shortg.c	102;"	d	file:
VSORTCOMMAND2	shortg.c	94;"	d	file:
VSORTCOMMANDT1	shortg.c	105;"	d	file:
VSORTCOMMANDT1	shortg.c	97;"	d	file:
VSORTCOMMANDT2	shortg.c	106;"	d	file:
VSORTCOMMANDT2	shortg.c	98;"	d	file:
VerifyCand	traces.c	/^boolean VerifyCand(Candidate *Cand, int n, int line) {$/;"	f
VerifyId	traces.c	/^boolean VerifyId(int *p, int n) {$/;"	f
VerifyPart	traces.c	/^boolean VerifyPart(Partition *Part, int start, int end) {$/;"	f
VerifyPerm	traces.c	/^int VerifyPerm(int *perm, int n,int where) {$/;"	f
Vswitch	directg.c	/^static boolean Gswitch,Vswitch,ntgroup,ntisol,digraph6;$/;"	v	file:
W	makefile	/^W=-DWORDSIZE=32$/;"	m
W1	makefile	/^W1=-DMAXN=WORDSIZE -DWORDSIZE=32$/;"	m
WHITE	twohamg.c	39;"	d	file:
WISSEL	watercluster2.c	898;"	d	file:
WORDSIZE	genquarticg.c	22;"	d	file:
WORDSIZE	nauty.h	374;"	d
WORDSIZE	nauty.h	375;"	d
WORDSIZE	nauty.h	380;"	d
WORDSIZE	nauty.h	393;"	d
WORDSIZE	nauty.h	395;"	d
WORDSIZE	poptest.c	12;"	d	file:
WORDSIZE	showg.c	176;"	d	file:
WORKSIZE	dreadnaut.c	128;"	d	file:
WRITEDREFILE	dretodot.c	50;"	d	file:
WRITEUP	watercluster2.c	257;"	d	file:
WRITEUP_COUNT	watercluster2.c	261;"	d	file:
WeightCodes	traces.c	/^void WeightCodes(int n) {$/;"	f
WriteIt	gentreeg.c	/^WriteIt(int level)$/;"	f	file:
WriteLev	gentreeg.c	/^WriteLev(FILE *f, int vpar[], int n)$/;"	f	file:
WritePar	gentreeg.c	/^void WritePar(FILE *f, int vpar[], int n)$/;"	f
WriteS6	gentreeg.c	/^WriteS6(FILE *f, int vpar[], int n)$/;"	f	file:
X	sumlines.c	192;"	d	file:
XNEXTBIT	genbg.c	197;"	d	file:
XNEXTBIT	genbg.c	208;"	d	file:
XNEXTBIT	genbg.c	223;"	d	file:
XNEXTBIT	geng.c	435;"	d	file:
XNEXTBIT	geng.c	446;"	d	file:
XNEXTBIT	geng.c	461;"	d	file:
XNEXTBIT	gentourng.c	212;"	d	file:
XNEXTBIT	gentourng.c	223;"	d	file:
XNEXTBIT	gentourng.c	238;"	d	file:
XOR	nauty.h	560;"	d
XPOPCOUNT	genbg.c	199;"	d	file:
XPOPCOUNT	genbg.c	211;"	d	file:
XPOPCOUNT	genbg.c	228;"	d	file:
XPOPCOUNT	geng.c	437;"	d	file:
XPOPCOUNT	geng.c	449;"	d	file:
XPOPCOUNT	geng.c	466;"	d	file:
XPOPCOUNT	gentourng.c	214;"	d	file:
XPOPCOUNT	gentourng.c	226;"	d	file:
XPOPCOUNT	gentourng.c	243;"	d	file:
YES	cubhamg.c	77;"	d	file:
YES	hamheuristic.c	32;"	d	file:
YES	twohamg.c	44;"	d	file:
ZAPBIT	nauty.h	561;"	d
ZCAT	blisstog.c	12;"	d	file:
_FILE_OFFSET_BITS	nauty.h	43;"	d
_FILE_OFFSET_BITS	nauty.h	47;"	d
_GTOOLS_H_	gtools.h	13;"	d
_LARGEFILE_SOURCE	nauty.h	45;"	d
_NAUSPARSE_H_	nausparse.h	24;"	d
_NAUTY_H_	nauty.h	7;"	d
_PLANARITY_H_	planarity.h	9;"	d
_SCHREIER_H_	schreier.h	4;"	d
_cmark	watercluster2.c	/^int _colourmarks[CSIZE], _cmark=INT_MAX;$/;"	v
_colourmarks	watercluster2.c	/^int _colourmarks[CSIZE], _cmark=INT_MAX;$/;"	v
_marks	watercluster2.c	/^int _marks[MAX_BOGEN], _markvalue=INT_MAX;$/;"	v
_markvalue	watercluster2.c	/^int _marks[MAX_BOGEN], _markvalue=INT_MAX;$/;"	v
_x_	watercluster2.c	/^int _x_, _y_;$/;"	v
_y_	watercluster2.c	/^int _x_, _y_;$/;"	v
a1calls	genbg.c	/^static long a1calls,a1nauty,a1succs;$/;"	v	file:
a1calls	geng.c	/^static unsigned long a1calls,a1nauty,a1succs;$/;"	v	file:
a1calls	gentourng.c	/^static unsigned long a1calls,a1nauty,a1succs;$/;"	v	file:
a1nauty	genbg.c	/^static long a1calls,a1nauty,a1succs;$/;"	v	file:
a1nauty	geng.c	/^static unsigned long a1calls,a1nauty,a1succs;$/;"	v	file:
a1nauty	gentourng.c	/^static unsigned long a1calls,a1nauty,a1succs;$/;"	v	file:
a1succs	genbg.c	/^static long a1calls,a1nauty,a1succs;$/;"	v	file:
a1succs	geng.c	/^static unsigned long a1calls,a1nauty,a1succs;$/;"	v	file:
a1succs	gentourng.c	/^static unsigned long a1calls,a1nauty,a1succs;$/;"	v	file:
a2calls	genbg.c	/^static long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2calls	geng.c	/^static unsigned long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2calls	gentourng.c	/^static unsigned long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2nauty	genbg.c	/^static long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2nauty	geng.c	/^static unsigned long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2nauty	gentourng.c	/^static unsigned long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2succs	genbg.c	/^static long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2succs	geng.c	/^static unsigned long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2succs	gentourng.c	/^static unsigned long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2uniq	genbg.c	/^static long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2uniq	geng.c	/^static unsigned long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
a2uniq	gentourng.c	/^static unsigned long a2calls,a2nauty,a2uniq,a2succs;$/;"	v	file:
aantal_bogen	watercluster2.c	/^int aantal_toppen, aantal_bogen, aantal_gerichte_bogen;$/;"	v
aantal_gerichte_bogen	watercluster2.c	/^int aantal_toppen, aantal_bogen, aantal_gerichte_bogen;$/;"	v
aantal_gerichte_grafen	watercluster2.c	/^long long int aantal_gerichte_grafen=0LL;$/;"	v
aantal_grafen_met_triv_group	watercluster2.c	/^long long int aantal_grafen_met_triv_group=0LL;$/;"	v
aantal_toppen	watercluster2.c	/^int aantal_toppen, aantal_bogen, aantal_gerichte_bogen;$/;"	v
ac_fn_c_check_func	configure	/^ac_fn_c_check_func ()$/;"	f
ac_fn_c_check_header_compile	configure	/^ac_fn_c_check_header_compile ()$/;"	f
ac_fn_c_check_header_mongrel	configure	/^ac_fn_c_check_header_mongrel ()$/;"	f
ac_fn_c_check_type	configure	/^ac_fn_c_check_type ()$/;"	f
ac_fn_c_compute_int	configure	/^ac_fn_c_compute_int ()$/;"	f
ac_fn_c_try_compile	configure	/^ac_fn_c_try_compile ()$/;"	f
ac_fn_c_try_cpp	configure	/^ac_fn_c_try_cpp ()$/;"	f
ac_fn_c_try_link	configure	/^ac_fn_c_try_link ()$/;"	f
ac_fn_c_try_run	configure	/^ac_fn_c_try_run ()$/;"	f
accept	genquarticg.c	/^{ accept,reject,undef } CHOISE;$/;"	e	enum:__anon9	file:
accept1	genbg.c	/^accept1(graph *g, int n2, int x, graph *gx, int *deg, boolean *rigid)$/;"	f	file:
accept1	geng.c	/^accept1(graph *g, int n, xword x, graph *gx, int *deg, boolean *rigid)$/;"	f	file:
accept1	gentourng.c	/^accept1(graph *g, int n, xword x, graph *gx, int *deg, boolean *rigid)$/;"	f	file:
accept1b	geng.c	/^accept1b(graph *g, int n, xword x, graph *gx, int *deg, boolean *rigid,$/;"	f	file:
accept2	genbg.c	/^accept2(graph *g, int n2, int x, graph *gx, int *deg, boolean nuniq)$/;"	f	file:
accept2	geng.c	/^accept2(graph *g, int n, xword x, graph *gx, int *deg, boolean nuniq)$/;"	f	file:
accept2	gentourng.c	/^accept2(graph *g, int n, xword x, graph *gx, int *deg, boolean nuniq)$/;"	f	file:
active	dreadnaut.c	/^static set active[MAXM];$/;"	v	file:
active	genquarticg.c	/^setword     active;$/;"	v
active	nauty.c	/^static TLS_ATTR set active[MAXM];     \/* used to contain index to cells now$/;"	v	file:
active	traces.c	/^    int active;$/;"	m	struct:Partition	file:
add_one	sumlines.c	/^add_one(countnode **to_root, char *fmt, integer pmod, int nval,$/;"	f	file:
add_one	testg.c	/^add_one(void)$/;"	f	file:
addgenerator	schreier.c	/^addgenerator(schreier **gp, permnode **ring, int *p, int n)$/;"	f
addnumber	watercluster2.c	/^long long int addnumber=0; \/* How much must the counter be increased if a graph$/;"	v
addpermutation	schreier.c	/^addpermutation(permnode **ring, int *p, int n)$/;"	f
addpermutationunmarked	schreier.c	/^addpermutationunmarked(permnode **ring, int *p, int n)$/;"	f	file:
addr	twohamg.c	/^    int *addr;$/;"	m	struct:addrval_struct	file:
addrval	twohamg.c	/^} addrval;$/;"	t	typeref:struct:addrval_struct	file:
addrval_struct	twohamg.c	/^typedef struct addrval_struct$/;"	s	file:
adjacencies	nautinv.c	/^adjacencies(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
adjacencies_sg	nausparse.c	/^adjacencies_sg(graph *g, int *lab, int *ptn, int level, int numcells,$/;"	f
adjacent_to	planarity.h	/^    int          adjacent_to;$/;"	m	struct:ver_edge
adjl_sparse_rep	planarity.h	/^typedef struct adjl_sparse_rep {$/;"	s
adjtriang	nautinv.c	/^adjtriang(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
all	watercluster2.c	/^graph all; \/\/ the set of all vertices$/;"	v
all_diff_colours	watercluster2.c	/^int all_diff_colours(graph testset, int orbitid)$/;"	f
allemaal_doubles_mogelijk	watercluster2.c	/^int allemaal_doubles_mogelijk(BOOG edgelist[],int orbitsize, int marker[], int *endlist)$/;"	f
allgroup	naugroup.c	/^allgroup(grouprec *grp, void (*action)(int*,int))$/;"	f
allgroup2	naugroup.c	/^allgroup2(grouprec *grp, void (*action)(int*,int,int*))$/;"	f
allgroup3	naugroup.c	/^allgroup3(grouprec *grp, void (*action)(int*,int,int*,void*), void *userptr)$/;"	f
alloc_error	gtools.h	186;"	d
alloc_error	nautil.c	/^alloc_error(const char *s)$/;"	f
alloc_error	showg.c	130;"	d	file:
alloc_m	nauty.c	/^static TLS_ATTR int alloc_m = 0;$/;"	v	file:
allsamelevel	nauty.c	/^    allsamelevel,  \/* level of least ancestor of first leaf for$/;"	v	file:
answ	traces.c	/^    int answ;$/;"	m	struct:TracesVars	file:
antichain	genbg.c	/^boolean antichain;              \/* presence of -A *\/$/;"	v
applyperm	schreier.c	/^applyperm(int *wp, int *p, int k, int n)$/;"	f	file:
aresame_sg	nausparse.c	/^aresame_sg(sparsegraph *g1, sparsegraph *g2)$/;"	f
arg	traces.c	/^    int arg;$/;"	m	struct:pair	file:
arg_double	gtools.c	/^arg_double(char **ps, double *val, char *id)$/;"	f
arg_doublerange	gtools.c	/^arg_doublerange(char **ps, char *sep, double *val1, double *val2, char *id)$/;"	f
arg_int	gtools.c	/^arg_int(char **ps, int *val, char *id)$/;"	f
arg_int	showg.c	/^arg_int(char **ps, int *val, char *id)$/;"	f	file:
arg_long	gtools.c	/^arg_long(char **ps, long *val, char *id)$/;"	f
arg_range	gtools.c	/^arg_range(char **ps, char *sep, long *val1, long *val2, char *id)$/;"	f
arg_range	showg.c	/^arg_range(char **ps, long *val1, long *val2, char *id)$/;"	f	file:
arg_sequence	gtools.c	/^arg_sequence(char **ps, char *sep,$/;"	f
args	genspecialg.c	/^static long args[MAXARGS];$/;"	v	file:
as_fn_append	config.status	/^  as_fn_append ()$/;"	f
as_fn_append	configure	/^  as_fn_append ()$/;"	f
as_fn_arith	config.status	/^  as_fn_arith ()$/;"	f
as_fn_arith	configure	/^  as_fn_arith ()$/;"	f
as_fn_error	config.status	/^as_fn_error ()$/;"	f
as_fn_error	configure	/^as_fn_error ()$/;"	f
as_fn_executable_p	config.status	/^as_fn_executable_p ()$/;"	f
as_fn_executable_p	configure	/^as_fn_executable_p ()$/;"	f
as_fn_exit	config.status	/^as_fn_exit ()$/;"	f
as_fn_exit	configure	/^as_fn_exit ()$/;"	f
as_fn_failure	configure	/^as_fn_failure () { as_fn_return 1; }$/;"	f
as_fn_mkdir_p	config.status	/^as_fn_mkdir_p ()$/;"	f
as_fn_mkdir_p	configure	/^as_fn_mkdir_p ()$/;"	f
as_fn_ret_failure	configure	/^as_fn_ret_failure () { return 1; }$/;"	f
as_fn_ret_success	configure	/^as_fn_ret_success () { return 0; }$/;"	f
as_fn_set_status	config.status	/^as_fn_set_status ()$/;"	f
as_fn_set_status	configure	/^as_fn_set_status ()$/;"	f
as_fn_success	configure	/^as_fn_success () { as_fn_return 0; }$/;"	f
as_fn_unset	config.status	/^as_fn_unset ()$/;"	f
as_fn_unset	configure	/^as_fn_unset ()$/;"	f
augmented_cells	traces.c	/^    int augmented_cells;$/;"	m	struct:TracesVars	file:
autchk	traces.c	/^    double autchk;$/;"	m	struct:TracesVars	file:
autmark	traces.c	/^    int autmark;$/;"	m	struct:TracesVars	file:
autofound	traces.c	/^    boolean autofound;$/;"	m	struct:TracesInfo	file:
b	planarity.h	/^    int          *b;$/;"	m	struct:merge_queue
base	genquarticg.c	/^	int base;$/;"	m	struct:__anon8	file:
beginsort	shortg.c	/^beginsort(FILE **sortin, FILE **sortout, char *tempdir,$/;"	f	file:
bestcell	naugraph.c	/^bestcell(graph *g, int *lab, int *ptn, int level, int tc_level, int m, int n)$/;"	f	file:
bestcell_sg	nausparse.c	/^bestcell_sg(graph *g, int *lab, int *ptn, int level,$/;"	f	file:
biconnected_cub	cubhamg.c	/^biconnected_cub(cubgraph cub, int n)$/;"	f	file:
biconnected_cub_v	cubhamg.c	/^biconnected_cub_v(cubgraph cub, int vv, int n)$/;"	f	file:
biconnected_v	cubhamg.c	/^biconnected_v(graph *g, int vv, int m, int n)$/;"	f	file:
binom	genspecialg.c	/^static int binom[32][16];   \/* Cached binomial coefficients *\/$/;"	v	file:
binomial	genspecialg.c	/^binomial(int n, int k)$/;"	f	file:
bipartite	geng.c	/^static boolean bipartite;       \/* presence of -b *\/$/;"	v	file:
bipartiteside	gutil1.c	/^bipartiteside(graph *g, int m, int n)$/;"	f
biplabel	biplabg.c	/^biplabel(graph *g, int m, int n, graph *h)$/;"	f	file:
bit	nauty.h	/^setword bit[] = {0100000,040000,020000,010000,04000,02000,01000,0400,0200,$/;"	v
bit	nauty.h	/^setword bit[] = {01000000000000000000000,0400000000000000000000,$/;"	v
bit	nauty.h	/^setword bit[] = {01000000000000000000000LL,0400000000000000000000LL,$/;"	v
bit	nauty.h	/^setword bit[] = {020000000000,010000000000,04000000000,02000000000,$/;"	v
bit	showg.c	/^static setword bit[32]=$/;"	v	file:
bit_orbit	watercluster2.c	/^graph bit_orbit[MAXN];$/;"	v
blocklength	watercluster2.c	/^int *root_op=NULL, size_root=0, blocklength, orbitblocklength[MAXN], size_operations=0, number_operations=0;$/;"	v
boolean	nauty.h	/^typedef int boolean;    \/* boolean MUST be the same as int *\/$/;"	t
boolean	showg.c	/^typedef int boolean;$/;"	t	file:
boolean	sumlines.c	/^typedef int boolean;$/;"	t	file:
breakout	nautil.c	/^breakout(int *lab, int *ptn, int level, int tc, int tv,$/;"	f
brkstpcount	traces.c	/^    int brkstpcount;$/;"	m	struct:TracesVars	file:
bucket	naugraph.c	/^static TLS_ATTR int bucket[MAXN+2];$/;"	v	file:
bucket	nautinv.c	/^static TLS_ATTR int bucket[MAXN+2];$/;"	v	file:
bufferlab	watercluster2.c	/^nvector bufferlab[MAXN], bufferptn[MAXN];$/;"	v
bufferptn	watercluster2.c	/^nvector bufferlab[MAXN], bufferptn[MAXN];$/;"	v
build_autom	traces.c	/^    int build_autom;$/;"	m	struct:TracesVars	file:
bytecount	nauty.h	/^int bytecount[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,$/;"	v
callprocess	watercluster2.c	/^ void callprocess(graph *g, int aantal_toppen)$/;"	f
cand_level	traces.c	/^    int cand_level;$/;"	m	struct:TracesVars	file:
cangraph	traces.c	/^    sparsegraph *cangraph;$/;"	m	struct:TracesVars	file:
canlist	traces.c	/^    int canlist;$/;"	m	struct:TracesVars	file:
canoncode	nauty.c	/^         canoncode[MAXN+2];      \/* codes for bsf leaf *\/$/;"	v	file:
canong	dreadnaut.c	/^static graph canong[MAXM*1L*MAXN];$/;"	v	file:
canong	nauty.c	/^static TLS_ATTR graph *g,*canong;$/;"	v	file:
canong	watercluster2.c	/^graph canong[MAXN];$/;"	v
canong	watercluster2.c	/^graph workg[MAXN], staticg[MAXN], canong[MAXN];$/;"	v
canong_sg	dreadnaut.c	/^static sparsegraph canong_sg;$/;"	v	file:
canonical	watercluster2.c	/^int canonical(unsigned char operation[], int vertexorbit[], int *newgroup, int orbitid, graph touched)$/;"	f
canonise	genbg.c	/^boolean canonise;               \/* presence of -l *\/$/;"	v
canonise	geng.c	/^boolean canonise;               \/* presence of -l *\/$/;"	v
canonise	genquarticg.c	/^boolean     canonise;                       \/* presence of -l *\/  \/\/????????$/;"	v
canonise	gentourng.c	/^boolean canonise;               \/* presence of -l *\/$/;"	v
canonlab	nauty.c	/^               canonlab[MAXN];   \/* label from bsf leaf *\/$/;"	v	file:
canonlevel	nauty.c	/^    canonlevel,    \/* level of bsf leaf *\/$/;"	v	file:
canupdates	nauty.h	/^    unsigned long canupdates;    \/* number of updates of best label *\/$/;"	m	struct:__anon18
canupdates	traces.h	/^	int canupdates;$/;"	m	struct:TracesStats
cartesian	nauty.c	/^   boolean getcanon,digraph,writeautoms,domarkers,cartesian,doschreier;$/;"	v	file:
cartesian	nauty.h	/^    boolean cartesian;        \/* use cartesian rep for writing automs? *\/$/;"	m	struct:optionstruct
cartesian	traces.h	/^	boolean cartesian;$/;"	m	struct:TracesOptions
ccend	traces.c	/^    int ccend;$/;"	m	struct:TracesSpine	file:
ccstart	traces.c	/^    int ccstart;$/;"	m	struct:TracesSpine	file:
cell	traces.c	/^    int cell;$/;"	m	struct:ExpPathInfo	file:
cellcliq	nautinv.c	/^cellcliq(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
cellfano	nautinv.c	/^cellfano(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
cellfano2	nautinv.c	/^cellfano2(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
cellind	nautinv.c	/^cellind(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
cellquads	nautinv.c	/^cellquads(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
cellquins	nautinv.c	/^cellquins(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
cells	traces.c	/^    int cells;$/;"	m	struct:Partition	file:
cellstarts	naututil.c	/^cellstarts(int *ptn, int level, set *cell, int m, int n)$/;"	f
celltrips	nautinv.c	/^celltrips(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
cheapautom	naugraph.c	/^cheapautom(int *ptn, int level, boolean digraph, int n)$/;"	f
cheapautom	nauty.h	/^    boolean (*cheapautom)     \/* test for easy automorphism *\/$/;"	m	struct:__anon19
cheapautom_sg	nausparse.c	/^cheapautom_sg(int *ptn, int level, boolean digraph, int n)$/;"	f
check	nauty.h	/^    void    (*check)          \/* check compilation parameters *\/$/;"	m	struct:__anon19
check_it	cubhamg.c	/^check_it(int index, cubgraph g, cubgraph eno, edgevec v1, edgevec v2,$/;"	f	file:
checkgline	gtools.c	/^checkgline(char *s)$/;"	f
chi	gentreeg.c	/^ chi[MAXN+1],                 \/* number of children of a node *\/$/;"	v	file:
choose_triv_orbit	watercluster2.c	/^void choose_triv_orbit(graph *touched, int best_orbit[], int orbitid, int fixed_vertex)$/;"	f
chooseorbit	watercluster2.c	/^void chooseorbit(graph *touched, int best_orbit[], int orbitid)$/;"	f
class	cubhamg.c	/^    edgevec class;$/;"	m	struct:__anon16	file:
class1size	genbg.c	/^int class1size;                 \/* same as n1 *\/$/;"	v
classin	cubhamg.c	/^classin(cubgraph g, cubgraph eno, nodedata *nodat,$/;"	f	file:
classout	cubhamg.c	/^classout(cubgraph g, nodedata *nodat, int v, int w, int en) $/;"	f	file:
classstack	cubhamg.c	/^static int classstack[4*MAXNE];      \/* stack of classifications *\/$/;"	v	file:
classstackptr	cubhamg.c	/^static int *classstackptr;       \/* points above top of classstack *\/$/;"	v	file:
cleanup	nauty.h	/^    void    (*cleanup)(graph*,graph**,graph*,graph**,int*,int*,$/;"	m	struct:__anon19
cleanup_sg	nausparse.c	/^cleanup_sg(graph *gin, graph **gout, graph *hin, graph **hout, int *lab,$/;"	f
clearfreelists	schreier.c	/^clearfreelists(void)$/;"	f	file:
clearvector	schreier.c	/^clearvector(permnode **vec, permnode **ring, int n)$/;"	f	file:
cliques	nautinv.c	/^cliques(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
cls	traces.c	/^    int *cls;$/;"	m	struct:Partition	file:
code	genquarticg.c	/^static int  nmax, m, code, numcells, mod, res, splitlevel, splitcount;$/;"	v	file:
code	traces.c	/^    int code;$/;"	m	struct:Candidate	file:
code	traces.c	/^    int code;$/;"	m	struct:ExpPathInfo	file:
code	traces.c	/^    int code;$/;"	m	struct:Partition	file:
col	vcolg.c	/^static int col[MAXNV];$/;"	v	file:
color	dretodot.c	/^    char color[6];$/;"	m	struct:NodeShape	file:
colour	watercluster2.c	/^nvector lab[MAX_BOGEN][MAXN]={{0}}, ptn[MAX_BOGEN][MAXN]={{0}}, orbits[MAX_BOGEN], colour[MAX_BOGEN][MAXN]={{0}};$/;"	v
colourit	vcolg.c	/^colourit(graph *g, int nfixed, long minedges, long maxedges,$/;"	f	file:
commonnbrs	gutil2.c	/^commonnbrs(graph *g, int *minadj, int *maxadj, int *minnon, int *maxnon,$/;"	f
comp_canon	nauty.c	/^    comp_canon,    \/* -1,0,1 according as code at eqlev_canon+1 is$/;"	v	file:
comp_sparse_rep	planarity.h	/^typedef struct comp_sparse_rep {$/;"	s
compare_count_node	testg.c	/^compare_count_node(count_node *a, count_node *b)$/;"	f	file:
compare_op	watercluster2.c	/^int compare_op(unsigned char *op1, unsigned char *op2)$/;"	f
compare_value_node	testg.c	/^compare_value_node(value_node *a, value_node *b)$/;"	f	file:
comparedge	bliss2dre.c	/^int comparedge(const void *p1, const void *p2)$/;"	f
comparelab_tr	nausparse.c	/^comparelab_tr(sparsegraph *g,$/;"	f
compl	complg.c	/^compl(graph *g, int m, int n, graph *h, boolean comploops)$/;"	f	file:
complement	naututil.c	/^complement(graph *g, int m, int n)$/;"	f
complement_sg	naututil.c	/^complement_sg(sparsegraph *g1, sparsegraph *g2)$/;"	f
component	nautaux.c	/^component(graph *g, int v, set *cmpt, int m, int n)$/;"	f
compstage	traces.c	/^    int compstage;$/;"	m	struct:TracesVars	file:
compute	testg.c	/^compute(graph *g, int m, int n, int code, boolean digraph)$/;"	f	file:
compute_edgeorbits	watercluster2.c	/^void compute_edgeorbits(int edgelist[][2],int orb[], int length)$/;"	f
compute_extensions	watercluster2.c	/^void compute_extensions(BOOG kleinste_orbit[], int orbitsize, BOOG extensionlist[], int *number_of_extensions)$/;"	f
compute_image_operation	watercluster2.c	/^int compute_image_operation(unsigned char image[], unsigned char original[], permutation generator[])$/;"	f
compute_orbits	watercluster2.c	/^int compute_orbits()$/;"	f
compute_par_extensions	watercluster2.c	/^int compute_par_extensions(BOOG orbit[], int orbitsize)$/;"	f
compute_par_orbits	watercluster2.c	/^int compute_par_orbits(BOOG edgeorbit[],int orbitsize,int num_extensions, unsigned int nonequivextensions[])$/;"	f
computed	testg.c	/^    boolean computed;$/;"	m	struct:constraint_st	file:
cond	genquarticg.c	/^    int cond;$/;"	m	struct:__anon6	file:
condaddgenerator	schreier.c	/^condaddgenerator(schreier **gp, permnode **ring, int *p, int n)$/;"	f
conncontent	gutil2.c	/^conncontent(graph *g, int m, int n)$/;"	f
connec	genbg.c	/^static boolean connec;          \/* presence of -c *\/$/;"	v	file:
connec	geng.c	/^static int connec;              \/* 1 for -c, 2 for -C, 0 for neither *\/$/;"	v	file:
connec	genquarticg.c	/^static int  connec;                          \/* 1 for -c, 2 for -C, 0 for neither *\/$/;"	v	file:
connec	gentourng.c	/^static int connec;              \/* 1 for -c, 0 for not *\/$/;"	v	file:
connec1	genquarticg.c	/^boolean     connec1;                        \/* presence of -c *\/$/;"	v
connec2	genquarticg.c	/^boolean     connec2;                        \/* presence of -C *\/$/;"	v
connected	watercluster2.c	/^int connected(graph g[], int aantal_toppen)$/;"	f
const	nauty.h	90;"	d
constraint	testg.c	/^} constraint[] = {$/;"	v	typeref:struct:constraint_st	file:
constraint_st	testg.c	/^static struct constraint_st    \/* Table of Constraints *\/$/;"	s	file:
construct_extensions	watercluster2.c	/^void construct_extensions(int still_open[], int orbit[], graph touched, int first_in_orbit, graph sameorbit)$/;"	f
construct_operations_final	watercluster2.c	/^void construct_operations_final(int list[], int decided[],unsigned char buffer_op[], $/;"	f
construct_operations_in	watercluster2.c	/^void construct_operations_in(int list[],int liststart, int decided[],unsigned char buffer_op[], $/;"	f
construct_operations_one	watercluster2.c	/^void construct_operations_one(int center, int end, int do_inedge, int do_outedge, int do_double)$/;"	f
construct_operations_out	watercluster2.c	/^void construct_operations_out(int list[],int liststart, int decided[],unsigned char buffer_op[], $/;"	f
conta0	traces.c	/^    int conta0;$/;"	m	struct:TracesVars	file:
conta1	traces.c	/^    int conta1;$/;"	m	struct:TracesVars	file:
conta2	traces.c	/^    int conta2;$/;"	m	struct:TracesVars	file:
conta3	traces.c	/^    int conta3;$/;"	m	struct:TracesVars	file:
conta4	traces.c	/^    int conta4;$/;"	m	struct:TracesVars	file:
conta5	traces.c	/^    int conta5;$/;"	m	struct:TracesVars	file:
conta6	traces.c	/^    int conta6;$/;"	m	struct:TracesVars	file:
conta7	traces.c	/^    int conta7;$/;"	m	struct:TracesVars	file:
contatc	traces.c	/^    int contatc;$/;"	m	struct:TracesVars	file:
contract1	gutil2.c	/^contract1(graph *g, graph *h, int v, int w, int n)  $/;"	f
conv	converseg.c	/^conv(graph *g, int m, int n)$/;"	f	file:
converse	naututil.c	/^converse(graph *g, int m, int n)$/;"	f
converse_sg	naututil.c	/^converse_sg(sparsegraph *g1, sparsegraph *g2)$/;"	f
copy_sg	nausparse.c	/^copy_sg(sparsegraph *sg1, sparsegraph *sg2)$/;"	f
copy_sg_structure	traces.c	/^sparsegraph* copy_sg_structure(sparsegraph *sg2, sparsegraph *sg1) {$/;"	f
copycomment	naututil.c	/^copycomment(FILE *fin, FILE *fout, int delimiter)$/;"	f
coset_struct	naugroup.h	/^typedef struct coset_struct$/;"	s
cosetindex	nauty.c	/^    cosetindex;    \/* the point being fixed at level gca_first *\/$/;"	v	file:
cosetrec	naugroup.h	/^} cosetrec;$/;"	t	typeref:struct:coset_struct
count	genquarticg.c	/^int         count[MAXN];$/;"	v
count	nautinv.c	/^static TLS_ATTR int count[MAXN];$/;"	v	file:
count	sumlines.c	/^    unsigned long count;$/;"	m	struct:countrec	file:
count	testg.c	/^    nauty_counter count;$/;"	m	struct:node_st	file:
count0	multig.c	/^static long long count0,count1,count2,count3,count4,count5;$/;"	v	file:
count1	multig.c	/^static long long count0,count1,count2,count3,count4,count5;$/;"	v	file:
count2	multig.c	/^static long long count0,count1,count2,count3,count4,count5;$/;"	v	file:
count3	multig.c	/^static long long count0,count1,count2,count3,count4,count5;$/;"	v	file:
count4	multig.c	/^static long long count0,count1,count2,count3,count4,count5;$/;"	v	file:
count5	multig.c	/^static long long count0,count1,count2,count3,count4,count5;$/;"	v	file:
count_node	testg.c	/^} count_node;$/;"	t	typeref:struct:node_st	file:
count_root	sumlines.c	/^static countnode *count_root[MAXFORMATS];$/;"	v	file:
count_root	testg.c	/^static splay_node *count_root = NULL;$/;"	v	file:
countcells	naututil.c	/^countcells(int *ptn, int level, int n)$/;"	f
counter	callgeng.c	/^static unsigned long counter;$/;"	v	file:
countnode	sumlines.c	/^} countnode;$/;"	t	typeref:struct:countrec	file:
countrec	sumlines.c	/^typedef struct countrec$/;"	s	file:
cubgraph	cubhamg.c	/^typedef int cubgraph[MAXN][4];$/;"	t	file:
cubham	cubhamg.c	/^cubham(cubgraph g, cubgraph eno, edgevec initclass, edgevec v1, edgevec v2,$/;"	f	file:
cubinit	cubhamg.c	/^cubinit(cubgraph g, cubgraph eno, edgevec v1, edgevec v2, int nv, int ne)$/;"	f	file:
curfile	dreadnaut.c	/^static int curfile;$/;"	v	file:
curres	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
currorbit	traces.c	/^    int *currorbit;$/;"	m	struct:TracesVars	file:
cutfree	genbg.c	/^boolean cutfree;                \/* presence of -L *\/$/;"	v
cyclecount	gutil2.c	/^cyclecount(graph *g, int m, int n)$/;"	f
cyclecount1	gutil2.c	/^cyclecount1(graph *g, int n)$/;"	f
d	nausparse.h	/^    int *d;      \/* Array with out-degree of each vertex *\/$/;"	m	struct:__anon10
d	sumlines.c	/^    integer d;$/;"	m	union:__anon14	file:
d	traces.c	/^    int d;$/;"	m	struct:grph_strct	file:
data	genbg.c	/^static leveldata data[MAXN];      \/* data[n] is data for n -> n+1 *\/$/;"	v	file:
data	geng.c	/^static leveldata data[MAXN];      \/* data[n] is data for n -> n+1 *\/$/;"	v	file:
data	gentourng.c	/^static leveldata data[MAXN];      \/* data[n] is data for n -> n+1 *\/$/;"	v	file:
data	testg.c	/^    long data[1];$/;"	m	struct:splay_st	file:
data	testg.c	/^    long data[1];$/;"	m	struct:value_st	file:
decode_to_nauty	watercluster2.c	/^void decode_to_nauty(unsigned char *code, int codelaenge, graph *g, int degree[]) $/;"	f
decodekeys	testg.c	/^decodekeys(char *s)$/;"	f	file:
def_ext	dreadnaut.c	/^static char def_ext[] = DEFEXT;$/;"	v	file:
defaultptn	nauty.h	/^    boolean defaultptn;       \/* set lab,ptn,active for single cell? *\/$/;"	m	struct:optionstruct
defaultptn	traces.h	/^	boolean defaultptn;$/;"	m	struct:TracesOptions
defltwork	nauty.c	/^static TLS_ATTR set defltwork[2*MAXM];   \/* workspace in case none provided *\/$/;"	v	file:
deg	watercluster2.c	/^int deg[MAXN]={0}, outdeg[MAXN]={0}, indeg[MAXN]={0};$/;"	v
deg_one	traces.c	/^    boolean deg_one;$/;"	m	struct:TracesInfo	file:
degstats	gutil1.c	/^degstats(graph *g, int m, int n, unsigned long *edges, int *mindeg,$/;"	f
degstats2	gutil1.c	/^degstats2(graph *g, boolean digraph, int m, int n,$/;"	f
delete1	gutil2.c	/^delete1(graph *g, graph *h, int v, int n)$/;"	f
deleteunmarked	schreier.c	/^deleteunmarked(permnode **ring)$/;"	f
delpermnode	schreier.c	/^delpermnode(permnode **ring)$/;"	f	file:
densenauty	naugraph.c	/^densenauty(graph *g, int *lab, int *ptn, int *orbits,$/;"	f
depth	naugroup.h	/^    int depth;               \/* number of points in base *\/$/;"	m	struct:group_struct
dg_ngen	directg.c	/^nauty_counter dg_nin,dg_ngen,dg_nout,dg_skipped; $/;"	v
dg_nin	directg.c	/^nauty_counter dg_nin,dg_ngen,dg_nout,dg_skipped; $/;"	v
dg_nin	watercluster2.c	/^nauty_counter dg_nin,dg_nout;$/;"	v
dg_nout	directg.c	/^nauty_counter dg_nin,dg_ngen,dg_nout,dg_skipped; $/;"	v
dg_nout	watercluster2.c	/^nauty_counter dg_nin,dg_nout;$/;"	v
dg_skipped	directg.c	/^nauty_counter dg_nin,dg_ngen,dg_nout,dg_skipped; $/;"	v
diamstats	gutil1.c	/^diamstats(graph *g, int m, int n, int *radius, int *diameter)$/;"	f
digits	traces.c	/^    int digits;$/;"	m	struct:TracesVars	file:
digraph	delptg.c	/^static boolean digraph,dolabel;$/;"	v	file:
digraph	nauty.c	/^   boolean getcanon,digraph,writeautoms,domarkers,cartesian,doschreier;$/;"	v	file:
digraph	nauty.h	/^    boolean digraph;          \/* multiple edges or loops? *\/$/;"	m	struct:optionstruct
digraph	traces.h	/^	boolean digraph;$/;"	m	struct:TracesOptions
digraph6	directg.c	/^static boolean Gswitch,Vswitch,ntgroup,ntisol,digraph6;$/;"	v	file:
digraph6	gentourng.c	/^boolean digraph6;               \/* presence of -z *\/$/;"	v
digraphok	testg.c	/^    boolean digraphok;   \/* Can be computed for digraphs *\/$/;"	m	struct:constraint_st	file:
digstring	traces.c	/^    char digstring[25];$/;"	m	struct:TracesVars	file:
din	cubhamg.c	/^    vertvec din,dout,farend;$/;"	m	struct:__anon16	file:
direct	directg.c	/^direct(graph *g, int nfixed, long minarcs, long maxarcs,$/;"	f	file:
direct_all_nontriv	watercluster2.c	/^void direct_all_nontriv()$/;"	f
direct_all_triv	watercluster2.c	/^void direct_all_triv()$/;"	f
direct_edges	watercluster2.c	/^void direct_edges(void) \/* graph workg[] and int aantal_toppen, aantal_bogen are global *\/$/;"	f
direct_output	watercluster2.c	/^int double_allowed=1, direct_output=0;$/;"	v
directorbit	watercluster2.c	/^void directorbit(int todo_list[], int vertexorbit[], int group_uptodate, int orbitid, $/;"	f
dispatch	nauty.c	/^static TLS_ATTR dispatchvec dispatch;$/;"	v	file:
dispatch	nauty.h	/^    dispatchvec *dispatch;    \/* vector of object-specific routines *\/$/;"	m	struct:optionstruct
dispatch_graph	naugraph.c	/^dispatchvec dispatch_graph =$/;"	v
dispatch_sparse	nausparse.c	/^dispatchvec dispatch_sparse =$/;"	v
dispatchsearch	twohamg.c	/^dispatchsearch(int n, int *e, int nblue, int nred)$/;"	f	file:
dispatchvec	nauty.h	/^} dispatchvec;$/;"	t	typeref:struct:__anon19
distances	nautinv.c	/^distances(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
distances_sg	nausparse.c	/^distances_sg(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
distinvar	genbg.c	/^distinvar(graph *g, int *invar, int n1, int n2)$/;"	f	file:
distinvar	geng.c	/^distinvar(graph *g, int *invar, int n)$/;"	f	file:
distvals	nausparse.c	/^distvals(sparsegraph *g, int v0, int *dist, int n)$/;"	f
dlcl	planarity.h	/^typedef struct dlcl {$/;"	s
dlen	nausparse.h	/^    size_t vlen,dlen,elen,wlen;  \/* Sizes of arrays in units of type *\/$/;"	m	struct:__anon10
dmax	genbg.c	/^    int ne,dmax;         \/* values used for xlb,xub calculation *\/$/;"	m	struct:__anon3	file:
dmax	geng.c	/^    int ne,dmax;          \/* values used for xlb,xub calculation *\/$/;"	m	struct:__anon17	file:
dmodel_bip_sg	genrang.c	/^dmodel_bip_sg(int deg1, sparsegraph *sg, int n1, int n2)$/;"	f	file:
dmodel_sg	genrang.c	/^dmodel_sg(int degree, sparsegraph *sg, int n)$/;"	f	file:
dnwork	naugraph.c	/^static TLS_ATTR set dnwork[40*MAXM];$/;"	v	file:
do_extensions_par	watercluster2.c	/^void do_extensions_par(BOOG orbit[],int positie,int numberin[],int numberout[], int numberdouble[],unsigned int op)$/;"	f
do_it	traces.c	/^    int do_it;$/;"	m	struct:Candidate	file:
docount	testg.c	/^static boolean docount,dofilter;$/;"	v	file:
dofilter	testg.c	/^static boolean docount,dofilter;$/;"	v	file:
dofragment	cubhamg.c	/^dofragment(nauty_counter id, cubgraph cub, int n, int ne, int weight)$/;"	f	file:
doglob	sumlines.c	/^doglob(char *patt, glob_t *globlk)$/;"	f	file:
dolabel	delptg.c	/^static boolean digraph,dolabel;$/;"	v	file:
domarkers	nauty.c	/^   boolean getcanon,digraph,writeautoms,domarkers,cartesian,doschreier;$/;"	v	file:
doref	nautil.c	/^doref(graph *g, int *lab, int *ptn, int level, int *numcells,$/;"	f
doschreier	nauty.c	/^   boolean getcanon,digraph,writeautoms,domarkers,cartesian,doschreier;$/;"	v	file:
double_allowed	watercluster2.c	/^int double_allowed=1, direct_output=0;$/;"	v
double_free	watercluster2.c	/^int double_free[MAXN]={0}; \/* hoeveel dubbele bogen kan top [i] nog krijgen? *\/$/;"	v
doublevalue	gtools.c	/^doublevalue(char **ps, double *l)$/;"	f
dout	cubhamg.c	/^    vertvec din,dout,farend;$/;"	m	struct:__anon16	file:
dout	sumlines.c	/^static char *dout,*fout,*vout,*hmsout1,*hmsout2;$/;"	v	file:
dovistruct	genquarticg.c	/^} dovistruct;$/;"	t	typeref:struct:__anon8	file:
dummy	cubhamg.c	/^dummy(void)$/;"	f	file:
dummybool	watercluster2.c	/^boolean dummybool;$/;"	v
dumpdata	twohamg.c	/^dumpdata(int id, int nblue, int nred, int n)$/;"	f	file:
dumpschreier	schreier.c	/^dumpschreier(FILE *f, schreier *gp, permnode *ring, int n)$/;"	f
e	nausparse.h	/^    int *e;      \/* Array to hold lists of neighbours *\/$/;"	m	struct:__anon10
e	traces.c	/^    int *e;$/;"	m	struct:grph_strct	file:
e1	twohamg.c	/^    int e1,e2,e3;$/;"	m	struct:p4	file:
e2	twohamg.c	/^    int e1,e2,e3;$/;"	m	struct:p4	file:
e3	twohamg.c	/^    int e1,e2,e3;$/;"	m	struct:p4	file:
echunk	naututil.c	/^typedef struct echunk {struct echunk *next; int edge[ECHUNKSIZE];} echunk;$/;"	s	file:
echunk	naututil.c	/^typedef struct echunk {struct echunk *next; int edge[ECHUNKSIZE];} echunk;$/;"	t	typeref:struct:echunk	file:
echunkw	naututil.c	/^ struct {int v1,v2; sg_weight wt;} edge[ECHUNKSIZE];} echunkw;$/;"	t	typeref:struct:echunkw	file:
echunkw	naututil.c	/^typedef struct echunkw {struct echunkw *next; \\$/;"	s	file:
ecount	genbg.c	/^static nauty_counter ecount[1+MAXN*MAXN\/4];  \/* counts by number of edges *\/$/;"	v	file:
ecount	geng.c	/^static nauty_counter ecount[1+MAXN*(MAXN-1)\/2];  \/* counts by number of edges *\/$/;"	v	file:
edge	naututil.c	/^ struct {int v1,v2; sg_weight wt;} edge[ECHUNKSIZE];} echunkw;$/;"	m	struct:echunkw	typeref:struct:echunkw::__anon12	file:
edge	naututil.c	/^typedef struct echunk {struct echunk *next; int edge[ECHUNKSIZE];} echunk;$/;"	m	struct:echunk	file:
edge_sparse_rep	planarity.h	/^typedef struct edge_sparse_rep {$/;"	s
edgelist	watercluster2.c	/^BOOG edgelist[MAX_BOGEN+1]; \/* de lijst van bogen *\/$/;"	v
edgelist_final	watercluster2.c	/^BOOG edgelist_final[MAX_BOGEN+1]; \/* de lijst van bogen die nadat er eerst nontriviale automorphismen waren die dan $/;"	v
edgeno	directg.c	/^static int edgeno[MAXNV][MAXNV];$/;"	v	file:
edgeno	multig.c	/^static int edgeno[MAXNV][MAXNV];$/;"	v	file:
edgestruct	genquarticg.c	/^} edgestruct;$/;"	t	typeref:struct:__anon6	file:
edgevec	cubhamg.c	/^typedef int edgevec[MAXNE+1];$/;"	t	file:
elen	nausparse.h	/^    size_t vlen,dlen,elen,wlen;  \/* Sizes of arrays in units of type *\/$/;"	m	struct:__anon10
embed_sparse_rep	planarity.h	/^typedef struct embed_sparse_rep {$/;"	s
embedg_VES_add_edge	planarity.c	/^embedg_VES_add_edge (t_ver_edge *embed_graph, int n, int *edge_pos,$/;"	f
embedg_VES_are_adj_lists_consistent	planarity.c	/^embedg_VES_are_adj_lists_consistent (t_ver_edge *embed_graph, int n)$/;"	f
embedg_VES_delete	planarity.c	/^embedg_VES_delete (t_ver_edge *embed_graph, int n)$/;"	f
embedg_VES_embed_edge	planarity.c	/^embedg_VES_embed_edge (t_ver_edge *embed_graph, int n, int *edge_pos,$/;"	f
embedg_VES_get_next_in_dlcl	planarity.c	/^embedg_VES_get_next_in_dlcl (t_ver_edge *embed_graph, int n, int r, int prev)$/;"	f
embedg_VES_get_succ_active_on_ext_face	planarity.c	/^embedg_VES_get_succ_active_on_ext_face (t_ver_edge *embed_graph, int n,$/;"	f
embedg_VES_get_succ_ext_active_on_ext_face	planarity.c	/^embedg_VES_get_succ_ext_active_on_ext_face (t_ver_edge *embed_graph, int n,$/;"	f
embedg_VES_get_succ_on_ext_face	planarity.c	/^embedg_VES_get_succ_on_ext_face (t_ver_edge *embed_graph, int n, int v,$/;"	f
embedg_VES_get_succ_on_proper_face	planarity.c	/^embedg_VES_get_succ_on_proper_face (t_ver_edge *embed_graph, int n, int e,$/;"	f
embedg_VES_get_succ_on_proper_face_with_avoidance	planarity.c	/^embedg_VES_get_succ_on_proper_face_with_avoidance (t_ver_edge *embed_graph,$/;"	f
embedg_VES_get_succ_pertinent_on_ext_face	planarity.c	/^embedg_VES_get_succ_pertinent_on_ext_face (t_ver_edge *embed_graph, int n,$/;"	f
embedg_VES_get_twin_edge	planarity.c	/^embedg_VES_get_twin_edge (t_ver_edge *embed_graph, int n, int e)$/;"	f
embedg_VES_get_ver	planarity.c	/^embedg_VES_get_ver (t_ver_edge *embed_graph, int n, int v)$/;"	f
embedg_VES_get_ver_from_virtual	planarity.c	/^embedg_VES_get_ver_from_virtual (t_ver_edge *embed_graph, int n, int vv)$/;"	f
embedg_VES_is_adj_list_consistent	planarity.c	/^embedg_VES_is_adj_list_consistent (t_ver_edge *embed_graph, int n, int r)$/;"	f
embedg_VES_is_back_edge	planarity.c	/^embedg_VES_is_back_edge (t_ver_edge *embed_graph, int n, int i)$/;"	f
embedg_VES_is_edge	planarity.c	/^embedg_VES_is_edge (int n, int i)$/;"	f
embedg_VES_is_ext_face_marked	planarity.c	/^embedg_VES_is_ext_face_marked (t_ver_edge *embed_graph, int n, int v, int mark)$/;"	f
embedg_VES_is_part_ext_face_marked	planarity.c	/^embedg_VES_is_part_ext_face_marked (t_ver_edge *embed_graph, int n, int v,$/;"	f	file:
embedg_VES_is_short_cut_edge	planarity.c	/^embedg_VES_is_short_cut_edge (t_ver_edge *embed_graph, int n, int i)$/;"	f
embedg_VES_is_tree_edge	planarity.c	/^embedg_VES_is_tree_edge (t_ver_edge *embed_graph, int n, int i)$/;"	f
embedg_VES_is_ver_ext_active	planarity.c	/^embedg_VES_is_ver_ext_active (t_ver_edge *embed_graph, int n, int v, int w)$/;"	f
embedg_VES_is_ver_inactive	planarity.c	/^embedg_VES_is_ver_inactive (t_ver_edge *embed_graph, int n, int v, int w)$/;"	f
embedg_VES_is_ver_int_active	planarity.c	/^embedg_VES_is_ver_int_active (t_ver_edge *embed_graph, int n, int v, int w)$/;"	f
embedg_VES_is_ver_pertinent	planarity.c	/^embedg_VES_is_ver_pertinent (t_ver_edge *embed_graph, int n, int v, int w)$/;"	f
embedg_VES_is_vertex	planarity.c	/^embedg_VES_is_vertex (int n, int i)$/;"	f
embedg_VES_is_virtual_vertex	planarity.c	/^embedg_VES_is_virtual_vertex (int n, int i)$/;"	f
embedg_VES_merge_pertinent_bicomps	planarity.c	/^embedg_VES_merge_pertinent_bicomps (t_ver_edge *embed_graph, int n,$/;"	f
embedg_VES_merge_simple_bicomps	planarity.c	/^embedg_VES_merge_simple_bicomps (t_ver_edge *embed_graph, int n, int vv,$/;"	f
embedg_VES_print	planarity.c	/^embedg_VES_print (t_ver_edge *embed_graph, int n)$/;"	f
embedg_VES_print_adj_list	planarity.c	/^embedg_VES_print_adj_list (t_ver_edge *embed_graph, int n, int r,$/;"	f
embedg_VES_print_any_rec	planarity.c	/^embedg_VES_print_any_rec (t_ver_edge *embed_graph, int n, int r)$/;"	f
embedg_VES_print_any_vertex	planarity.c	/^embedg_VES_print_any_vertex (t_ver_edge *embed_graph, int n, int v)$/;"	f
embedg_VES_print_bigcomps	planarity.c	/^embedg_VES_print_bigcomps (t_ver_edge *embed_graph, int n)$/;"	f
embedg_VES_print_edge	planarity.c	/^embedg_VES_print_edge (t_ver_edge *embed_graph, int n, int e)$/;"	f
embedg_VES_print_flipped_edges	planarity.c	/^embedg_VES_print_flipped_edges (t_ver_edge *embed_graph, int n, int edge_pos)$/;"	f
embedg_VES_print_vertex	planarity.c	/^embedg_VES_print_vertex (int n, int v)$/;"	f
embedg_VES_print_virtual_vertex	planarity.c	/^embedg_VES_print_virtual_vertex (t_ver_edge *embed_graph, int n, int v)$/;"	f
embedg_VES_remove_edge	planarity.c	/^embedg_VES_remove_edge (t_ver_edge *embed_graph, int n, int e)$/;"	f
embedg_VES_set_orientation	planarity.c	/^embedg_VES_set_orientation (t_ver_edge *embed_graph, int n, int *ver_orient)$/;"	f
embedg_VES_walk_bicomp	planarity.c	/^embedg_VES_walk_bicomp (t_ver_edge *embed_graph, int n, int v, int vin)$/;"	f
embedg_VES_walk_mark_ext_face	planarity.c	/^embedg_VES_walk_mark_ext_face (t_ver_edge *embed_graph, int n, int v, int mark)$/;"	f	file:
embedg_VES_walk_mark_part_ext_face	planarity.c	/^embedg_VES_walk_mark_part_ext_face (t_ver_edge *embed_graph, int n,$/;"	f	file:
embedg_VES_walk_mark_part_proper_face	planarity.c	/^embedg_VES_walk_mark_part_proper_face (t_ver_edge *embed_graph, int n,$/;"	f	file:
embedg_VES_walk_proper_face	planarity.c	/^embedg_VES_walk_proper_face (t_ver_edge *embed_graph, int n, int e,$/;"	f
embedg_add_mark_u_x	planarity.c	/^embedg_add_mark_u_x (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f	file:
embedg_add_mark_v_w	planarity.c	/^embedg_add_mark_v_w (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f	file:
embedg_add_mark_v_w_for_B	planarity.c	/^embedg_add_mark_v_w_for_B (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f	file:
embedg_check_recov_embedding	planarity.c	/^embedg_check_recov_embedding (int n, int nbr_e, int nbr_comp,$/;"	f
embedg_check_recov_obs	planarity.c	/^embedg_check_recov_obs (t_dlcl **obs, int n, minor m)$/;"	f
embedg_dlcl_cat	planarity.c	/^embedg_dlcl_cat (t_dlcl *l, t_dlcl *m)$/;"	f
embedg_dlcl_copy	planarity.c	/^embedg_dlcl_copy (t_dlcl *l)$/;"	f
embedg_dlcl_delete	planarity.c	/^embedg_dlcl_delete (t_dlcl *l)$/;"	f
embedg_dlcl_delete_first	planarity.c	/^embedg_dlcl_delete_first (t_dlcl *l)$/;"	f
embedg_dlcl_delete_rec	planarity.c	/^embedg_dlcl_delete_rec (t_dlcl *l, t_dlcl *r)$/;"	f
embedg_dlcl_find	planarity.c	/^embedg_dlcl_find (t_dlcl *l, int info)$/;"	f
embedg_dlcl_find_with_NIL_twin_in_adjl	planarity.c	/^embedg_dlcl_find_with_NIL_twin_in_adjl (t_dlcl *l, int info)$/;"	f
embedg_dlcl_is_empty	planarity.c	/^embedg_dlcl_is_empty (t_dlcl *l)$/;"	f
embedg_dlcl_is_singleton	planarity.c	/^embedg_dlcl_is_singleton (t_dlcl *l)$/;"	f	file:
embedg_dlcl_length	planarity.c	/^embedg_dlcl_length (t_dlcl *l)$/;"	f
embedg_dlcl_list_last	planarity.c	/^embedg_dlcl_list_last (t_dlcl *l)$/;"	f
embedg_dlcl_list_next	planarity.c	/^embedg_dlcl_list_next (t_dlcl *l)$/;"	f
embedg_dlcl_list_prev	planarity.c	/^embedg_dlcl_list_prev (t_dlcl *l)$/;"	f
embedg_dlcl_print	planarity.c	/^embedg_dlcl_print (t_dlcl *l)$/;"	f
embedg_dlcl_rec_append	planarity.c	/^embedg_dlcl_rec_append (t_dlcl *l, t_dlcl *r)$/;"	f
embedg_dlcl_rec_delete	planarity.c	/^embedg_dlcl_rec_delete (t_dlcl *r)$/;"	f	file:
embedg_dlcl_rec_free	planarity.c	/^embedg_dlcl_rec_free (t_dlcl *r)$/;"	f	file:
embedg_dlcl_rec_insert_left	planarity.c	/^embedg_dlcl_rec_insert_left (t_dlcl *l, t_dlcl *r)$/;"	f	file:
embedg_dlcl_rec_insert_right	planarity.c	/^embedg_dlcl_rec_insert_right (t_dlcl *l, t_dlcl *r)$/;"	f	file:
embedg_dlcl_rec_new	planarity.c	/^embedg_dlcl_rec_new (int info)$/;"	f
embedg_dlcl_rec_prepend	planarity.c	/^embedg_dlcl_rec_prepend (t_dlcl *l, t_dlcl *r)$/;"	f
embedg_dlcl_rec_print	planarity.c	/^embedg_dlcl_rec_print (t_dlcl *r)$/;"	f
embedg_dlcl_rec_retrieve	planarity.c	/^embedg_dlcl_rec_retrieve (t_dlcl *r)$/;"	f	file:
embedg_embedding	planarity.c	/^embedg_embedding (t_ver_sparse_rep *V, t_adjl_sparse_rep *A,$/;"	f
embedg_get_least_neigh	planarity.c	/^embedg_get_least_neigh (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f	file:
embedg_get_reduced_obs	planarity.c	/^embedg_get_reduced_obs (t_dlcl **obs, int n)$/;"	f	file:
embedg_get_u_x	planarity.c	/^embedg_get_u_x (t_ver_edge *embed_graph, int n, int v, int x, int *u_x)$/;"	f	file:
embedg_init_insert_TE	planarity.c	/^embedg_init_insert_TE (t_ver_edge *embed_graph, int n, int *edge_pos, t_dlcl *p)$/;"	f	file:
embedg_is_embed_valid	planarity.c	/^embedg_is_embed_valid (t_ver_edge *embed_graph, int n, int nbr_comp,$/;"	f
embedg_is_red_obs_K33	planarity.c	/^embedg_is_red_obs_K33 (t_dlcl **reduced, int n)$/;"	f	file:
embedg_is_red_obs_K5	planarity.c	/^embedg_is_red_obs_K5 (t_dlcl **reduced, int n)$/;"	f	file:
embedg_iso_get_c_of_v	planarity.c	/^embedg_iso_get_c_of_v (t_ver_edge *embed_graph, int n, int v, int w)$/;"	f
embedg_iso_get_highest_x_y_path	planarity.c	/^embedg_iso_get_highest_x_y_path ($/;"	f
embedg_iso_get_x_y_w	planarity.c	/^embedg_iso_get_x_y_w (t_ver_edge *embed_graph, int n, int v, int r,$/;"	f
embedg_iso_is_minor_A	planarity.c	/^embedg_iso_is_minor_A (t_ver_edge *embed_graph, int n,$/;"	f
embedg_iso_is_minor_B	planarity.c	/^embedg_iso_is_minor_B (t_ver_edge *embed_graph, int n, int *edge_pos,$/;"	f
embedg_mark_minor_A	planarity.c	/^embedg_mark_minor_A (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f
embedg_mark_minor_B	planarity.c	/^embedg_mark_minor_B (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f
embedg_mark_minor_C	planarity.c	/^embedg_mark_minor_C (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f
embedg_mark_minor_D	planarity.c	/^embedg_mark_minor_D (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f
embedg_mark_minor_E	planarity.c	/^embedg_mark_minor_E (t_dlcl **dfs_tree, t_dlcl **back_edges,$/;"	f
embedg_mark_obstruction	planarity.c	/^embedg_mark_obstruction ($/;"	f
embedg_mark_tree_path	planarity.c	/^embedg_mark_tree_path (t_ver_edge *embed_graph, int n, int d_x, int x, int mark)$/;"	f	file:
embedg_mark_x_y_path	planarity.c	/^embedg_mark_x_y_path (t_ver_edge *embed_graph, int n, int *path_v,$/;"	f	file:
embedg_merge_queue_append	planarity.c	/^embedg_merge_queue_append (t_merge_queue *q, t_ver_edge *embed_graph,$/;"	f
embedg_merge_queue_append_vertex	planarity.c	/^embedg_merge_queue_append_vertex (t_merge_queue *q, t_ver_edge *embed_graph,$/;"	f
embedg_merge_queue_append_virtual_vertex	planarity.c	/^embedg_merge_queue_append_virtual_vertex (t_merge_queue *q,$/;"	f
embedg_merge_queue_delete	planarity.c	/^embedg_merge_queue_delete (t_merge_queue q)$/;"	f
embedg_merge_queue_empty	planarity.c	/^embedg_merge_queue_empty (t_merge_queue q)$/;"	f
embedg_merge_queue_get	planarity.c	/^embedg_merge_queue_get (t_merge_queue *q, int *v, int *vin, int *vv, int *vvout)$/;"	f
embedg_merge_queue_new	planarity.c	/^embedg_merge_queue_new (int n)$/;"	f
embedg_merge_queue_print	planarity.c	/^embedg_merge_queue_print (t_merge_queue q)$/;"	f
embedg_merge_queue_prune	planarity.c	/^embedg_merge_queue_prune (t_merge_queue *q, int *v,$/;"	f
embedg_merge_remaining_virtual	planarity.c	/^embedg_merge_remaining_virtual (t_ver_edge *embed_graph, int n)$/;"	f
embedg_nbr_faces	planarity.c	/^embedg_nbr_faces (t_ver_edge *embed_graph, int n, int edge_pos,$/;"	f
embedg_obstruction	planarity.c	/^embedg_obstruction ($/;"	f
embedg_planar_alg_init	planarity.c	/^embedg_planar_alg_init ($/;"	f
embedg_recov_embed_walk_proper_face	planarity.c	/^embedg_recov_embed_walk_proper_face (int n, int e, t_adjl_sparse_rep *A,$/;"	f
embedg_recover_embedding	planarity.c	/^embedg_recover_embedding ($/;"	f
embedg_recover_embedding_embed_loops	planarity.c	/^embedg_recover_embedding_embed_loops (t_dlcl **mult_edges,$/;"	f	file:
embedg_recover_embedding_embed_mult	planarity.c	/^embedg_recover_embedding_embed_mult (t_dlcl **mult_edges,$/;"	f	file:
embedg_recover_obstruction	planarity.c	/^embedg_recover_obstruction (t_ver_edge *embed_graph, int n, minor m, int *nbr_e)$/;"	f
embedg_remove_SCE	planarity.c	/^embedg_remove_SCE (t_ver_edge *embed_graph, int n, int edge_pos)$/;"	f
embedg_vertices_orientation	planarity.c	/^embedg_vertices_orientation (t_ver_edge *embed_graph, int n)$/;"	f
embedg_walkdown	planarity.c	/^embedg_walkdown (t_ver_edge *embed_graph, int n, int *edge_pos, int vv)$/;"	f
embedg_walkup	planarity.c	/^embedg_walkup (t_ver_edge *embed_graph, int n, int v, t_dlcl *p)$/;"	f
encodegraphsize	gtools.c	/^encodegraphsize(int n, char **pp)$/;"	f
encodegraphsize	naugstrings.c	/^encodegraphsize(int n, char **pp)$/;"	f	file:
end	genquarticg.c	/^    setword end;$/;"	m	struct:__anon6	file:
end	planarity.h	/^    int          start, end;$/;"	m	struct:merge_queue
end_vertex	planarity.h	/^    int          end_vertex; $/;"	m	struct:adjl_sparse_rep
ends	planarity.h	/^    int          ends[2];$/;"	m	struct:edge_sparse_rep
eno	cubhamg.c	/^static cubgraph eno;$/;"	v	file:
entrypoint	dreadnaut.c	/^    void (*entrypoint)(graph*,int*,int*,int,int,int,int*,int,boolean,int,int);$/;"	m	struct:invarrec	file:
entrypoint	labelg.c	/^    void (*entrypoint)(graph*,int*,int*,int,int,int,int*,$/;"	m	struct:invarrec	file:
entrypoint	shortg.c	/^    void (*entrypoint)(graph*,int*,int*,int,int,int,int*,$/;"	m	struct:invarrec	file:
entrypoint_sg	dreadnaut.c	/^    void (*entrypoint_sg)(graph*,int*,int*,int,int,int,int*,int,boolean,int,int);$/;"	m	struct:invarrec	file:
entrypoint_sg	labelg.c	/^    void (*entrypoint_sg)(graph*,int*,int*,int,int,int,int*,$/;"	m	struct:invarrec	file:
entrypoint_sg	shortg.c	/^    void (*entrypoint_sg)(graph*,int*,int*,int,int,int,int*,$/;"	m	struct:invarrec	file:
eplus	cubhamg.c	/^eplus(cubgraph acub, int n, int ne, int x, int y, int *pwhy)$/;"	f	file:
eqlev_canon	nauty.c	/^    eqlev_canon,   \/* level to which codes for this node match those$/;"	v	file:
eqlev_first	nauty.c	/^    eqlev_first,   \/* level to which codes for this node match those$/;"	v	file:
equitable	nautaux.c	/^equitable(graph *g, int *lab, int *ptn, int level, int m, int n)$/;"	f
errstatus	nauty.h	/^    int errstatus;          \/* if non-zero : an error code *\/$/;"	m	struct:__anon18
errstatus	traces.h	/^	int errstatus;$/;"	m	struct:TracesStats
exitfromref	traces.c	/^    boolean exitfromref;$/;"	m	struct:TracesInfo	file:
expandschreier	schreier.c	/^expandschreier(schreier *gp, permnode **ring, int n)$/;"	f
expathlength	traces.c	/^    int expathlength;$/;"	m	struct:TracesVars	file:
expaths	traces.c	/^    double expaths;$/;"	m	struct:TracesVars	file:
extend	genquarticg.c	/^extend(int n, graph *g, edgestruct *edge, pairstruct *epair, int numpair,$/;"	f	file:
extra_autom	nauty.c	/^extra_autom(int *p, int n)$/;"	f
extra_level	nauty.c	/^extra_level(int level, int *lab, int *ptn, int numcells, int tv1, int index,$/;"	f
extra_options	nauty.h	/^    void *extra_options;      \/* arbitrary extra options *\/$/;"	m	struct:optionstruct
f	sumlines.c	/^    double f;$/;"	m	union:__anon14	file:
factorial	traces.c	/^void factorial(double *size1, int *size2, int k) {$/;"	f
factorial2	traces.c	/^void factorial2(double *size1, int *size2, int k) {$/;"	f
fail_level	vcolg.c	/^static int fail_level;$/;"	v	file:
farend	cubhamg.c	/^    vertvec din,dout,farend;$/;"	m	struct:__anon16	file:
father	traces.c	/^    struct searchtrie *father;$/;"	m	struct:searchtrie	typeref:struct:searchtrie::searchtrie	file:
fcanonise	gtnauty.c	/^fcanonise(graph *g, int m, int n, graph *h, char *fmt, boolean digraph)$/;"	f
fcanonise_inv	gtnauty.c	/^fcanonise_inv(graph *g, int m, int n, graph *h, char *fmt,$/;"	f
fcanonise_inv_sg	gtnauty.c	/^fcanonise_inv_sg(sparsegraph *g, int m, int n, sparsegraph *h, char *fmt,$/;"	f
fertilenodes	genbg.c	/^static long nodes[MAXN],rigidnodes[MAXN],fertilenodes[MAXN];$/;"	v	file:
fertilenodes	geng.c	/^static unsigned long rigidnodes[MAXN],fertilenodes[MAXN];$/;"	v	file:
fertilenodes	gentourng.c	/^static unsigned long rigidnodes[MAXN],fertilenodes[MAXN];$/;"	v	file:
fgroup	gtnauty.c	/^fgroup(graph *g, int m, int n, char *fmt, int *orbits, int *numorbits)  $/;"	f
fgroup_inv	gtnauty.c	/^fgroup_inv(graph *g, int m, int n, char *fmt, int *orbits, int *numorbits,$/;"	f
fileptr	dreadnaut.c	/^static FILE *fileptr[MAXIFILES];$/;"	v	file:
fill_edgelist	watercluster2.c	/^void fill_edgelist()$/;"	f
fill_edgelist_edgeorb	watercluster2.c	/^void fill_edgelist_edgeorb()$/;"	f
fill_edgelist_edgeorb_final	watercluster2.c	/^void fill_edgelist_edgeorb_final()$/;"	f
fill_edgelist_edgeorb_order	watercluster2.c	/^void fill_edgelist_edgeorb_order()$/;"	f
fill_edgelist_edgeorb_order_final	watercluster2.c	/^void fill_edgelist_edgeorb_order_final()$/;"	f
fill_edgelist_final	watercluster2.c	/^void fill_edgelist_final(graph g[])$/;"	f
fill_edgelist_order	watercluster2.c	/^void fill_edgelist_order()$/;"	f
fill_edgelist_order_final	watercluster2.c	/^void fill_edgelist_order_final()$/;"	f
filtercount	schreier.c	/^TLS_ATTR long long filtercount = 0;$/;"	v
filterschreier	schreier.c	/^filterschreier(schreier *gp, int *p, permnode **ring,$/;"	f	file:
finalnumcells	traces.c	/^    int finalnumcells;$/;"	m	struct:TracesVars	file:
find_dist	gutil1.c	/^find_dist(graph *g, int m, int n, int v, int *dist)$/;"	f
find_dist2	gutil1.c	/^find_dist2(graph *g, int m, int n, int v, int w, int *dist)$/;"	f
find_maxint	sumlines.c	/^find_maxint(void)$/;"	f
findcurrorbits	traces.c	/^int *findcurrorbits(schreier *gp, int k) {$/;"	f
findperm	traces.c	/^boolean findperm(permnode *pn, int *p, int n) {$/;"	f
findpermutation	schreier.c	/^findpermutation(permnode *pn, int *p, int n)$/;"	f
first	directg.c	/^static boolean first;$/;"	v	file:
first	genquarticg.c	/^	int first;$/;"	m	struct:__anon6	file:
first	genquarticg.c	/^	int first;$/;"	m	struct:__anon7	file:
first	multig.c	/^static boolean first;$/;"	v	file:
first	vcolg.c	/^static boolean first;$/;"	v	file:
first1	genquarticg.c	/^	int first1;$/;"	m	struct:__anon8	file:
first2	genquarticg.c	/^	int first2;$/;"	m	struct:__anon8	file:
first_child	traces.c	/^    struct searchtrie *first_child;$/;"	m	struct:searchtrie	typeref:struct:searchtrie::searchtrie	file:
first_child	traces.c	/^    struct trie *first_child;$/;"	m	struct:trie	typeref:struct:trie::trie	file:
first_echunk	naututil.c	/^static TLS_ATTR echunk first_echunk = {NULL,{0}};$/;"	v	file:
first_echunkw	naututil.c	/^static TLS_ATTR echunkw first_echunkw = {NULL,{0,0,0}};$/;"	v	file:
first_edge	planarity.h	/^    int          first_edge; \/* can be index into an adj. list$/;"	m	struct:ver_sparse_rep
first_matching	traces.c	/^    boolean first_matching;$/;"	m	struct:TracesInfo	file:
firstcode	nauty.c	/^static TLS_ATTR short firstcode[MAXN+2],      \/* codes for first leaf *\/$/;"	v	file:
firstlab	nauty.c	/^static TLS_ATTR int firstlab[MAXN],   \/* label from first leaf *\/$/;"	v	file:
firstpath	dreadnaut.c	/^static boolean firstpath;       \/* used in usernode() *\/$/;"	v	file:
firstpathlength	traces.c	/^    int firstpathlength;$/;"	m	struct:TracesVars	file:
firstpathnode0	nauty.c	/^firstpathnode0(int *lab, int *ptn, int level, int numcells,$/;"	f	file:
firstsingcode	traces.c	/^    unsigned int firstsingcode;$/;"	m	struct:Candidate	file:
firsttc	nauty.c	/^static TLS_ATTR int firsttc[MAXN+2];  \/* index of target cell for left path *\/$/;"	v	file:
firstterminal	nauty.c	/^firstterminal(int *lab, int level)$/;"	f	file:
fishtail	twohamg.c	/^fishtail(int n, int *nblue, int *nred)$/;"	f	file:
fixed	schreier.h	/^    int fixed;                     \/* fixed at next level, -1 if none *\/$/;"	m	struct:schreierlevel
fixedpt	naugroup.h	/^    int fixedpt;       \/* point that is fixed in this level *\/$/;"	m	struct:level_struct
fixedpts	nauty.c	/^static TLS_ATTR set fixedpts[MAXM];      \/* points which were explicitly$/;"	v	file:
fixit	naututil.c	/^fixit(int *lab, int *ptn, int *numcells, int fixedvertex, int n)$/;"	f
flags	sumlines.c	/^   int flags;$/;"	m	struct:fmt_st	file:
flushline	naututil.c	/^flushline(FILE *f)$/;"	f
fmperm	nautil.c	/^fmperm(int *perm, set *fix, set *mcr, int m, int n)$/;"	f
fmptn	nautil.c	/^fmptn(int *lab, int *ptn, int level, set *fix, set *mcr, int m, int n)$/;"	f
fmptr	nauty.c	/^static TLS_ATTR set *fmptr;                   \/* pointer into workspace *\/$/;"	v	file:
fmt	sumlines.c	/^    char *fmt;$/;"	m	struct:countrec	file:
fmt	sumlines.c	/^   char *fmt;$/;"	m	struct:fmt_st	file:
fmt_st	sumlines.c	/^static struct fmt_st$/;"	s	file:
fn	genquarticg.c	/^    setword fn;$/;"	m	struct:__anon6	file:
footfree	genbg.c	/^boolean footfree;               \/* presence of -F *\/$/;"	v
force_edges	watercluster2.c	/^void force_edges(int top, int all_out, BOOG forcelist[], int *listlen, int *problem)$/;"	f
format	sumlines.c	/^} format[MAXFORMATS];$/;"	v	typeref:struct:fmt_st	file:
fout	sumlines.c	/^static char *dout,*fout,*vout,*hmsout1,*hmsout2;$/;"	v	file:
fragments	genbg.c	/^fragments(int *x, int nx, int *frag, int *nfrag)$/;"	f	file:
freedyn	nauty.h	/^    void    (*freedyn)(void); \/* free dynamic memory *\/$/;"	m	struct:__anon19
freegroup	naugroup.c	/^freegroup(grouprec *grp)$/;"	f
freelist	naugroup.c	/^static permrec *freelist = NULL;$/;"	v	file:
freelist_n	naugroup.c	/^static int freelist_n = 0;$/;"	v	file:
freepermrec	naugroup.c	/^freepermrec(permrec *p, int n)$/;"	f
freeschreier	schreier.c	/^freeschreier(schreier **gp, permnode **gens)$/;"	f
fromlevel	traces.c	/^    int fromlevel;$/;"	m	struct:TracesVars	file:
fromsort	shortg.c	/^fromsort(FILE *f, char **cdstr, char **dstr, nauty_counter *index)$/;"	f	file:
fuzz1	nausparse.c	/^static const int fuzz1[] = {037541,061532,005257,026416};$/;"	v	file:
fuzz1	nautinv.c	/^static const int fuzz1[] = {037541,061532,005257,026416};$/;"	v	file:
fuzz1	naututil.c	/^static const long fuzz1[] = {1984625421L, 971524688L,1175081625L, 377165387L};$/;"	v	file:
fuzz1	traces.c	/^static const unsigned int fuzz1[] = {037541, 061532, 005257, 026416};$/;"	v	file:
fuzz2	gtnauty.c	/^static int fuzz2[] = {006532,070236,035523,062437};$/;"	v	file:
fuzz2	nausparse.c	/^static const int fuzz2[] = {006532,070236,035523,062437};$/;"	v	file:
fuzz2	nautinv.c	/^static const int fuzz2[] = {006532,070236,035523,062437};$/;"	v	file:
fuzz2	naututil.c	/^static const long fuzz2[] = {2001381726L,1615243355L, 191176436L,1212176501L};$/;"	v	file:
fuzz2	traces.c	/^static const unsigned int fuzz2[] = {006532, 070236, 035523, 062437};$/;"	v	file:
g	dreadnaut.c	/^static graph g[MAXM*1L*MAXN];$/;"	v	file:
g	nauty.c	/^static TLS_ATTR graph *g,*canong;$/;"	v	file:
g0	gtnauty.c	/^static set *g0;$/;"	v	file:
g_sg	dreadnaut.c	/^static sparsegraph g_sg;$/;"	v	file:
gca_canon	nauty.c	/^    gca_canon,     \/* ditto for current node and bsf leaf *\/$/;"	v	file:
gca_first	nauty.c	/^static TLS_ATTR int gca_first, \/* level of greatest common ancestor of$/;"	v	file:
gcan	genbg.c	/^static graph gcan[MAXN];$/;"	v	file:
gcan	geng.c	/^static graph gcan[MAXN];$/;"	v	file:
gcan	gentourng.c	/^static graph gcan[MAXN];$/;"	v	file:
gcomplement	geng.c	/^gcomplement(graph *g, graph *gc, int n)$/;"	f	file:
gcomplement	genrang.c	/^gcomplement(graph *g, boolean loopstoo, int m, int n)$/;"	f	file:
gcomplement	gentourng.c	/^gcomplement(graph *g, graph *gc, int n)$/;"	f	file:
gcomplement_bip	genrang.c	/^gcomplement_bip(graph *g, int m, int n1, int n2)$/;"	f	file:
generators	traces.h	/^	permnode **generators;$/;"	m	struct:TracesOptions
generators	watercluster2.c	/^permutation generators[MAXN][MAXN];$/;"	v
genextend	genbg.c	/^genextend(graph *g, int n2, int *deg, int ne, boolean rigid, int xlb, int xub)$/;"	f	file:
genextend	geng.c	/^genextend(graph *g, int n, int *deg, int ne, boolean rigid, int xlb, int xub)$/;"	f	file:
genextend	gentourng.c	/^genextend(graph *g, int n, int *deg, boolean rigid)$/;"	f	file:
gens	naugroup.c	/^static permrec *gens;$/;"	v	file:
gens	naugroup.h	/^    permrec *gens;     \/* pointer to list of generators *\/$/;"	m	struct:level_struct
gens	nauty.c	/^static TLS_ATTR permnode *gens;$/;"	v	file:
gensB	traces.c	/^static TLS_ATTR permnode  *gensB;			\/* This will point to the stored generators *\/$/;"	v	file:
get_orbit	watercluster2.c	/^void get_orbit(BOOG kleinste_orbit[], int *orbitsize, int *biggest_orbit)$/;"	f
get_orbit_first	watercluster2.c	/^void get_orbit_first(BOOG kleinste_orbit[], int *orbitsize, int *fixedgeindex, int *biggest_orbit)$/;"	f
getbigcells	nautinv.c	/^getbigcells(int *ptn, int level, int minsize, int *bigcells,$/;"	f
getcanon	nauty.c	/^   boolean getcanon,digraph,writeautoms,domarkers,cartesian,doschreier;$/;"	v	file:
getcanon	nauty.h	/^    int getcanon;             \/* make canong and canonlab? *\/$/;"	m	struct:optionstruct
getcanon	traces.h	/^	boolean getcanon;$/;"	m	struct:TracesOptions
getecline	gtools.c	/^getecline(FILE *f)     \/* read an edge_code line *\/$/;"	f
getexpensivequality	watercluster2.c	/^int getexpensivequality(graph x,graph y)$/;"	f
getint	naututil.c	/^getint(FILE *f)$/;"	f
getint_sl	naututil.c	/^getint_sl(FILE *f)$/;"	f
getorbits	schreier.c	/^getorbits(int *fix, int nfix, schreier *gp, permnode **ring, int n)$/;"	f
getorbitsmin	schreier.c	/^getorbitsmin(int *fix, int nfix, schreier *gp, permnode **ring,$/;"	f
girth	gutil1.c	/^girth(graph *g, int m, int n)$/;"	f
given_gens	traces.c	/^int given_gens(sparsegraph *g, permnode *gens, int *orbits, boolean digraph) {$/;"	f
gm	gtnauty.c	/^static int gm;$/;"	v	file:
goes_to	traces.c	/^    struct searchtrie *goes_to;$/;"	m	struct:searchtrie	typeref:struct:searchtrie::searchtrie	file:
good	gentreeg.c	/^good( int p, int h, int t ) {$/;"	f	file:
goodret	genquarticg.c	/^boolean     goodret;$/;"	v
gotonode	traces.c	/^    struct searchtrie *gotonode;$/;"	m	struct:TracesVars	typeref:struct:TracesVars::searchtrie	file:
gp	nauty.c	/^static TLS_ATTR schreier *gp;       \/* These two for Schreier computations *\/$/;"	v	file:
gpB	traces.c	/^static TLS_ATTR schreier  *gpB;				\/* This will point to the Schreier structure *\/$/;"	v	file:
grandgraph	genrang.c	/^grandgraph(graph *g, boolean digraph, boolean loopsok,$/;"	f	file:
grandgraph_bip	genrang.c	/^grandgraph_bip(graph *g, boolean digraph,$/;"	f	file:
grandtourn	genrang.c	/^grandtourn(graph *g, int m, int n)$/;"	f	file:
grandtourn_bip	genrang.c	/^grandtourn_bip(graph *g, int m, int n1, int n2)$/;"	f	file:
graph	nauty.h	/^typedef setword set,graph;$/;"	t
graph	showg.c	/^typedef setword graph;$/;"	t	file:
graph	traces.c	/^    sparsegraph *graph;$/;"	m	struct:TracesVars	file:
graph6	genbg.c	/^boolean graph6;                 \/* presence of -g *\/$/;"	v
graph6	geng.c	/^boolean graph6;                 \/* presence of -g *\/$/;"	v
graph6	genquarticg.c	/^boolean     graph6;                         \/* presence of -g *\/$/;"	v
graph6	gentourng.c	/^boolean graph6;                 \/* presence of -g *\/$/;"	v
graph_sparse_rep	planarity.h	/^typedef struct graph_sparse_rep {$/;"	s
graphsize	gtools.c	/^graphsize(char *s)$/;"	f
graphsize	showg.c	/^graphsize(char *s)$/;"	f	file:
greout	genbg.c	/^boolean greout;                 \/* presence of -a *\/$/;"	v
group	naugroup.c	/^static grouprec *group = NULL;$/;"	v	file:
group_depth	naugroup.c	/^static int group_depth = 0;$/;"	v	file:
group_in_range	testg.c	/^group_in_range(group_node *sz, long lo, long hi)$/;"	f	file:
group_level	traces.c	/^    int group_level;$/;"	m	struct:TracesVars	file:
group_node	testg.c	/^} group_node;$/;"	t	typeref:struct:grpsize_st	file:
group_struct	naugroup.h	/^typedef struct group_struct$/;"	s
group_up_to_date	watercluster2.c	/^int group_up_to_date=0;$/;"	v
groupautomproc	naugroup.c	/^groupautomproc(int count, int *perm, int *orbits,$/;"	f
groupelts	naugroup.c	/^groupelts(levelrec *lr, int n, int level, void (*action)(int*,int),$/;"	f	file:
groupelts2	naugroup.c	/^groupelts2(levelrec *lr, int n, int level,$/;"	f	file:
groupelts3	naugroup.c	/^groupelts3(levelrec *lr, int n, int level,$/;"	f	file:
grouplevelproc	naugroup.c	/^grouplevelproc(int *lab, int *ptn, int level, int *orbits, statsblk *stats,$/;"	f
grouporder	schreier.c	/^grouporder(int *fix, int nfix, schreier *gp, permnode **ring, $/;"	f
grouporderplus	traces.c	/^void grouporderplus(sparsegraph *sg_orig, Candidate *Cand, Partition *Part, permnode **ring,$/;"	f
groupptr	naugroup.c	/^groupptr(boolean cutloose)$/;"	f
grouprec	naugroup.h	/^} grouprec;$/;"	t	typeref:struct:group_struct
groupsize	directg.c	/^static unsigned long groupsize;$/;"	v	file:
groupsize	multig.c	/^static unsigned long groupsize;$/;"	v	file:
groupsize	vcolg.c	/^static unsigned long groupsize;$/;"	v	file:
groupsize1	nauty.h	835;"	d
groupsize1	testg.c	/^    double groupsize1;$/;"	m	struct:grpsize_st	file:
groupsize2	nauty.h	836;"	d
groupsize2	testg.c	/^    long groupsize2;$/;"	m	struct:grpsize_st	file:
groupstats	testg.c	/^groupstats(graph *g, boolean digraph, int m, int n, group_node *sz,$/;"	f	file:
grph_strct	traces.c	/^typedef struct grph_strct {$/;"	s	file:
grph_strct	traces.c	/^} grph_strct;$/;"	t	typeref:struct:grph_strct	file:
grpsize1	nauty.h	/^    double grpsize1;        \/* size of group is *\/$/;"	m	struct:__anon18
grpsize1	traces.h	/^	double grpsize1;$/;"	m	struct:TracesStats
grpsize2	nauty.h	/^    int grpsize2;           \/*    grpsize1 * 10^grpsize2 *\/$/;"	m	struct:__anon18
grpsize2	traces.h	/^	int grpsize2;$/;"	m	struct:TracesStats
grpsize_st	testg.c	/^typedef struct grpsize_st$/;"	s	file:
gt_abort	gtools.c	/^gt_abort(const char *msg)     \/* Write message and halt. *\/$/;"	f
gt_abort	showg.c	/^gt_abort(char *msg)     \/* Write message and halt. *\/$/;"	f	file:
gt_numorbits	gtnauty.c	/^int gt_numorbits;$/;"	v
gtocub	cubhamg.c	/^gtocub(graph *g, int m, int n, cubgraph cub, int *pne)$/;"	f	file:
gtod6string	naugstrings.c	/^gtod6string(graph *g, char **pp, int m, int n)$/;"	f
gtog6string	naugstrings.c	/^gtog6string(graph *g, char **pp, int m, int n)$/;"	f
gtois6string	naugstrings.c	/^gtois6string(graph *g, graph *prevg, char **pp, int m, int n)$/;"	f
gtools_check	gtools.c	/^gtools_check(int wordsize, int m, int n, int version)$/;"	f
gtools_getline	gtools.c	/^gtools_getline(FILE *f)     \/* read a line with error checking *\/$/;"	f
gtos6string	naugstrings.c	/^gtos6string(graph *g, char **pp, int m, int n)$/;"	f
hamheur	hamheuristic.c	/^hamheur(sparsegraph *sg, boolean pathok, unsigned long limit, int *cyc)$/;"	f	file:
hamnode	cubhamg.c	/^hamnode(cubgraph g, cubgraph eno, edgevec v1, edgevec v2,$/;"	f	file:
hase34	cubhamg.c	/^hase34(cubgraph cub,$/;"	f	file:
hash	naututil.c	/^hash(set *setarray, long length, int key)$/;"	f
hashgraph	naututil.c	/^hashgraph(graph *g, int m, int n, long key)$/;"	f
hashgraph_sg	naututil.c	/^hashgraph_sg(sparsegraph *sg, long key)$/;"	f
hasin	cubhamg.c	/^hasin(cubgraph cub, int n, int ne, int *x0, int *x1, int limit)$/;"	f	file:
hasinin	cubhamg.c	/^hasinin(cubgraph cub,$/;"	f	file:
hasinout	cubhamg.c	/^hasinout(cubgraph cub,$/;"	f	file:
hasloops	gtnauty.c	/^hasloops(graph *g, int m, int n)$/;"	f	file:
hasloops_sg	gtnauty.c	/^hasloops_sg(sparsegraph *sg)$/;"	f	file:
hasout	cubhamg.c	/^hasout(cubgraph cub, int n, int ne, int weight, int *x0, int *x1, int limit)$/;"	f	file:
hcnodat	cubhamg.c	/^static nodedata hcnodat;$/;"	v	file:
header	geng.c	/^boolean header;                 \/* presence of -h *\/$/;"	v
header	genquarticg.c	/^boolean     header;                         \/* presence of -h *\/$/;"	v
header	gentourng.c	/^boolean header;                 \/* presence of -h *\/$/;"	v
help	dreadnaut.c	/^help(FILE *f, int i)$/;"	f	file:
hi	genbg.c	/^    int lo,hi;           \/* work purposes for orbit calculation *\/$/;"	m	struct:__anon3	file:
hi	geng.c	/^    xword lo,hi;          \/* work purposes for orbit calculation *\/$/;"	m	struct:__anon17	file:
hi	gentourng.c	/^    xword lo,hi;          \/* work purposes for orbit calculation *\/$/;"	m	struct:__anon15	file:
hi	testg.c	/^    long lo,hi;$/;"	m	struct:constraint_st	file:
hitinvar	gentourng.c	/^hitinvar(graph *g, int *invar, int n)$/;"	f	file:
hmsout1	sumlines.c	/^static char *dout,*fout,*vout,*hmsout1,*hmsout2;$/;"	v	file:
hmsout2	sumlines.c	/^static char *dout,*fout,*vout,*hmsout1,*hmsout2;$/;"	v	file:
id	testg.c	/^    char *id;$/;"	m	struct:constraint_st	file:
id_permnode	schreier.c	/^static permnode id_permnode; $/;"	v	file:
identitygroup	traces.c	/^    boolean identitygroup;$/;"	m	struct:TracesInfo	file:
il	sumlines.c	/^static integerlist il[MAXVALUES];$/;"	v	file:
image	naugroup.h	/^    int image;       \/* image of fixed point *\/$/;"	m	struct:coset_struct
in_adjl	planarity.h	/^    int            in_adjl;      \/* if relevant, the pos in the adjl. list$/;"	m	struct:dlcl
in_adjl	planarity.h	/^    int          in_adjl;$/;"	m	struct:ver_edge
in_adjl	planarity.h	/^    int          in_adjl;\/* index of edge in adj. list *\/$/;"	m	struct:embed_sparse_rep
indcyclecount	gutil2.c	/^indcyclecount(graph *g, int m, int n)$/;"	f
indcyclecount1	gutil2.c	/^indcyclecount1(graph *g, int n)$/;"	f
indeg	directg.c	/^static int lastlev[MAXNV],indeg[MAXNV],outdeg[MAXNV];$/;"	v	file:
indeg	watercluster2.c	/^int deg[MAXN]={0}, outdeg[MAXN]={0}, indeg[MAXN]={0};$/;"	v
indeg_free	watercluster2.c	/^int indeg_free[MAXN]={0}, outdeg_free[MAXN]={0}, saturated[MAXN]={0};$/;"	v
index	traces.c	/^    int index;$/;"	m	struct:searchtrie	file:
indiv_vtx	traces.c	/^    int indiv_vtx;$/;"	m	struct:TracesVars	file:
indivend	traces.c	/^    int indivend;$/;"	m	struct:TracesVars	file:
individualise	naututil.c	/^individualise(int *lab,int *ptn, int level,$/;"	f
indivstart	traces.c	/^    int indivstart;$/;"	m	struct:TracesVars	file:
indnum	traces.c	/^    int indnum;$/;"	m	struct:Candidate	file:
indpathcount1	gutil2.c	/^indpathcount1(graph *g, int start, setword body, setword last)$/;"	f
indsets	nautinv.c	/^indsets(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
infile	listg.c	/^static FILE *infile,*outfile;$/;"	v	file:
infile	showg.c	/^static FILE *infile,*outfile;$/;"	v	file:
info	planarity.h	/^    int            info;$/;"	m	struct:dlcl
info	traces.c	/^    int info;$/;"	m	struct:ExpPathInfo	file:
init	nauty.h	/^    void    (*init)(graph*,graph**,graph*,graph**,int*,int*,set*,$/;"	m	struct:__anon19
init_allocated_fields	watercluster2.c	/^void init_allocated_fields()$/;"	f
init_for_g6	watercluster2.c	/^void init_for_g6(graph g[],int aantal_toppen, int degree[])$/;"	f
init_nauty_options	watercluster2.c	/^void init_nauty_options()$/;"	f
init_refinex	genquarticg.c	/^init_refinex( int *clr, int *lb, int *p, set *active, int n)$/;"	f	file:
init_sg	nausparse.c	/^init_sg(graph *gin, graph **gout, graph *hin, graph **hout, int *lab,$/;"	f
init_waterplugin	watercluster2.c	/^void init_waterplugin(int toppen)$/;"	f
initialise_colouring	twohamg.c	/^initialise_colouring(int n)$/;"	f	file:
initialise_g	twohamg.c	/^initialise_g(int n, int *e)$/;"	f	file:
initschreier	schreier.c	/^initschreier(schreier *sh, int n)$/;"	f	file:
input_graph	traces.c	/^    sparsegraph *input_graph;$/;"	m	struct:TracesVars	file:
integer	sumlines.c	/^typedef long integer;$/;"	t	file:
integer	sumlines.c	/^typedef long long integer;$/;"	t	file:
integerlist	sumlines.c	/^} integerlist;$/;"	t	typeref:struct:__anon13	file:
interrupted	traces.h	/^	unsigned long interrupted;$/;"	m	struct:TracesStats
intersect	genquarticg.c	/^    int intersect;$/;"	m	struct:__anon6	file:
inv	planarity.h	/^    int          inv;    \/* inverse edge *\/$/;"	m	struct:embed_sparse_rep
inv	traces.c	/^    int *inv;$/;"	m	struct:Partition	file:
invapplics	nauty.c	/^static TLS_ATTR unsigned long invapplics,invsuccesses;$/;"	v	file:
invapplics	nauty.h	/^    unsigned long invapplics;    \/* number of applications of invarproc *\/$/;"	m	struct:__anon18
invararg	nauty.c	/^static TLS_ATTR int linelength,tc_level,mininvarlevel,maxinvarlevel,invararg;$/;"	v	file:
invararg	nauty.h	/^    int invararg;             \/* value passed to (*invarproc)() *\/$/;"	m	struct:optionstruct
invarproc	dreadnaut.c	/^} invarproc[]$/;"	v	typeref:struct:invarrec	file:
invarproc	labelg.c	/^} invarproc[]$/;"	v	typeref:struct:invarrec	file:
invarproc	nauty.c	/^static TLS_ATTR void (*invarproc)$/;"	v	file:
invarproc	nauty.h	/^    void (*invarproc)         \/* procedure to compute vertex-invariant *\/$/;"	m	struct:optionstruct
invarproc	shortg.c	/^} invarproc[]$/;"	v	typeref:struct:invarrec	file:
invarprocname	nauty.h	/^    char *invarprocname;      \/* Magma - no longer global sjc 1994 *\/$/;"	m	struct:optionstruct
invarrec	dreadnaut.c	/^static struct invarrec$/;"	s	file:
invarrec	labelg.c	/^static struct invarrec$/;"	s	file:
invarrec	shortg.c	/^static struct invarrec$/;"	s	file:
invarsuclevel	nauty.c	/^static TLS_ATTR int invarsuclevel;$/;"	v	file:
invarsuclevel	nauty.h	/^    int invarsuclevel;      \/* least level where invarproc worked *\/$/;"	m	struct:__anon18
inverse	testg.c	/^    boolean inverse;$/;"	m	struct:constraint_st	file:
invlab	dretodot.c	/^int invlab[MAXN];$/;"	v
invlab	traces.c	/^    int *invlab;$/;"	m	struct:Candidate	file:
invsuccesses	nauty.c	/^static TLS_ATTR unsigned long invapplics,invsuccesses;$/;"	v	file:
invsuccesses	nauty.h	/^    unsigned long invsuccesses;  \/* number of successful uses of invarproc() *\/$/;"	m	struct:__anon18
irred	quarticirred28.h	/^static char *irred[] = {$/;"	v
is_canonical_edge	watercluster2.c	/^int is_canonical_edge(BOOG list[],int last_positie)$/;"	f
is_gericht	watercluster2.c	/^int is_gericht[MAX_BOGEN][MAX_BOGEN]={{0}}; \/*  is_gericht[i][j]==1 als {i,j} is al gericht -- anders 0 *\/$/;"	v
is_odd	naurng.c	75;"	d	file:
is_odd	rng.c	74;"	d	file:
is_pipe	gtools.c	/^TLS_ATTR boolean is_pipe;$/;"	v
isautom	naugraph.c	/^isautom(graph *g, int *perm, boolean digraph, int m, int n)$/;"	f
isautom	nauty.h	/^    boolean (*isautom)        \/* test for automorphism *\/$/;"	m	struct:__anon19
isautom_sg	nausparse.c	/^isautom_sg(graph *g, int *p, boolean digraph, int m, int n)$/;"	f
isautom_sg_pair	traces.c	/^boolean isautom_sg_pair(graph *g, int *p, boolean digraph, int m, int n, struct TracesVars *tv) {$/;"	f
isbiconnected	geng.c	/^isbiconnected(graph *g, int n)$/;"	f	file:
isbiconnected	genquarticg.c	/^isbiconnected(graph *g, int n)$/;"	f	file:
isbiconnected	gutil1.c	/^isbiconnected(graph *g, int m, int n)$/;"	f
isbiconnected1	gutil1.c	/^isbiconnected1(graph *g, int n)$/;"	f
isbipartite	gutil1.c	/^isbipartite(graph *g, int m, int n)$/;"	f
isconnected	genbg.c	/^isconnected(graph *g, int n)$/;"	f	file:
isconnected	geng.c	/^isconnected(graph *g, int n)$/;"	f	file:
isconnected	genquarticg.c	/^isconnected(graph *g, int n)$/;"	f	file:
isconnected	gutil1.c	/^isconnected(graph *g, int m, int n)$/;"	f
isconnected1	gutil1.c	/^isconnected1(graph *g, int n)$/;"	f
iscrossdecomposable	twohamg.c	/^iscrossdecomposable(sparsegraph sg, int vertex)$/;"	f	file:
isdecomposable	twohamg.c	/^isdecomposable(sparsegraph sg, int *ham1, int *ham2)$/;"	f	file:
isham	cubhamg.c	/^isham(cubgraph cub,$/;"	f	file:
ismax	directg.c	/^ismax(int *p, int n)$/;"	f	file:
ismax	multig.c	/^ismax(int *p, int n)$/;"	f	file:
ismax	vcolg.c	/^ismax(int *p, int n)$/;"	f	file:
isplanar	planarg.c	/^isplanar(t_ver_sparse_rep *V, int n, t_adjl_sparse_rep *A, int e,$/;"	f	file:
isstrong	gentourng.c	/^isstrong(graph *g, int n)$/;"	f	file:
issubconnected	gutil1.c	/^issubconnected(graph *g, set *sub, int m, int n)$/;"	f
issymm	gtnauty.c	/^static boolean issymm;$/;"	v	file:
istransitive	gtnauty.c	/^istransitive(graph *g, int m, int n, graph *h)$/;"	f
itos	nautil.c	/^itos(int i, char *s)$/;"	f
itos	showg.c	/^itos(int i, char *s)$/;"	f	file:
ix	directg.c	/^static int ix[2*MAXNE],nix;$/;"	v	file:
ix	multig.c	/^static int ix[MAXNE+MAXNV],nix;$/;"	v	file:
keptcounter	traces.c	/^    unsigned long keptcounter;$/;"	m	struct:TracesSpine	file:
key	testg.c	/^static int key[MAXKEYS];$/;"	v	file:
knm	gutil2.c	/^static TLS_ATTR int knm[18][16];  \/* knm[n,m] = conncontent(K_n - m*K_2) *\/$/;"	v	file:
knm_computed	gutil2.c	/^static TLS_ATTR boolean knm_computed = FALSE;$/;"	v	file:
l	sumlines.c	/^    integerlist *l;$/;"	m	union:__anon14	file:
laatstepositie	watercluster2.c	/^BOOG *laatstepositie; \/* The last position in one of these lists. Global in order not to have to copy it every time *\/$/;"	v
lab	dreadnaut.c	/^static int lab[MAXN];$/;"	v	file:
lab	dretodot.c	/^int lab[MAXN];$/;"	v
lab	traces.c	/^    int *lab;$/;"	m	struct:Candidate	file:
lab	watercluster2.c	/^nvector lab[MAX_BOGEN][MAXN]={{0}}, ptn[MAX_BOGEN][MAXN]={{0}}, orbits[MAX_BOGEN], colour[MAX_BOGEN][MAXN]={{0}};$/;"	v
lab_h	nauty.h	/^    int lab_h;                \/* Magma - no longer global sjc 1994 *\/$/;"	m	struct:optionstruct
labcol	dretodot.c	/^    int labcol;$/;"	m	struct:NodeShape	file:
label	planarity.h	/^    int          label;$/;"	m	struct:ver_edge
labelorg	nautil.c	/^int labelorg = 0;   \/* no TLS_ATTR on purpose *\/$/;"	v
labelorg	showg.c	/^static int labelorg = 0;$/;"	v	file:
last_child	traces.c	/^    struct searchtrie *last_child;$/;"	m	struct:searchtrie	typeref:struct:searchtrie::searchtrie	file:
lastcell	traces.c	/^    int lastcell;$/;"	m	struct:TracesVars	file:
lastlev	directg.c	/^static int lastlev[MAXNV],indeg[MAXNV],outdeg[MAXNV];$/;"	v	file:
lastlev	multig.c	/^static int lastlev[MAXNE];$/;"	v	file:
lastlev	traces.c	/^    int lastlev;$/;"	m	struct:TracesVars	file:
lastreject	directg.c	/^static int lastreject[MAXNV];$/;"	v	file:
lastreject	multig.c	/^static int lastreject[MAXNV];$/;"	v	file:
lastreject	vcolg.c	/^static int lastreject[MAXNV];$/;"	v	file:
lastrejok	directg.c	/^static boolean lastrejok;$/;"	v	file:
lastrejok	multig.c	/^static boolean lastrejok;$/;"	v	file:
lastrejok	vcolg.c	/^static boolean lastrejok;$/;"	v	file:
lastseq	sumlines.c	/^static integer lastseq[MAXFORMATS];$/;"	v	file:
least_ancestor	planarity.h	/^    int          least_ancestor;$/;"	m	struct:ver_edge
left	planarity.h	/^    struct dlcl    * left;$/;"	m	struct:dlcl	typeref:struct:dlcl::dlcl
left	sumlines.c	/^    struct countrec *left,*right,*parent;$/;"	m	struct:countrec	typeref:struct:countrec::countrec	file:
left	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:grpsize_st	typeref:struct:grpsize_st::splay_st	file:
left	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:node_st	typeref:struct:node_st::splay_st	file:
left	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:splay_st	typeref:struct:splay_st::splay_st	file:
left	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:value_st	typeref:struct:value_st::splay_st	file:
leftbit	nauty.h	/^int leftbit[] =   {8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,$/;"	v
leftbit	showg.c	/^static int leftbit[] =$/;"	v	file:
lese_multicode	watercluster2.c	/^int lese_multicode(unsigned char**code, int *codelaenge, FILE *fil)$/;"	f
lev_of_lastauto	traces.c	/^    int lev_of_lastauto;$/;"	m	struct:TracesVars	file:
level	traces.c	/^    int level;$/;"	m	struct:searchtrie	file:
level_struct	naugroup.h	/^typedef struct level_struct$/;"	s
levelcounter	traces.c	/^    unsigned long levelcounter;$/;"	m	struct:TracesSpine	file:
leveldata	genbg.c	/^} leveldata;$/;"	t	typeref:struct:__anon3	file:
leveldata	geng.c	/^} leveldata;$/;"	t	typeref:struct:__anon17	file:
leveldata	gentourng.c	/^} leveldata;$/;"	t	typeref:struct:__anon15	file:
levelfromCS0	traces.c	/^    int levelfromCS0;$/;"	m	struct:TracesVars	file:
levelinfo	naugroup.h	/^    levelrec levelinfo[1];   \/* extendable section *\/$/;"	m	struct:group_struct
levelrec	naugroup.h	/^} levelrec;$/;"	t	typeref:struct:level_struct
limit	twohamg.c	/^static nauty_counter nodes,limit,totallimit;$/;"	v	file:
line1	naucompare.c	/^static char line1[MAXLINELEN+1];$/;"	v	file:
line1mod	naucompare.c	/^static char line1mod[MAXLINELEN+100];$/;"	v	file:
line2	naucompare.c	/^static char line2[MAXLINELEN+1];$/;"	v	file:
line2mod	naucompare.c	/^static char line2mod[MAXLINELEN+100];$/;"	v	file:
linegraph	linegraphg.c	/^linegraph(sparsegraph *g, sparsegraph *h)$/;"	f	file:
linelength	nauty.c	/^static TLS_ATTR int linelength,tc_level,mininvarlevel,maxinvarlevel,invararg;$/;"	v	file:
linelength	nauty.h	/^    int linelength;           \/* max chars\/line (excl. '\\n') for output *\/$/;"	m	struct:optionstruct
linelength	traces.h	/^	int linelength;$/;"	m	struct:TracesOptions
linelgth	traces.c	/^    int linelgth;$/;"	m	struct:TracesVars	file:
link	planarity.h	/^    int          link[2];$/;"	m	struct:ver_edge
list	dretodot.c	/^typedef struct list {$/;"	s	file:
list	dretodot.c	/^} list;$/;"	t	typeref:struct:list	file:
listcounter	traces.c	/^    int listcounter;$/;"	m	struct:TracesSpine	file:
listend	traces.c	/^    Candidate *listend;$/;"	m	struct:TracesSpine	file:
listhash	naututil.c	/^listhash(int *x, int nx, long key)$/;"	f
liststart	traces.c	/^    Candidate *liststart;$/;"	m	struct:TracesSpine	file:
lo	genbg.c	/^    int lo,hi;           \/* work purposes for orbit calculation *\/$/;"	m	struct:__anon3	file:
lo	geng.c	/^    xword lo,hi;          \/* work purposes for orbit calculation *\/$/;"	m	struct:__anon17	file:
lo	gentourng.c	/^    xword lo,hi;          \/* work purposes for orbit calculation *\/$/;"	m	struct:__anon15	file:
lo	testg.c	/^    long lo,hi;$/;"	m	struct:constraint_st	file:
locallimit	twohamg.c	/^static nauty_counter locallimit[]$/;"	v	file:
longprune	nautil.c	/^longprune(set *tcell, set *fix, set *bottom, set *top, int m)$/;"	f
longvalue	gtools.c	/^longvalue(char **ps, long *l)$/;"	f
longvalue	showg.c	/^longvalue(char **ps, long *l)$/;"	f	file:
lookup	traces.c	/^boolean lookup(searchtrie *t) {$/;"	f
loopcount	gutil2.c	/^loopcount(graph *g, int m, int n)$/;"	f
lowpoint	planarity.h	/^    int          lowpoint;$/;"	m	struct:ver_edge
lswitch	testg.c	/^static boolean lswitch;$/;"	v	file:
m	genquarticg.c	/^static int  nmax, m, code, numcells, mod, res, splitlevel, splitcount;$/;"	v	file:
m	nauty.c	/^static TLS_ATTR int m,n;$/;"	v	file:
m	sumlines.c	/^    mpz_t *m;$/;"	m	union:__anon14	file:
main	NRswitchg.c	/^main(int argc, char *argv[])$/;"	f
main	addedgeg.c	/^main(int argc, char *argv[])$/;"	f
main	amtog.c	/^main(int argc, char *argv[])$/;"	f
main	biplabg.c	/^main(int argc, char *argv[])$/;"	f
main	bliss2dre.c	/^main(int argc, char *argv[])$/;"	f
main	blisstog.c	/^main(int argc, char *argv[])$/;"	f
main	callgeng.c	/^main(int argc, char *argv[])$/;"	f
main	catg.c	/^main(int argc, char *argv[])$/;"	f
main	checks6.c	/^main(int argc, char *argv[])$/;"	f
main	complg.c	/^main(int argc, char *argv[])$/;"	f
main	converseg.c	/^main(int argc, char *argv[])$/;"	f
main	copyg.c	/^main(int argc, char *argv[])$/;"	f
main	cubhamg.c	/^main(int argc, char *argv[])$/;"	f
main	deledgeg.c	/^main(int argc, char *argv[])$/;"	f
main	delptg.c	/^main(int argc, char *argv[])$/;"	f
main	directg.c	/^main(int argc, char *argv[])$/;"	f
main	dreadnaut.c	/^main(int argc, char *argv[])$/;"	f
main	dretodot.c	/^main(int argc, char *argv[])$/;"	f
main	dretog.c	/^main(int argc, char *argv[])$/;"	f
main	genbg.c	/^main(int argc, char *argv[])$/;"	f
main	genquarticg.c	/^int main(int argc, char *argv[])$/;"	f
main	genrang.c	/^main(int argc, char *argv[])$/;"	f
main	genspecialg.c	/^main(int argc, char *argv[])$/;"	f
main	hamheuristic.c	/^main(int argc, char *argv[])$/;"	f
main	labelg.c	/^main(int argc, char *argv[])$/;"	f
main	linegraphg.c	/^main(int argc, char *argv[])$/;"	f
main	listg.c	/^main(int argc, char *argv[])$/;"	f
main	multig.c	/^main(int argc, char *argv[])$/;"	f
main	naucompare.c	/^main(int argc, char *argv[])$/;"	f
main	nautest.c	/^main(int argc, char *argv[])$/;"	f
main	nauthread1.c	/^main(int argc, char *argv[])$/;"	f
main	nauthread2.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex1.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex10.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex2.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex3.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex4.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex5.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex6.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex7.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex8.c	/^main(int argc, char *argv[])$/;"	f
main	nautyex9.c	/^main(int argc, char *argv[])$/;"	f
main	newedgeg.c	/^main(int argc, char *argv[])$/;"	f
main	planarg.c	/^main(int argc, char *argv[])$/;"	f
main	poptest.c	/^main(int argc, char *argv[])$/;"	f
main	ranlabg.c	/^main(int argc, char *argv[])$/;"	f
main	shortg.c	/^main(int argc, char *argv[])$/;"	f
main	showg.c	/^main(int argc, char *argv[])$/;"	f
main	subdivideg.c	/^main(int argc, char *argv[])$/;"	f
main	sumlines.c	/^main(int argc, char *argv[])$/;"	f
main	testg.c	/^main(int argc, char *argv[])$/;"	f
main	twohamg.c	/^main(int argc, char *argv[])$/;"	f
main	vcolg.c	/^main(int argc, char *argv[])$/;"	f
main	watercluster2.c	/^int main(int argc, char *argv[])$/;"	f
make0graph	geng.c	/^make0graph(graph *g, xword *h, int n)$/;"	f	file:
makeJohnson	genspecialg.c	/^makeJohnson(long n, long k, boolean digraph, sparsegraph *sg)$/;"	f	file:
makeb6graph	geng.c	/^makeb6graph(graph *g, xword *h, int n)$/;"	f	file:
makebgraph	geng.c	/^makebgraph(graph *g, xword *h, int n)$/;"	f	file:
makeblue	twohamg.c	/^makeblue(int edge, boolean lastok)$/;"	f	file:
makecanon	genbg.c	/^makecanon(graph *g, graph *gcan, int n1, int n2)$/;"	f	file:
makecanon	geng.c	/^makecanon(graph *g, graph *gcan, int n)$/;"	f	file:
makecanon	gentourng.c	/^makecanon(graph *g, graph *gcan, int n)$/;"	f	file:
makecirculant	genspecialg.c	/^makecirculant(long n, long *conn, int nconn, boolean digraph, sparsegraph *sg)$/;"	f	file:
makecomplete	genspecialg.c	/^makecomplete(long n, boolean digraph, sparsegraph *sg)$/;"	f	file:
makecompletebipartite	genspecialg.c	/^makecompletebipartite(long n1, long n2, boolean digraph, sparsegraph *sg)$/;"	f	file:
makecosetreps	naugroup.c	/^makecosetreps(grouprec *grp)$/;"	f
makecycle	genspecialg.c	/^makecycle(long n, boolean digraph, sparsegraph *sg)$/;"	f	file:
makeempty	genspecialg.c	/^makeempty(long n, boolean digraph, sparsegraph *sg)$/;"	f	file:
makeflowersnark	genspecialg.c	/^makeflowersnark(long k, boolean digraph, sparsegraph *sg)$/;"	f	file:
makeg5graph	geng.c	/^makeg5graph(graph *g, xword *h, int n)$/;"	f	file:
makegenpetersen	genspecialg.c	/^makegenpetersen(long n1, long n2, boolean digraph, sparsegraph *sg)$/;"	f	file:
makegrid	genspecialg.c	/^makegrid(long *dim, int ndim, boolean digraph, sparsegraph *sg)$/;"	f	file:
makehypercube	genspecialg.c	/^makehypercube(long deg, boolean digraph, sparsegraph *sg)$/;"	f	file:
makeleveldata	genbg.c	/^makeleveldata(void)$/;"	f	file:
makeleveldata	geng.c	/^makeleveldata(boolean restricted)$/;"	f	file:
makeleveldata	gentourng.c	/^makeleveldata(void)$/;"	f	file:
makepath	genspecialg.c	/^makepath(long n, boolean digraph, sparsegraph *sg)$/;"	f	file:
makeprism_sg	twohamg.c	/^makeprism_sg(sparsegraph *sg, sparsegraph *sh)$/;"	f	file:
makeranreg	genrang.c	/^makeranreg(int *cub, int degree, int multmax, int loopmax, int n)$/;"	f	file:
makered	twohamg.c	/^makered(int edge, boolean lastok)$/;"	f	file:
makesgraph	geng.c	/^makesgraph(graph *g, xword *h, int n)$/;"	f	file:
maketargetcell	nautil.c	/^maketargetcell(graph *g, int *lab, int *ptn, int level, set *tcell,$/;"	f
maketheta	genspecialg.c	/^maketheta(long *len, int npaths, boolean digraph, sparsegraph *sg)$/;"	f	file:
makexgraph	geng.c	/^makexgraph(graph *g, xword *h, int n)$/;"	f	file:
mark	planarity.h	/^    int          mark;   \/* a spot for marking *\/$/;"	m	struct:embed_sparse_rep
mark	schreier.h	/^    int mark;                            \/* a mark, 0 unless changed *\/$/;"	m	struct:permnodestruct
mark	traces.c	/^    int mark;$/;"	m	struct:TracesVars	file:
mark_components	watercluster2.c	/^void  mark_components(int graaf[][MAXN],int adj[],int aantal_toppen,int number[])$/;"	f
mark_orbitnumbers	watercluster2.c	/^void mark_orbitnumbers(int number[], BOOG list_of_dir_edges[], int listlength)$/;"	f
mark_orbitnumbers_edgelist	watercluster2.c	/^void mark_orbitnumbers_edgelist(int number[], int *specialexists)$/;"	f
mark_orbitnumbers_edgelist_first	watercluster2.c	/^void mark_orbitnumbers_edgelist_first(int number[], int *specialexists, int *completelyfixededge)$/;"	f
mark_orbitnumbers_only_candidates	watercluster2.c	/^void mark_orbitnumbers_only_candidates(int number[], BOOG list_of_edges[], int listlength, int candidate[])$/;"	f
mark_orbitnumbers_only_directed	watercluster2.c	/^void mark_orbitnumbers_only_directed(int number[], BOOG list_of_edges[], int listlength)$/;"	f
markcell1	traces.c	/^    int markcell1;$/;"	m	struct:TracesVars	file:
markcell2	traces.c	/^    int markcell2;$/;"	m	struct:TracesVars	file:
marker	schreier.h	/^    permnode *marker;              \/* points to marker for this level *\/$/;"	m	struct:schreierlevel
matching_lines	sumlines.c	/^static unsigned long matching_lines[MAXFORMATS];$/;"	v	file:
mathon	naututil.c	/^mathon(graph *g1, int m1, int n1, graph *g2, int m2, int n2)$/;"	f
mathon_sg	naututil.c	/^mathon_sg(sparsegraph *g1, sparsegraph *g2)$/;"	f
max	traces.c	/^int max(int u, int v) {$/;"	f
max_doubles	watercluster2.c	/^int max_doubles;$/;"	v
maxchild	gentreeg.c	/^ maxchild,                    \/* max number of children *\/$/;"	v	file:
maxclassstack	cubhamg.c	/^static int maxlevel,maxclassstack;$/;"	v	file:
maxcliques	gutil1.c	/^maxcliques(graph *g, int m, int n)$/;"	f
maxclnode1	gutil1.c	/^maxclnode1(graph *g, setword cliq, setword cov, int maxv)$/;"	f	file:
maxcommon	genbg.c	/^int maxcommon;                  \/* -1 or value of -Z *\/$/;"	v
maxdeg	geng.c	/^static int mindeg,maxdeg,maxn,mine,maxe,mod,res;$/;"	v	file:
maxdeg	gentourng.c	/^static int mindeg,maxdeg,maxn,mod,res;$/;"	v	file:
maxdeg	gentreeg.c	/^static int maxdeg; $/;"	v	file:
maxdeg	traces.c	/^    int maxdeg;$/;"	m	struct:TracesVars	file:
maxdeg1	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
maxdeg2	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
maxdiam	gentreeg.c	/^static int maxdiam;$/;"	v	file:
maxdirectdeg	watercluster2.c	/^int maxindeg=MAXN, maxoutdeg=MAXN, maxdirectdeg=MAXN, nodegbound=1;$/;"	v
maxe	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
maxe	geng.c	/^static int mindeg,maxdeg,maxn,mine,maxe,mod,res;$/;"	v	file:
maxeb	geng.c	/^static int maxeb[] =     \/* max edges for -b *\/$/;"	v	file:
maxebf	geng.c	/^static int maxebf[] =    \/* max edges for -bf *\/$/;"	v	file:
maxef	geng.c	/^static int maxef[] =     \/* max edges for -f *\/$/;"	v	file:
maxeft	geng.c	/^static int maxeft[] =    \/* max edges for -ft *\/$/;"	v	file:
maxet	geng.c	/^static int maxet[] =     \/* max edges for -t *\/$/;"	v	file:
maxindeg	watercluster2.c	/^int maxindeg=MAXN, maxoutdeg=MAXN, maxdirectdeg=MAXN, nodegbound=1;$/;"	v
maxint	sumlines.c	/^static integer maxint;   \/* set by find_maxint() *\/$/;"	v	file:
maxinvarlevel	nauty.c	/^static TLS_ATTR int linelength,tc_level,mininvarlevel,maxinvarlevel,invararg;$/;"	v	file:
maxinvarlevel	nauty.h	/^    int maxinvarlevel;        \/* max level for invariant computation *\/$/;"	m	struct:optionstruct
maxlevel	cubhamg.c	/^static int maxlevel,maxclassstack;$/;"	v	file:
maxlevel	nauty.h	/^    int maxlevel;                \/* maximum depth of search *\/$/;"	m	struct:__anon18
maxn	geng.c	/^static int mindeg,maxdeg,maxn,mine,maxe,mod,res;$/;"	v	file:
maxn	gentourng.c	/^static int mindeg,maxdeg,maxn,mod,res;$/;"	v	file:
maxn2	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
maxnodes	cubhamg.c	/^static long nodecount,maxnodes,totalnodes;$/;"	v	file:
maxoutdeg	watercluster2.c	/^int maxindeg=MAXN, maxoutdeg=MAXN, maxdirectdeg=MAXN, nodegbound=1;$/;"	v
maxspineorblevel	traces.c	/^    int maxspineorblevel;$/;"	m	struct:TracesVars	file:
maxtreelevel	traces.c	/^    int maxtreelevel;$/;"	m	struct:TracesVars	file:
me	directg.c	/^static int me;$/;"	v	file:
mem_free	planarity.h	41;"	d
mem_malloc	planarity.h	39;"	d
mem_realloc	planarity.h	40;"	d
merge_queue	planarity.h	/^typedef struct merge_queue {$/;"	s
mg_nin	multig.c	/^nauty_counter mg_nin,mg_nout,mg_skipped;$/;"	v
mg_nout	multig.c	/^nauty_counter mg_nin,mg_nout,mg_skipped;$/;"	v
mg_skipped	multig.c	/^nauty_counter mg_nin,mg_nout,mg_skipped;$/;"	v
min	traces.c	/^int min(int u, int v) {$/;"	f
min_splitlevel	geng.c	/^static int min_splitlevel,odometer,splitlevel,multiplicity;$/;"	v	file:
min_splitlevel	gentourng.c	/^static int min_splitlevel,odometer,splitlevel,multiplicity;$/;"	v	file:
mindeg	geng.c	/^static int mindeg,maxdeg,maxn,mine,maxe,mod,res;$/;"	v	file:
mindeg	gentourng.c	/^static int mindeg,maxdeg,maxn,mod,res;$/;"	v	file:
mindeg	traces.c	/^    int mindeg;$/;"	m	struct:TracesVars	file:
mindeg1	genbg.c	/^static int mindeg1,mindeg2;$/;"	v	file:
mindeg2	genbg.c	/^static int mindeg1,mindeg2;$/;"	v	file:
mindiam	gentreeg.c	/^static int mindiam; $/;"	v	file:
mine	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
mine	geng.c	/^static int mindeg,maxdeg,maxn,mine,maxe,mod,res;$/;"	v	file:
mingerichtdeg	watercluster2.c	/^int mingerichtdeg;$/;"	v
minimalinorbits	traces.c	/^    boolean minimalinorbits;$/;"	m	struct:TracesInfo	file:
mininvarlevel	nauty.c	/^static TLS_ATTR int linelength,tc_level,mininvarlevel,maxinvarlevel,invararg;$/;"	v	file:
mininvarlevel	nauty.h	/^    int mininvarlevel;        \/* min level for invariant computation *\/$/;"	m	struct:optionstruct
minor	planarity.h	/^} minor;$/;"	t	typeref:enum:__anon2
mod	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
mod	geng.c	/^static int mindeg,maxdeg,maxn,mine,maxe,mod,res;$/;"	v	file:
mod	genquarticg.c	/^static int  nmax, m, code, numcells, mod, res, splitlevel, splitcount;$/;"	v	file:
mod	gentourng.c	/^static int mindeg,maxdeg,maxn,mod,res;$/;"	v	file:
mod	gentreeg.c	/^static int splitlevel,splitcount,mod,res;   \/* -s res\/mod *\/$/;"	v	file:
mod_diff	naurng.c	51;"	d	file:
mod_diff	rng.c	46;"	d	file:
mode	dreadnaut.c	/^static int mode;$/;"	v	file:
mp_value	sumlines.c	/^static mpz_t mp_value[MAXVALUES];$/;"	v	file:
msgfile	genquarticg.c	/^static FILE *outfile, *msgfile;             \/* file for output graphs *\/$/;"	v	file:
mult	planarity.h	/^    int            mult;         \/* if relevant, #occurences if this edge$/;"	m	struct:dlcl
mult	planarity.h	/^    int          mult;$/;"	m	struct:ver_edge
multcount	schreier.c	/^TLS_ATTR long long multcount = 0;$/;"	v
multi	multig.c	/^multi(graph *g, int nfixed, long minedges, long maxedges, long maxmult,$/;"	f	file:
multiplicity	geng.c	/^static int min_splitlevel,odometer,splitlevel,multiplicity;$/;"	v	file:
multiplicity	gentourng.c	/^static int min_splitlevel,odometer,splitlevel,multiplicity;$/;"	v	file:
multp	genquarticg.c	/^    int multp;$/;"	m	struct:__anon7	file:
n	naugroup.h	/^    int n;                   \/* number of points *\/$/;"	m	struct:group_struct
n	nauthread1.c	/^    int n;$/;"	m	struct:__anon4	file:
n	nauthread2.c	/^    int n;$/;"	m	struct:__anon11	file:
n	nauty.c	/^static TLS_ATTR int m,n;$/;"	v	file:
n	planarity.h	/^	int                 n;$/;"	m	struct:graph_sparse_rep
n1	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
na_newedge	newedgeg.c	/^na_newedge(graph *g1, int m1, int n1, boolean dolabel)$/;"	f	file:
nalloc	schreier.h	/^    int nalloc;                          \/* size of p[] in ints,$/;"	m	struct:permnodestruct
nalloc	schreier.h	/^    int nalloc;                    \/* size of vec[] and orbits[] *\/$/;"	m	struct:schreierlevel
name	dreadnaut.c	/^    char *name;$/;"	m	struct:invarrec	file:
name	labelg.c	/^    char *name;$/;"	m	struct:invarrec	file:
name	shortg.c	/^    char *name;$/;"	m	struct:invarrec	file:
name	traces.c	/^    int name;$/;"	m	struct:Candidate	file:
name	traces.c	/^    int name;$/;"	m	struct:TracesVars	file:
name	traces.c	/^    int name;$/;"	m	struct:searchtrie	file:
name_sg	dreadnaut.c	/^    char *name_sg;$/;"	m	struct:invarrec	file:
naugraph_check	naugraph.c	/^naugraph_check(int wordsize, int m, int n, int version)$/;"	f
naugraph_freedyn	naugraph.c	/^naugraph_freedyn(void)$/;"	f
nausparse_check	nausparse.c	/^nausparse_check(int wordsize, int m, int n, int version)$/;"	f
nausparse_freedyn	nausparse.c	/^nausparse_freedyn(void)$/;"	f
nautaux_check	nautaux.c	/^nautaux_check(int wordsize, int m, int n, int version)$/;"	f
nautaux_freedyn	nautaux.c	/^nautaux_freedyn(void)$/;"	f
nautil_check	nautil.c	/^nautil_check(int wordsize, int m, int n, int version)$/;"	f
nautil_freedyn	nautil.c	/^nautil_freedyn(void)$/;"	f
nautinv_check	nautinv.c	/^nautinv_check(int wordsize, int m, int n, int version)$/;"	f
nautinv_freedyn	nautinv.c	/^nautinv_freedyn(void)$/;"	f
naututil_check	naututil.c	/^naututil_check(int wordsize, int m, int n, int version)$/;"	f
naututil_freedyn	naututil.c	/^naututil_freedyn(void)$/;"	f
nauty	nauty.c	/^nauty(graph *g_arg, int *lab, int *ptn, set *active_arg,$/;"	f
nauty_check	nauty.c	/^nauty_check(int wordsize, int m, int n, int version)$/;"	f
nauty_counter	nauty.h	/^typedef unsigned long long nauty_counter;$/;"	t
nauty_counter	nauty.h	/^typedef unsigned long nauty_counter;$/;"	t
nauty_freedyn	nauty.c	/^nauty_freedyn(void)$/;"	f
nauty_graph	nauty.h	/^typedef graph nauty_graph;$/;"	t
nauty_kill_request	nautil.c	/^volatile int nauty_kill_request = 0;   \/* no TLS_ATTR on purpose *\/$/;"	v
nauty_set	nauty.h	/^typedef set nauty_set;$/;"	t
nauty_stats	geng.c	/^statsblk nauty_stats;$/;"	v
nauty_stats	gentourng.c	/^statsblk nauty_stats;$/;"	v
nauty_to_sg	nausparse.c	/^nauty_to_sg(graph *g, sparsegraph *sg, int m, int n)$/;"	f
nautyformat	genbg.c	/^boolean nautyformat;            \/* presence of -n *\/$/;"	v
nautyformat	geng.c	/^boolean nautyformat;            \/* presence of -n *\/$/;"	v
nbr_e	planarity.h	/^	int                 nbr_e;   \/* ALWAYS # directed edges *\/$/;"	m	struct:graph_sparse_rep
nbr_v	planarity.h	/^    int          nbr_v;   \/* nbr of vertices *\/$/;"	m	struct:comp_sparse_rep
nde	nausparse.h	/^    size_t nde;  \/* Number of directed edges (loops contribute only 1) *\/$/;"	m	struct:__anon10
ne	genbg.c	/^    int ne,dmax;         \/* values used for xlb,xub calculation *\/$/;"	m	struct:__anon3	file:
ne	geng.c	/^    int ne,dmax;          \/* values used for xlb,xub calculation *\/$/;"	m	struct:__anon17	file:
needed	testg.c	/^    int needed;     \/* 1 = sortkey, 2 = constraint; 3 = both *\/$/;"	m	struct:constraint_st	file:
needshortprune	nauty.c	/^static TLS_ATTR boolean needshortprune;  \/* used to flag calls to shortprune *\/$/;"	v	file:
neighbour	planarity.h	/^    int          neighbour;$/;"	m	struct:ver_edge
newedge	newedgeg.c	/^newedge(graph *g1, int m1, int n1,$/;"	f	file:
newgotonode	traces.c	/^    struct searchtrie *newgotonode;$/;"	m	struct:TracesVars	typeref:struct:TracesVars::searchtrie	file:
newgroup	schreier.c	/^newgroup(schreier **sh, permnode **ring, int n)$/;"	f
newgroupsize	directg.c	/^static unsigned long newgroupsize;$/;"	v	file:
newgroupsize	multig.c	/^static unsigned long newgroupsize;$/;"	v	file:
newgroupsize	vcolg.c	/^static unsigned long newgroupsize;$/;"	v	file:
newindex	traces.c	/^    int newindex;$/;"	m	struct:TracesVars	file:
newpermnode	schreier.c	/^*newpermnode(int n)$/;"	f	file:
newpermrec	naugroup.c	/^*newpermrec(int n)$/;"	f
newschreier	schreier.c	/^*newschreier(int n)$/;"	f	file:
newst_stage1	traces.c	/^    struct searchtrie *newst_stage1;$/;"	m	struct:TracesVars	typeref:struct:TracesVars::searchtrie	file:
next	dretodot.c	/^    struct list *next;$/;"	m	struct:list	typeref:struct:list::list	file:
next	naututil.c	/^typedef struct echunk {struct echunk *next; int edge[ECHUNKSIZE];} echunk;$/;"	m	struct:echunk	typeref:struct:echunk::echunk	file:
next	naututil.c	/^typedef struct echunkw {struct echunkw *next; \\$/;"	m	struct:echunkw	typeref:struct:echunkw::echunkw	file:
next	nauty.c	/^    struct tcnode_struct *next;$/;"	m	struct:tcnode_struct	typeref:struct:tcnode_struct::tcnode_struct	file:
next	planarity.h	/^    int          next;   \/* next edge in embedding  *\/$/;"	m	struct:embed_sparse_rep
next	planarity.h	/^    int          next;   \/* next in list as an index in the adj. list *\/$/;"	m	struct:adjl_sparse_rep
next	schreier.h	/^    struct permnodestruct *prev,*next;   \/* prev&next in circular list *\/$/;"	m	struct:permnodestruct	typeref:struct:permnodestruct::
next	schreier.h	/^    struct schreierlevel *next;    \/* down one level, if any *\/$/;"	m	struct:schreierlevel	typeref:struct:schreierlevel::schreierlevel
next	traces.c	/^    struct Candidate *next;$/;"	m	struct:Candidate	typeref:struct:Candidate::Candidate	file:
next	traces.c	/^    struct trielist *next;$/;"	m	struct:trielist	typeref:struct:trielist::trielist	file:
next_sibling	traces.c	/^    struct searchtrie *next_sibling;$/;"	m	struct:searchtrie	typeref:struct:searchtrie::searchtrie	file:
next_sibling	traces.c	/^    struct trie *next_sibling;$/;"	m	struct:trie	typeref:struct:trie::trie	file:
nextchar	bliss2dre.c	/^nextchar(void)$/;"	f	file:
nextchar	blisstog.c	/^nextchar(FILE *f)$/;"	f	file:
nextelement	nautil.c	/^nextelement(set *set1, int m, int pos)$/;"	f
nextelement	showg.c	/^nextelement(set *set1, int m, int pos)$/;"	f	file:
nextlevel	traces.c	/^    int nextlevel;$/;"	m	struct:TracesVars	file:
nextp	gentreeg.c	/^ nextp[MAXN+1],               \/* next good pos to add nodes *\/$/;"	v	file:
nextstep_depth	watercluster2.c	/^int nextstep_depth; $/;"	v
nfix	traces.c	/^    int nfix;$/;"	m	struct:TracesVars	file:
nin	listg.c	/^static unsigned long nin;$/;"	v	file:
nin	showg.c	/^static long nin;$/;"	v	file:
nix	directg.c	/^static int ix[2*MAXNE],nix;$/;"	v	file:
nix	multig.c	/^static int ix[MAXNE+MAXNV],nix;$/;"	v	file:
nmax	genquarticg.c	/^static int  nmax, m, code, numcells, mod, res, splitlevel, splitcount;$/;"	v	file:
no3path	addedgeg.c	/^no3path(graph *g, int m, int n, int v, int *dist)$/;"	f	file:
no4path	addedgeg.c	/^no4path(graph *g, int m, int n, int v, int *dist)$/;"	f	file:
node_st	testg.c	/^typedef struct node_st     \/* variant for count tree *\/$/;"	s	file:
nodecount	cubhamg.c	/^static long nodecount,maxnodes,totalnodes;$/;"	v	file:
nodedata	cubhamg.c	/^} nodedata;$/;"	t	typeref:struct:__anon16	file:
nodegbound	watercluster2.c	/^int maxindeg=MAXN, maxoutdeg=MAXN, maxdirectdeg=MAXN, nodegbound=1;$/;"	v
nodes	genbg.c	/^static long nodes[MAXN],rigidnodes[MAXN],fertilenodes[MAXN];$/;"	v	file:
nodes	geng.c	/^static nauty_counter nodes[MAXN];     \/* nodes at each level *\/$/;"	v	file:
nodes	gentourng.c	/^static nauty_counter nodes[MAXN];     \/* nodes at each level *\/$/;"	v	file:
nodes	twohamg.c	/^static nauty_counter nodes,limit,totallimit;$/;"	v	file:
noncheaplevel	nauty.c	/^    noncheaplevel, \/* level of greatest ancestor for which cheapautom==FALSE *\/$/;"	v	file:
nontrivlabels	watercluster2.c	/^void nontrivlabels(BOOG kleinste_orbit[], int done_in_orbit, int orbitsize, BOOG al_gericht[],$/;"	f
nooutput	genbg.c	/^boolean nooutput;               \/* presence of -u *\/$/;"	v
nooutput	geng.c	/^boolean nooutput;               \/* presence of -u *\/$/;"	v
nooutput	genquarticg.c	/^boolean     nooutput;                       \/* presence of -u *\/$/;"	v
nooutput	gentourng.c	/^boolean nooutput;               \/* presence of -u *\/$/;"	v
nout	delptg.c	/^static nauty_counter nout;$/;"	v	file:
nout	gentourng.c	/^static nauty_counter nout;$/;"	v	file:
nout	gentreeg.c	/^static nauty_counter nout;                 \/* number of trees *\/$/;"	v	file:
nout	newedgeg.c	/^static nauty_counter nout;$/;"	v	file:
np2vector	nauty.h	/^typedef int nvector,np2vector; $/;"	t
nphases	twohamg.c	/^static nauty_counter nphases[100];  \/* Must be greater than NUMLIMITS *\/$/;"	v	file:
nprune	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
ntgroup	directg.c	/^static boolean Gswitch,Vswitch,ntgroup,ntisol,digraph6;$/;"	v	file:
ntimeouts	twohamg.c	/^static nauty_counter ntimeouts;$/;"	v	file:
ntisol	directg.c	/^static boolean Gswitch,Vswitch,ntgroup,ntisol,digraph6;$/;"	v	file:
ntod6	gtools.c	/^ntod6(graph *g, int m, int n)$/;"	f
ntog6	gtools.c	/^ntog6(graph *g, int m, int n)$/;"	f
ntois6	gtools.c	/^ntois6(graph *g, graph *prevg, int m, int n)$/;"	f
ntos6	gtools.c	/^ntos6(graph *g, int m, int n)$/;"	f
nullwrite	genbg.c	/^nullwrite(FILE *f, graph *g, int n1, int n2)$/;"	f	file:
nullwrite	geng.c	/^nullwrite(FILE *f, graph *g, int n)$/;"	f	file:
nullwrite	genquarticg.c	/^nullwrite(FILE *f, graph *g, int n)$/;"	f	file:
nullwrite	gentourng.c	/^nullwrite(FILE *f, graph *g, int n)$/;"	f	file:
numbadleaves	nauty.h	/^    unsigned long numbadleaves;  \/* number of leaves of no use *\/$/;"	m	struct:__anon18
number	sumlines.c	/^} number;$/;"	t	typeref:union:__anon14	file:
number_of_generators	watercluster2.c	/^int number_of_generators;$/;"	v
number_operations	watercluster2.c	/^int *root_op=NULL, size_root=0, blocklength, orbitblocklength[MAXN], size_operations=0, number_operations=0;$/;"	v
number_parops	watercluster2.c	/^int number_parops; $/;"	v
numcells	genquarticg.c	/^static int  nmax, m, code, numcells, mod, res, splitlevel, splitcount;$/;"	v	file:
numdirtriangles	gutil2.c	/^numdirtriangles(graph *g, int m, int n)$/;"	f
numgenerators	nauty.h	/^    int numgenerators;      \/* number of generators found *\/$/;"	m	struct:__anon18
numgenerators	traces.h	/^	int numgenerators;$/;"	m	struct:TracesStats
numkeys	testg.c	/^static int numkeys;$/;"	v	file:
numnodes	nauty.h	/^    unsigned long numnodes;      \/* total number of nodes *\/$/;"	m	struct:__anon18
numnodes	traces.h	/^	unsigned long numnodes;$/;"	m	struct:TracesStats
numorbits	naugroup.h	/^    int numorbits;           \/* number of orbits *\/$/;"	m	struct:group_struct
numorbits	nauty.h	/^    int numorbits;          \/* number of orbits in group *\/$/;"	m	struct:__anon18
numorbits	traces.h	/^	int numorbits;$/;"	m	struct:TracesStats
numread	genquarticg.c	/^long        numread;$/;"	v
numstrcmp	sumlines.c	/^numstrcmp(char *s1, char *s2)$/;"	f	file:
numtriangles	gutil2.c	/^numtriangles(graph *g, int m, int n)$/;"	f
numtriangles1	gutil2.c	/^numtriangles1(graph *g, int n)$/;"	f
numtries	cubhamg.c	/^static nauty_counter numtries[NUMMAXNODES+1];$/;"	v	file:
numwritten	genquarticg.c	/^nauty_counter numwritten;$/;"	v
nv	gentreeg.c	/^static int nv;  \/* number of vertices *\/$/;"	v	file:
nv	nausparse.h	/^    int nv;      \/* Number of vertices *\/$/;"	m	struct:__anon10
nvals	sumlines.c	/^    int nvals;$/;"	m	struct:__anon13	file:
nvector	nauty.h	/^typedef int nvector,np2vector; $/;"	t
odometer	geng.c	/^static int min_splitlevel,odometer,splitlevel,multiplicity;$/;"	v	file:
odometer	gentourng.c	/^static int min_splitlevel,odometer,splitlevel,multiplicity;$/;"	v	file:
ogf_linelen	gtools.c	/^TLS_ATTR size_t ogf_linelen;$/;"	v
ogf_linelen	showg.c	/^static long ogf_linelen;$/;"	v	file:
ok	twohamg.c	/^    boolean ok;$/;"	m	struct:p4	file:
oldlo	multig.c	/^static nauty_counter oldlo;$/;"	v	file:
one	traces.c	/^    boolean one;$/;"	m	struct:grph_strct	file:
onlevel	watercluster2.c	/^long long int onlevel[MAX_BOGEN]={0};$/;"	v
onstack	cubhamg.c	/^static vertvec onstack,stack;       \/* stack contains vertex numbers *\/$/;"	v	file:
openfile_head	catg.c	/^openfile_head(char *filename, char **header)$/;"	f	file:
opengraphfile	gtools.c	/^opengraphfile(char *filename, int *codetype, int assumefixed, long position)$/;"	f
opengraphfile	showg.c	/^opengraphfile(char *filename, int *codetype, int assumefixed, long position)$/;"	f	file:
operations	watercluster2.c	/^unsigned char *operations=NULL;$/;"	v
optadd	cubhamg.c	/^optadd(cubgraph cub, int v1, int v2)$/;"	f	file:
optionblk	nauty.h	/^} optionblk;$/;"	t	typeref:struct:optionstruct
options	traces.c	/^    TracesOptions *options;$/;"	m	struct:TracesVars	file:
options_cartesian	dreadnaut.c	/^	    options_invararg,options_tc_level,options_cartesian;$/;"	v	file:
options_digraph	dreadnaut.c	/^            options_digraph,options_getcanon,options_linelength;$/;"	v	file:
options_getcanon	dreadnaut.c	/^            options_digraph,options_getcanon,options_linelength;$/;"	v	file:
options_invararg	dreadnaut.c	/^	    options_invararg,options_tc_level,options_cartesian;$/;"	v	file:
options_invarproc	dreadnaut.c	/^static int options_invarproc,options_mininvarlevel,options_maxinvarlevel,$/;"	v	file:
options_keepgroup	dreadnaut.c	/^static int options_schreier,options_keepgroup,options_verbosity,$/;"	v	file:
options_linelength	dreadnaut.c	/^            options_digraph,options_getcanon,options_linelength;$/;"	v	file:
options_maxinvarlevel	dreadnaut.c	/^static int options_invarproc,options_mininvarlevel,options_maxinvarlevel,$/;"	v	file:
options_mininvarlevel	dreadnaut.c	/^static int options_invarproc,options_mininvarlevel,options_maxinvarlevel,$/;"	v	file:
options_schreier	dreadnaut.c	/^static int options_schreier,options_keepgroup,options_verbosity,$/;"	v	file:
options_strategy	dreadnaut.c	/^	   options_strategy;$/;"	v	file:
options_tc_level	dreadnaut.c	/^	    options_invararg,options_tc_level,options_cartesian;$/;"	v	file:
options_verbosity	dreadnaut.c	/^static int options_schreier,options_keepgroup,options_verbosity,$/;"	v	file:
options_writeautoms	dreadnaut.c	/^static boolean options_writeautoms,options_writemarkers,$/;"	v	file:
options_writemarkers	dreadnaut.c	/^static boolean options_writeautoms,options_writemarkers,$/;"	v	file:
optionstruct	nauty.h	/^typedef struct optionstruct$/;"	s
orbitblocklength	watercluster2.c	/^int *root_op=NULL, size_root=0, blocklength, orbitblocklength[MAXN], size_operations=0, number_operations=0;$/;"	v
orbitchoices	watercluster2.c	/^int orbitchoices[MAXN]={0};$/;"	v
orbits	dreadnaut.c	/^static int orbits[MAXN];$/;"	v	file:
orbits	dretodot.c	/^int orbits[MAXN];$/;"	v
orbits	nauty.c	/^static TLS_ATTR int *orbits;$/;"	v	file:
orbits	schreier.h	/^    int *orbits;                   \/* vector of orbits *\/$/;"	m	struct:schreierlevel
orbits	traces.c	/^    int *orbits;$/;"	m	struct:TracesVars	file:
orbits	watercluster2.c	/^nvector lab[MAX_BOGEN][MAXN]={{0}}, ptn[MAX_BOGEN][MAXN]={{0}}, orbits[MAX_BOGEN], colour[MAX_BOGEN][MAXN]={{0}};$/;"	v
orbitset_h	nauty.h	/^    int orbitset_h;           \/* Magma - no longer global sjc 1994 *\/$/;"	m	struct:optionstruct
orbitsize	naugroup.h	/^    int orbitsize;     \/* the size of the orbit containing fixedpt *\/$/;"	m	struct:level_struct
orbjoin	nautil.c	/^orbjoin(int *orbits, int *map, int n)$/;"	f
orbjoin_sp_pair	traces.c	/^void orbjoin_sp_pair(int *orbits, int *list, int n, int u, int v, int *numorbs) {$/;"	f
orbjoin_sp_perm	traces.c	/^void orbjoin_sp_perm(int *orbits, int *map, int *list, int n, int *numorbs) {$/;"	f
orbtotal	labelg.c	/^static nauty_counter orbtotal;$/;"	v	file:
othernode0	nauty.c	/^othernode0(int *lab, int *ptn, int level, int numcells,$/;"	f	file:
outcode	delptg.c	/^static int outcode;$/;"	v	file:
outcode	newedgeg.c	/^static int outcode;$/;"	v	file:
outdeg	directg.c	/^static int lastlev[MAXNV],indeg[MAXNV],outdeg[MAXNV];$/;"	v	file:
outdeg	watercluster2.c	/^int deg[MAXN]={0}, outdeg[MAXN]={0}, indeg[MAXN]={0};$/;"	v
outdeg_free	watercluster2.c	/^int indeg_free[MAXN]={0}, outdeg_free[MAXN]={0}, saturated[MAXN]={0};$/;"	v
outfile	delptg.c	/^static FILE *outfile;$/;"	v	file:
outfile	directg.c	/^FILE *outfile;$/;"	v
outfile	dreadnaut.c	/^static FILE *outfile;$/;"	v	file:
outfile	genbg.c	/^static FILE *outfile;           \/* file for output graphs *\/$/;"	v	file:
outfile	geng.c	/^static FILE *outfile;           \/* file for output graphs *\/$/;"	v	file:
outfile	genquarticg.c	/^static FILE *outfile, *msgfile;             \/* file for output graphs *\/$/;"	v	file:
outfile	gentourng.c	/^static FILE *outfile;           \/* file for output graphs *\/$/;"	v	file:
outfile	gentreeg.c	/^static FILE *outfile;$/;"	v	file:
outfile	listg.c	/^static FILE *infile,*outfile;$/;"	v	file:
outfile	multig.c	/^FILE *outfile;$/;"	v
outfile	nauty.c	/^static TLS_ATTR FILE *outfile;$/;"	v	file:
outfile	nauty.h	/^    FILE *outfile;            \/* file for output, if any *\/$/;"	m	struct:optionstruct
outfile	newedgeg.c	/^static FILE *outfile;$/;"	v	file:
outfile	showg.c	/^static FILE *infile,*outfile;$/;"	v	file:
outfile	traces.c	/^static TLS_ATTR FILE *outfile;$/;"	v	file:
outfile	traces.h	/^	FILE* outfile;$/;"	m	struct:TracesOptions
outfile	vcolg.c	/^FILE *outfile;$/;"	v
outfilename	genquarticg.c	/^static char *outfilename;$/;"	v	file:
outofspace	nauty.h	840;"	d
outproc	genbg.c	/^static void (*outproc)(FILE*,graph*,int,int);$/;"	v	file:
outproc	geng.c	/^static void (*outproc)(FILE*,graph*,int);$/;"	v	file:
outproc	genquarticg.c	/^static void (*outproc)(FILE*, graph*, int);$/;"	v	file:
outproc	gentourng.c	/^static void (*outproc)(FILE*,graph*,int);$/;"	v	file:
outproc	gentreeg.c	/^void (*outproc)(FILE *f, int vpar[], int n);$/;"	v
outstring	gentreeg.c	/^static char outstring[MAXOUTLEN];$/;"	v	file:
p	naugroup.h	/^    int p[2];          \/* extendable section *\/$/;"	m	struct:perm_struct
p	schreier.h	/^    int p[2];                            \/* actual vector, extended to$/;"	m	struct:permnodestruct
p4	twohamg.c	/^typedef struct p4$/;"	s	file:
p4	twohamg.c	/^} p4;$/;"	t	typeref:struct:p4	file:
p4decomposition	twohamg.c	/^p4decomposition(sparsegraph sg, int vertex, boolean vertical)$/;"	f	file:
pCNT	genquarticg.c	/^int         *pCNT, *pnumpair, *pdoviorbit, *pepairorbit;$/;"	v
pair	traces.c	/^typedef struct pair {$/;"	s	file:
pair	traces.c	/^} pair;$/;"	t	typeref:struct:pair	file:
pairstruct	genquarticg.c	/^} pairstruct;$/;"	t	typeref:struct:__anon7	file:
pantidovi	genquarticg.c	/^int         (*pantidovi)[MAXN], (*pantipair)[MAXE], (*pantiedge)[MAXN];$/;"	v
pantiedge	genquarticg.c	/^int         (*pantidovi)[MAXN], (*pantipair)[MAXE], (*pantiedge)[MAXN];$/;"	v
pantipair	genquarticg.c	/^int         (*pantidovi)[MAXN], (*pantipair)[MAXE], (*pantiedge)[MAXN];$/;"	v
par	gentreeg.c	/^ par[MAXN+1],                 \/* parent position of i  *\/$/;"	v	file:
par_image	watercluster2.c	/^unsigned int par_image(unsigned int orig, permutation aut[], BOOG orbit[], int orbitsize, int inv[][MAXN])$/;"	f
parallel_orbit_labelling	watercluster2.c	/^void parallel_orbit_labelling(BOOG edge_orbit[], int orbitsize)$/;"	f
params	nauthread1.c	/^} params;   \/* Used to pass parameters to the thread *\/$/;"	t	typeref:struct:__anon4	file:
params	nauthread2.c	/^} params;   \/* Used to pass parameters to the thread *\/$/;"	t	typeref:struct:__anon11	file:
parent	sumlines.c	/^    struct countrec *left,*right,*parent;$/;"	m	struct:countrec	typeref:struct:countrec::	file:
parent	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:grpsize_st	typeref:struct:grpsize_st::	file:
parent	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:node_st	typeref:struct:node_st::	file:
parent	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:splay_st	typeref:struct:splay_st::	file:
parent	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:value_st	typeref:struct:value_st::	file:
parops	watercluster2.c	/^unsigned int parops[MAXPAROPS];$/;"	v
part	traces.c	/^    Partition *part;$/;"	m	struct:TracesSpine	file:
pathcount1	gutil2.c	/^pathcount1(graph *g, int start, setword body, setword last)$/;"	f
pathsingcode	traces.c	/^    unsigned int pathsingcode;$/;"	m	struct:Candidate	file:
pdovi	genquarticg.c	/^dovistruct  *pdovi;$/;"	v
pdoviorbit	genquarticg.c	/^int         *pCNT, *pnumpair, *pdoviorbit, *pepairorbit;$/;"	v
peaknodes	traces.h	/^	unsigned long peaknodes;$/;"	m	struct:TracesStats
pedge	genquarticg.c	/^edgestruct  *pedge;$/;"	v
pepair	genquarticg.c	/^pairstruct  *pepair;$/;"	v
pepairorbit	genquarticg.c	/^int         *pCNT, *pnumpair, *pdoviorbit, *pepairorbit;$/;"	v
perm	dreadnaut.c	/^static int perm[MAXN];$/;"	v	file:
perm	genquarticg.c	/^static int perm[MAXN];$/;"	v	file:
permInd	traces.c	/^    int permInd;$/;"	m	struct:TracesVars	file:
perm_struct	naugroup.h	/^typedef struct perm_struct$/;"	s
permcycles	naugroup.c	/^permcycles(int *p, int n, int *len, boolean sort)$/;"	f
perminvar	genrang.c	/^perminvar(graph *g, int *perm, int m, int n)$/;"	f	file:
permnode	schreier.h	/^} permnode;$/;"	t	typeref:struct:permnodestruct
permnode_freelist	schreier.c	/^static TLS_ATTR permnode *permnode_freelist = NULL;$/;"	v	file:
permnodestruct	schreier.h	/^typedef struct permnodestruct$/;"	s
permrec	naugroup.h	/^} permrec;$/;"	t	typeref:struct:perm_struct
permset	nautil.c	/^permset(set *set1, set *set2, int m, int *perm)$/;"	f
permutation	nauty.h	/^typedef shortish permutation;$/;"	t
pertinent_bicomp_list	planarity.h	/^    t_dlcl       * pertinent_bicomp_list;$/;"	m	struct:ver_edge
pid_t	shortg.c	/^typedef int pid_t;$/;"	t	file:
pmod	sumlines.c	/^   integer pmod;$/;"	m	struct:fmt_st	file:
pnumpair	genquarticg.c	/^int         *pCNT, *pnumpair, *pdoviorbit, *pepairorbit;$/;"	v
pnumstrcmp	sumlines.c	/^pnumstrcmp(const void *a, const void *b)$/;"	f	file:
pos_A	planarity.h	/^	int                 pos_A;$/;"	m	struct:graph_sparse_rep
positie	watercluster2.c	/^int positie[MAXN][MAXN]; \/* the value of positie[i][j] is the position of edge {1,j} in edgelist in case of$/;"	v
possibleblankline	testg.c	/^possibleblankline(FILE *f, long *val)$/;"	f	file:
prepare_next_step	watercluster2.c	/^void prepare_next_step(int group_uptodate, int orbitid, int iterationdepth, graph touched)$/;"	f
preparemarks	genspecialg.c	/^preparemarks(size_t nn)$/;"	f	file:
preparemarks1	nausparse.c	/^preparemarks1(size_t nn)$/;"	f	file:
preparemarks2	nausparse.c	/^preparemarks2(size_t nn)$/;"	f	file:
preprocessed	traces.c	/^    int preprocessed;$/;"	m	struct:TracesVars	file:
prereq	testg.c	/^    unsigned long prereq;    \/* Must be earlier, must be <= bits in long *\/$/;"	m	struct:constraint_st	file:
prev	planarity.h	/^    int          prev;   \/* previous edge in embedding  *\/$/;"	m	struct:embed_sparse_rep
prev	schreier.h	/^    struct permnodestruct *prev,*next;   \/* prev&next in circular list *\/$/;"	m	struct:permnodestruct	typeref:struct:permnodestruct::permnodestruct
prev	traces.c	/^    struct trielist *prev;$/;"	m	struct:trielist	typeref:struct:trielist::trielist	file:
print_common	sumlines.c	/^print_common(countnode *root)$/;"	f	file:
print_counts	sumlines.c	/^print_counts(countnode *root, boolean printcounts)$/;"	f	file:
print_stats	nauty.h	/^    boolean print_stats;      \/* CAYLEY specfic - GYM Sep 1990 *\/$/;"	m	struct:optionstruct
printam	multig.c	/^printam(FILE *f, int n, int ne, int *ix)$/;"	f	file:
printkeyvals	testg.c	/^printkeyvals(FILE *f, long *val)$/;"	f	file:
printthesevals	testg.c	/^printthesevals(FILE *f)$/;"	f	file:
processnode	nauty.c	/^processnode(int *lab, int *ptn, int level, int numcells)$/;"	f	file:
propagate	cubhamg.c	/^propagate(cubgraph g, cubgraph eno, nodedata *ndptr, int *nin, int nv)$/;"	f	file:
propagate	twohamg.c	/^propagate(int n, int *e, int *nblue, int *nred)$/;"	f	file:
prototypes	configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
pruneset	schreier.c	/^pruneset(set *fixset, schreier *gp, permnode **ring, set *x, int m, int n)$/;"	f
pt0	nautinv.c	/^static TLS_ATTR set pt0[MAXM],pt1[MAXM],pt2[MAXM];$/;"	v	file:
pt1	nautinv.c	/^static TLS_ATTR set pt0[MAXM],pt1[MAXM],pt2[MAXM];$/;"	v	file:
pt2	nautinv.c	/^static TLS_ATTR set pt0[MAXM],pt1[MAXM],pt2[MAXM];$/;"	v	file:
ptn	dreadnaut.c	/^static int ptn[MAXN];$/;"	v	file:
ptn	dretodot.c	/^int ptn[MAXN];$/;"	v
ptn	watercluster2.c	/^nvector lab[MAX_BOGEN][MAXN]={{0}}, ptn[MAX_BOGEN][MAXN]={{0}}, orbits[MAX_BOGEN], colour[MAX_BOGEN][MAXN]={{0}};$/;"	v
ptn_h	nauty.h	/^    int ptn_h;                \/* Magma - no longer global sjc 1994 *\/$/;"	m	struct:optionstruct
ptncode	nautaux.c	/^ptncode(graph *g, int *lab, int *ptn, int level, int m, int n)$/;"	f
ptr	naugroup.h	/^    struct perm_struct *ptr;   \/* general-purpose pointer *\/$/;"	m	struct:perm_struct	typeref:struct:perm_struct::perm_struct
putGRAPE	listg.c	/^putGRAPE(FILE *f, graph *g, int m, int n)$/;"	f	file:
putHCP	listg.c	/^putHCP(FILE *f, graph *g, int m, int n)$/;"	f	file:
putMagma	listg.c	/^putMagma(FILE *outfile, graph *g, int linelength, boolean digraph,$/;"	f	file:
putMaple	listg.c	/^putMaple(FILE *outfile, graph *g, int linelength, int m, int n, long index)$/;"	f	file:
put_sg	nausparse.c	/^put_sg(FILE *f, sparsegraph *sg, boolean digraph, int linelength)$/;"	f
putam	listg.c	/^putam(FILE *f, graph *g, int linelength, boolean space,$/;"	f	file:
putam	showg.c	/^putam(FILE *f, graph *g, int linelength, boolean space, boolean triang,$/;"	f	file:
putbliss	listg.c	/^putbliss(FILE *f, unsigned long id, graph *g, int m, int n)$/;"	f	file:
putcanon	naututil.c	/^putcanon(FILE *f, int *canonlab, graph *canong, int linelength, int m, int n)$/;"	f
putcanon_sg	naututil.c	/^putcanon_sg(FILE *f, int *canonlab, sparsegraph *canong, int linelength)$/;"	f
putcgraph	listg.c	/^putcgraph(FILE *f, graph *g, int linelength, boolean digraph, int m, int n)$/;"	f	file:
putcgraph	showg.c	/^putcgraph(FILE *f, graph *g, int linelength, boolean digraph, int m, int n)$/;"	f	file:
putdegs	naututil.c	/^putdegs(FILE *f, graph *g, int linelength, int m, int n)$/;"	f
putdegs_sg	naututil.c	/^putdegs_sg(FILE *f, sparsegraph *sg, int linelength)$/;"	f
putdegseq	naututil.c	/^putdegseq(FILE *f, graph *g, int linelength, int m, int n)$/;"	f
putdegseq_sg	naututil.c	/^putdegseq_sg(FILE *f, sparsegraph *sg, int linelength)$/;"	f
putdotty	listg.c	/^putdotty(FILE *f, graph *g, unsigned long id, char *extras, int m, int n)$/;"	f	file:
putedges	listg.c	/^putedges(FILE *f, graph *g, boolean ptn, int linelength, $/;"	f	file:
putedges	showg.c	/^putedges(FILE *f, graph *g, int linelength, $/;"	f	file:
putgraph	naututil.c	/^putgraph(FILE *f, graph *g, int linelength, int m, int n)$/;"	f
putgraph_sg	naututil.c	/^putgraph_sg(FILE *f, sparsegraph *sg, int linelength)$/;"	f
putgraphplus_sg	traces.c	/^void putgraphplus_sg(FILE *f, sparsegraph *sg, int linelength)$/;"	f
putgraphx	listg.c	/^putgraphx(FILE *f, graph *g, int linelength, boolean triang, int m, int n)$/;"	f	file:
putgraphx	showg.c	/^putgraphx(FILE *f, graph *g, int linelength, boolean triang, int m, int n)$/;"	f	file:
putmapping	naututil.c	/^putmapping(FILE *f, int *lab1, int org1,int *lab2, int org2,$/;"	f
putnumbers	naututil.c	/^putnumbers(FILE *f, int *x, int linelength, int n)$/;"	f	file:
putorbits	naututil.c	/^putorbits(FILE *f, int *orbits, int linelength, int n)$/;"	f
putorbitsplus	naututil.c	/^putorbitsplus(FILE *f, int *orbits, int linelength, int n)$/;"	f
putptn	naututil.c	/^putptn(FILE *f, int *lab, int *ptn, int level, int linelength, int n)$/;"	f
putquotient	naututil.c	/^putquotient(FILE *f, graph *g, int *lab, int *ptn, int level,$/;"	f
putquotient_sg	naututil.c	/^putquotient_sg(FILE *f, sparsegraph *g, int *lab, int *ptn,$/;"	f
putsequence	naututil.c	/^putsequence(FILE *f, int *x, int linelength, int n)$/;"	f	file:
putset	naututil.c	/^putset(FILE *f, set *set1, int *curlenp, int linelength,$/;"	f
putset_firstbold	naututil.c	/^putset_firstbold(FILE *f, set *set1, int *curlenp, int linelength,$/;"	f
putsetx	listg.c	/^putsetx(FILE *f, set *set1, int *curlenp, int linelength, int m,$/;"	f	file:
putsetx	showg.c	/^putsetx(FILE *f, set *set1, int *curlenp, int linelength, int m,$/;"	f	file:
putstring	nautil.c	/^putstring(FILE *f, char *s)$/;"	f
putve	listg.c	/^putve(FILE *f, unsigned long id, graph *g, boolean digraph, int m, int n)$/;"	f	file:
pwr	schreier.h	/^    int *pwr;                      \/*  transitive closure maps i->fixed *\/$/;"	m	struct:schreierlevel
quadruples	nautinv.c	/^quadruples(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
quickSort	traces.c	/^void quickSort(int *arr, int elements) {$/;"	f
quiet	genbg.c	/^boolean quiet;                  \/* presence of -q *\/$/;"	v
quiet	geng.c	/^boolean quiet;                  \/* presence of -q *\/$/;"	v
quiet	gentourng.c	/^boolean quiet;                  \/* presence of -q *\/$/;"	v
rChi	gentreeg.c	/^ rChi[MAXN+1],                \/* the right most child of node i *\/$/;"	v	file:
ran_arr_buf	naurng.c	/^static TLS_ATTR long ran_arr_buf[RNG_QUALITY];$/;"	v	file:
ran_arr_buf	rng.c	/^static long ran_arr_buf[QUALITY];$/;"	v	file:
ran_arr_cycle	naurng.c	/^ran_arr_cycle(void)$/;"	f	file:
ran_arr_cycle	rng.c	/^ran_arr_cycle(void)$/;"	f
ran_arr_dummy	naurng.c	/^static long ran_arr_dummy=-1;$/;"	v	file:
ran_arr_dummy	rng.c	/^static long ran_arr_dummy=-1, ran_arr_started=-1;$/;"	v	file:
ran_arr_next	rng.c	116;"	d	file:
ran_arr_ptr	naurng.c	/^static TLS_ATTR long *ran_arr_ptr = &ran_arr_dummy;$/;"	v	file:
ran_arr_ptr	rng.c	/^long *ran_arr_ptr=&ran_arr_dummy; \/* the next random number, or -1 *\/$/;"	v
ran_arr_started	naurng.c	/^static long ran_arr_started=-1;$/;"	v	file:
ran_arr_started	rng.c	/^static long ran_arr_dummy=-1, ran_arr_started=-1;$/;"	v	file:
ran_array	naurng.c	/^ran_array(long aa[],int n)$/;"	f	file:
ran_array	rng.c	/^void ran_array(long aa[],int n)$/;"	f
ran_init	naurng.c	/^ran_init(long seed)    \/* Added by BDM: use instead of ran_start. *\/$/;"	f
ran_init	rng.c	/^ran_init(long seed)    \/* Added by BDM: use instead of ran_start. *\/$/;"	f
ran_nextran	naurng.c	/^ran_nextran(void)$/;"	f
ran_start	naurng.c	/^ran_start(long seed)$/;"	f	file:
ran_start	rng.c	/^void ran_start(long seed)$/;"	f
ran_x	naurng.c	/^static TLS_ATTR long ran_x[KK];                    \/* the generator state *\/$/;"	v	file:
ran_x	rng.c	/^long ran_x[KK];                    \/* the generator state *\/$/;"	v
ranarcs	genrang.c	/^ranarcs(long e, boolean loopsok, graph *g, int m, int n)$/;"	f	file:
randomtree	genrang.c	/^randomtree(sparsegraph *sg, int n)$/;"	f	file:
ranedges	genrang.c	/^ranedges(long e, boolean loopsok, graph *g, int m, int n)$/;"	f	file:
ranedges_bip	genrang.c	/^ranedges_bip(long e, graph *g, int m, int n1, int n2)$/;"	f	file:
rangraph	naututil.c	/^rangraph(graph *g, boolean digraph, int invprob, int m, int n)$/;"	f
rangraph2	naututil.c	/^rangraph2(graph *g, boolean digraph, int p1, int p2, int m, int n)$/;"	f
rangraph2_sg	naututil.c	/^rangraph2_sg(sparsegraph *sg, boolean digraph, int p1, int p2, int n)$/;"	f
rank	genspecialg.c	/^rank(int k, int *a)$/;"	f	file:
ranperm	naututil.c	/^ranperm(int *perm, int n)$/;"	f
ranreg	genrang.c	/^ranreg(int degree, graph *g, int m, int n)$/;"	f	file:
ranregR	genrang.c	/^ranregR(FILE *f, int degree, int multmax, int loopmax, int n)$/;"	f	file:
ranreg_sg	naututil.c	/^ranreg_sg(sparsegraph *sg, int degree, int n)$/;"	f
ranreglm_sg	genrang.c	/^ranreglm_sg(int degree, sparsegraph *sg, int multmax, int loopmax, int n)$/;"	f	file:
ranrelabel	ranlabg.c	/^ranrelabel(graph *g, int fixed, int m, int n, graph *h)$/;"	f	file:
ransetword	poptest.c	/^ransetword(int k)     \/* setword with k random bits *\/$/;"	f	file:
read_env_formats	sumlines.c	/^read_env_formats(int *numformatsp)$/;"	f	file:
read_formats	sumlines.c	/^read_formats(char *filename, int *numformatsp, boolean mustexist)$/;"	f	file:
read_global_formats	sumlines.c	/^read_global_formats(int *numformatsp)$/;"	f	file:
read_local_formats	sumlines.c	/^read_local_formats(int *numformatsp)$/;"	f	file:
read_sg	gtools.c	/^read_sg(FILE *f, sparsegraph *sg)$/;"	f
read_sg_loops	gtools.c	/^read_sg_loops(FILE *f, sparsegraph *sg, int *nloops) $/;"	f
read_sgg_loops	gtools.c	/^read_sgg_loops(FILE *f, sparsegraph *sg, int *nloops, boolean *digraph) $/;"	f
readblissgraph	blisstog.c	/^readblissgraph(FILE *f, sparsegraph *g)$/;"	f	file:
readg	gtools.c	/^readg(FILE *f, graph *g, int reqm, int *pm, int *pn) $/;"	f
readg_code	gtools.c	/^TLS_ATTR int readg_code;$/;"	v
readg_inc	gtools.c	/^readg_inc(FILE *f, graph *g, int reqm, int *pm, int *pn,$/;"	f
readg_line	gtools.c	/^TLS_ATTR char *readg_line;$/;"	v
readgg	gtools.c	/^readgg(FILE *f, graph *g, int reqm, int *pm, int *pn, boolean *digraph) $/;"	f
readgg	showg.c	/^readgg(FILE *f, graph *g, int reqm, int *pm, int *pn, boolean *digraph) $/;"	f
readgg_inc	gtools.c	/^readgg_inc(FILE *f, graph *g, int reqm, int *pm, int *pn,$/;"	f
readgraph	naututil.c	/^readgraph(FILE *f, graph *g, boolean digraph, boolean prompt,$/;"	f
readgraph_sg	naututil.c	/^readgraph_sg(FILE *f, sparsegraph *sg, boolean digraph, boolean prompt,$/;"	f
readgraph_swg	naututil.c	/^readgraph_swg(FILE *f, sparsegraph *sg, boolean digraph, boolean prompt,$/;"	f
readinteger	naututil.c	/^readinteger(FILE *f, int *p)$/;"	f
readinteger_sl	naututil.c	/^readinteger_sl(FILE *f, int *p)$/;"	f
readoneline	sumlines.c	/^readoneline(FILE *f, char *line, int size, int *nulls)$/;"	f	file:
readpc_sg	gtools.c	/^readpc_sg(FILE *f,sparsegraph *sg)$/;"	f
readpcle_sg	gtools.c	/^readpcle_sg(FILE *f,sparsegraph *sg)$/;"	f
readperm	naututil.c	/^readperm(FILE *f, int *perm, boolean prompt, int n)$/;"	f
readptn	naututil.c	/^readptn(FILE *f, int *lab, int *ptn, int *numcells, boolean prompt, int n)$/;"	f
readstring	naututil.c	/^readstring(FILE *f, char *s, int slen)$/;"	f
readvperm	naututil.c	/^readvperm(FILE *f, int *perm, boolean prompt, int n, int *nv)$/;"	f
recover	nauty.c	/^recover(int *ptn, int level)$/;"	f	file:
redgraph	traces.c	/^static TLS_ATTR sparsegraph redgraph;$/;"	v	file:
ref	traces.c	/^    int *ref;$/;"	m	struct:weightwhere	file:
refcount	schreier.h	/^    unsigned long refcount;              \/* number of references *\/$/;"	m	struct:permnodestruct
refine	naugraph.c	/^refine(graph *g, int *lab, int *ptn, int level, int *numcells,$/;"	f
refine	nauty.h	/^    void    (*refine)         \/* refine partition *\/$/;"	m	struct:__anon19
refine1	naugraph.c	/^refine1(graph *g, int *lab, int *ptn, int level, int *numcells,$/;"	f
refine1	nauty.h	/^    void    (*refine1)        \/* refine partition, MAXM==1 *\/$/;"	m	struct:__anon19
refine_sg	nausparse.c	/^refine_sg(graph *g, int *lab, int *ptn, int level, int *numcells,$/;"	f
refine_tr	traces.c	/^void refine_tr(sparsegraph *sg, int *lab, int *ptn, int *numcells, int *code, TracesOptions *options_arg) {$/;"	f
refine_tr_refine	traces.c	/^int refine_tr_refine(Candidate *Cand,$/;"	f
refinex	genbg.c	/^refinex(graph *g, int *lab, int *ptn, int level, int *numcells,$/;"	f	file:
refinex	geng.c	/^refinex(graph *g, int *lab, int *ptn, int level, int *numcells,$/;"	f	file:
refinex	genquarticg.c	/^refinex(graph *g, int *lab, int *ptn, int level, int *numcells, int *count,$/;"	f	file:
refinex	gentourng.c	/^refinex(graph *g, int *lab, int *ptn, int level, int *numcells,$/;"	f	file:
refinvar	nautinv.c	/^refinvar(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
regular	gentourng.c	/^static boolean regular;$/;"	v	file:
regular	traces.c	/^    boolean regular;$/;"	m	struct:TracesInfo	file:
reject	genquarticg.c	/^{ accept,reject,undef } CHOISE;$/;"	e	enum:__anon9	file:
rejectlevel	directg.c	/^static int rejectlevel;$/;"	v	file:
relabel	naututil.c	/^relabel(graph *g, int *lab, int *perm, graph *workg, int m, int n)$/;"	f
relabel_sg	naututil.c	/^relabel_sg(sparsegraph *sg, int *lab, int *perm, sparsegraph *workg)$/;"	f
remaining_doubles	watercluster2.c	/^int remaining_doubles=0; \/* hoeveel bogen kunnen ten hoogste nog in allebei $/;"	v
remember_operations	watercluster2.c	/^unsigned char *remember_operations[MAXN]; \/\/the nonequivalent operations that are stored for every iteration$/;"	v
remember_size	watercluster2.c	/^int remember_size[MAXN]; \/\/ remember_size[i] is the number of characters allocated for remember_operations[i]$/;"	v
rememberorbits	watercluster2.c	/^int rememberorbits[MAXN][MAXN];$/;"	v
rep	naugroup.h	/^    permrec *rep;    \/* pointer to a representative *\/$/;"	m	struct:coset_struct
rep_in_parent_list	planarity.h	/^    t_dlcl       * rep_in_parent_list;$/;"	m	struct:ver_edge
repeats	cubhamg.c	/^static long repeats;$/;"	v	file:
replist	naugroup.h	/^    cosetrec *replist; \/* array of orbitsize representatives *\/$/;"	m	struct:level_struct
res	genbg.c	/^static int maxdeg1,maxdeg2,n1,maxn2,mine,maxe,nprune,mod,res,curres;$/;"	v	file:
res	geng.c	/^static int mindeg,maxdeg,maxn,mine,maxe,mod,res;$/;"	v	file:
res	genquarticg.c	/^static int  nmax, m, code, numcells, mod, res, splitlevel, splitcount;$/;"	v	file:
res	gentourng.c	/^static int mindeg,maxdeg,maxn,mod,res;$/;"	v	file:
res	gentreeg.c	/^static int splitlevel,splitcount,mod,res;   \/* -s res\/mod *\/$/;"	v	file:
reset_doubles	watercluster2.c	/^void reset_doubles(BOOG edgelist[], int marklist[], int marklistend)$/;"	f
right	planarity.h	/^    struct dlcl    * right;$/;"	m	struct:dlcl	typeref:struct:dlcl::dlcl
right	sumlines.c	/^    struct countrec *left,*right,*parent;$/;"	m	struct:countrec	typeref:struct:countrec::	file:
right	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:grpsize_st	typeref:struct:grpsize_st::	file:
right	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:node_st	typeref:struct:node_st::	file:
right	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:splay_st	typeref:struct:splay_st::	file:
right	testg.c	/^    struct splay_st *left,*right,*parent;$/;"	m	struct:value_st	typeref:struct:value_st::	file:
rigidnodes	genbg.c	/^static long nodes[MAXN],rigidnodes[MAXN],fertilenodes[MAXN];$/;"	v	file:
rigidnodes	geng.c	/^static unsigned long rigidnodes[MAXN],fertilenodes[MAXN];$/;"	v	file:
rigidnodes	gentourng.c	/^static unsigned long rigidnodes[MAXN],fertilenodes[MAXN];$/;"	v	file:
root_op	watercluster2.c	/^int *root_op=NULL, size_root=0, blocklength, orbitblocklength[MAXN], size_operations=0, number_operations=0;$/;"	v
rundmodel	genrang.c	/^rundmodel(int *cub, int degree, int n)$/;"	f	file:
rundmodel_bip	genrang.c	/^rundmodel_bip(int *cub, int deg1, int deg2, int n1, int n2)$/;"	f	file:
runit	nauthread1.c	/^runit(void * threadarg)          \/* Main routine for one thread *\/$/;"	f	file:
runit	nauthread2.c	/^runit(void * threadarg)          \/* Main routine for one thread *\/$/;"	f	file:
runonetest	runalltests	/^runonetest() {$/;"	f
s6len	gtools.c	/^TLS_ATTR size_t s6len;$/;"	v
samepref	traces.c	/^    int samepref;$/;"	m	struct:TracesVars	file:
samerows	nauty.c	/^    samerows,      \/* number of rows of canong which are correct for$/;"	v	file:
sammle_permutationen	watercluster2.c	/^void sammle_permutationen(int count, permutation perm[], nvector orbits[],$/;"	f
saturated	watercluster2.c	/^int indeg_free[MAXN]={0}, outdeg_free[MAXN]={0}, saturated[MAXN]={0};$/;"	v
savedg	dreadnaut.c	/^static graph savedg[MAXM*1L*MAXN];$/;"	v	file:
savedg_sg	dreadnaut.c	/^static sparsegraph savedg_sg;$/;"	v	file:
savedlab	dreadnaut.c	/^static int savedlab[MAXN],savedptn[MAXN];$/;"	v	file:
savedptn	dreadnaut.c	/^static int savedlab[MAXN],savedptn[MAXN];$/;"	v	file:
savemem	geng.c	/^static boolean savemem;         \/* presence of -m *\/$/;"	v	file:
scan	directg.c	/^scan(int level, int ne, int minarcs, int maxarcs, int sofar,$/;"	f	file:
scan	multig.c	/^scan(int level, int ne, long minedges, long maxedges, long sofar,$/;"	f	file:
scan	vcolg.c	/^scan(int level, graph *g, int *prev, long minedges, long maxedges,$/;"	f	file:
scan_lp	multig.c	/^scan_lp(int level, int ne, long minedges, long maxedges, long sofar,$/;"	f	file:
scan_md	multig.c	/^scan_md(int level, int ne, long minedges, long maxedges, long sofar,$/;"	f	file:
scan_reg	multig.c	/^scan_reg(int level, int ne, long minedges, long maxedges, long sofar,$/;"	f	file:
scanline	naucompare.c	/^scanline(char *in, char *fmt, char *out)$/;"	f	file:
scanline	sumlines.c	/^scanline(char *s, char *f, number *val, int *valtype,$/;"	f	file:
schreier	nauty.h	/^    boolean schreier;         \/* use random schreier method *\/$/;"	m	struct:optionstruct
schreier	schreier.h	/^} schreier;$/;"	t	typeref:struct:schreierlevel
schreier1	traces.c	/^    double schreier1;$/;"	m	struct:TracesVars	file:
schreier2	traces.c	/^    double schreier2;$/;"	m	struct:TracesVars	file:
schreier3	traces.c	/^    double schreier3;$/;"	m	struct:TracesVars	file:
schreier_check	schreier.c	/^schreier_check(int wordsize, int m, int n, int version)$/;"	f
schreier_fails	schreier.c	/^schreier_fails(int nfails)$/;"	f
schreier_freedyn	schreier.c	/^schreier_freedyn(void)$/;"	f
schreier_freelist	schreier.c	/^static TLS_ATTR schreier *schreier_freelist = NULL;$/;"	v	file:
schreier_gens	schreier.c	/^schreier_gens(permnode *ring)$/;"	f
schreierfails	schreier.c	/^static TLS_ATTR int schreierfails = SCHREIERFAILS;$/;"	v	file:
schreierlevel	schreier.h	/^typedef struct schreierlevel$/;"	s
search	delptg.c	/^search(int level, int ndel, int *del, graph *g, int m, int n, boolean *degok)$/;"	f	file:
search_edge	watercluster2.c	/^int search_edge(int start, int end, int edgelist[][2], int length)$/;"	f
search_op	watercluster2.c	/^int search_op(unsigned char *op)$/;"	f
searchnode	twohamg.c	/^searchnode(int level, int n, int *e, int nblue, int nred)$/;"	f	file:
searchtrie	traces.c	/^typedef struct searchtrie {$/;"	s	file:
searchtrie	traces.c	/^} searchtrie;$/;"	t	typeref:struct:searchtrie	file:
searchtrie_make	traces.c	/^searchtrie *searchtrie_make(Candidate *CurrCand, Candidate *NextCand, int n, struct TracesVars *tv) {$/;"	f
searchtrie_new	traces.c	/^trielist *searchtrie_new(int n, struct TracesVars *tv) {$/;"	f
sec	genquarticg.c	/^    int sec;$/;"	m	struct:__anon6	file:
sec	genquarticg.c	/^    int sec;$/;"	m	struct:__anon7	file:
sec1	genquarticg.c	/^	int sec1;$/;"	m	struct:__anon8	file:
sec2	genquarticg.c	/^	int sec2;$/;"	m	struct:__anon8	file:
seed	dreadnaut.c	/^static long seed;$/;"	v	file:
seed	genrang.c	/^static long seed;$/;"	v	file:
seed	hamheuristic.c	/^static long seed = 314159265;$/;"	v	file:
seed	nautest.c	/^long seed;$/;"	v
seed	twohamg.c	/^static long seed = 314159265;$/;"	v	file:
seemsbad	checks6.c	/^seemsbad(char *s)$/;"	f	file:
selected	testg.c	/^selected(graph *g, int m, int n, boolean digraph)$/;"	f	file:
semirefine	nautinv.c	/^semirefine(graph *g, int *lab, int *ptn, int level, int *numcells,$/;"	f	file:
separated_DFS_child_list	planarity.h	/^    t_dlcl       * separated_DFS_child_list;$/;"	m	struct:ver_edge
set	nauty.h	/^typedef setword set,graph;$/;"	t
set	showg.c	/^typedef setword set;$/;"	t	file:
sethash	naututil.c	/^sethash(set *s, int n, long seed, int key)$/;"	f
setinter	naututil.c	/^setinter(set *set1, set *set2, int m)$/;"	f
setlab	vcolg.c	/^setlab(int *weight, int *lab, int *ptn, int n)$/;"	f	file:
setlabptn	gtnauty.c	/^setlabptn(int *weight, int *lab, int *ptn, int n)$/;"	f
setlabptnfmt	gtnauty.c	/^setlabptnfmt(char *fmt, int *lab, int *ptn, set *active, int m, int n)$/;"	f	file:
setnbhd	nautinv.c	/^setnbhd(graph *g, int m, int n, set *w, set *wn)$/;"	f
setsigcatcher	dreadnaut.c	/^setsigcatcher(void)$/;"	f	file:
setsize	naututil.c	/^setsize(set *set1, int m)$/;"	f
setword	nauty.h	/^typedef t_uint setword;$/;"	t
setword	nauty.h	/^typedef unsigned int setword;$/;"	t
setword	nauty.h	/^typedef unsigned long long setword;$/;"	t
setword	nauty.h	/^typedef unsigned long setword;$/;"	t
setword	nauty.h	/^typedef unsigned short setword;$/;"	t
setword	showg.c	/^typedef unsigned int setword;$/;"	t	file:
setword	showg.c	/^typedef unsigned long setword;$/;"	t	file:
sg_to_nauty	nausparse.c	/^sg_to_nauty(sparsegraph *sg, graph *g, int reqm, int *pm)$/;"	f
sg_weight	nausparse.h	/^typedef SG_WEIGHT sg_weight;$/;"	t
sgtocub	cubhamg.c	/^sgtocub(sparsegraph *sg, cubgraph cub, int *pne)$/;"	f	file:
sgtod6	gtools.c	/^sgtod6(sparsegraph *sg)$/;"	f
sgtod6string	naugstrings.c	/^sgtod6string(sparsegraph *sg, char **pp)$/;"	f
sgtog6	gtools.c	/^sgtog6(sparsegraph *sg)$/;"	f
sgtog6string	naugstrings.c	/^sgtog6string(sparsegraph *sg, char **pp)$/;"	f
sgtos6	gtools.c	/^sgtos6(sparsegraph *sg)$/;"	f
sgtos6string	naugstrings.c	/^sgtos6string(sparsegraph *sg, char **pp)$/;"	f
shortish	nauty.h	/^typedef int shortish;$/;"	t
shortprune	nautil.c	/^shortprune(set *set1, set *set2, int m)$/;"	f
showg_getline	showg.c	/^showg_getline(FILE *f)     \/* read a line with error checking *\/$/;"	f	file:
sigintcatcher	dreadnaut.c	/^sigintcatcher(int sig)$/;"	f
sign	planarity.h	/^    int          sign;$/;"	m	struct:ver_edge
simple	genbg.c	/^static boolean simple;          \/* presence of -z *\/$/;"	v	file:
singcode	traces.c	/^    unsigned int singcode;$/;"	m	struct:Candidate	file:
singcode	traces.c	/^    unsigned int singcode;$/;"	m	struct:TracesSpine	file:
singend	traces.c	/^    int singend;$/;"	m	struct:TracesSpine	file:
singlongcode	traces.c	/^    unsigned int singlongcode;$/;"	m	struct:TracesVars	file:
singstart	traces.c	/^    int singstart;$/;"	m	struct:TracesSpine	file:
size	testg.c	/^    size_t size;$/;"	m	struct:grpsize_st	file:
size	testg.c	/^    size_t size;$/;"	m	struct:value_st	file:
size_A	planarity.h	/^	int                 size_A;$/;"	m	struct:graph_sparse_rep
size_operations	watercluster2.c	/^int *root_op=NULL, size_root=0, blocklength, orbitblocklength[MAXN], size_operations=0, number_operations=0;$/;"	v
size_root	watercluster2.c	/^int *root_op=NULL, size_root=0, blocklength, orbitblocklength[MAXN], size_operations=0, number_operations=0;$/;"	v
sn	genquarticg.c	/^    setword sn;$/;"	m	struct:__anon6	file:
snwork	nausparse.c	/^static TLS_ATTR set snwork[40*MAXM];$/;"	v	file:
sort_Split_Array	traces.c	/^void sort_Split_Array(int *Array, int Ind){$/;"	f
sort_decreasing	watercluster2.c	/^void sort_decreasing(int list[], int number)$/;"	f
sort_formats	sumlines.c	/^sort_formats(int *order, int numformats)$/;"	f	file:
sortedlab	traces.c	/^    boolean sortedlab;$/;"	m	struct:Candidate	file:
sortlists_sg	nausparse.c	/^sortlists_sg(sparsegraph *g)$/;"	f
spaextend	geng.c	/^spaextend(graph *g, int n, int *deg, int ne, boolean rigid,$/;"	f	file:
sparse6	genbg.c	/^boolean sparse6;                \/* presence of -s *\/$/;"	v
sparse6	geng.c	/^boolean sparse6;                \/* presence of -s *\/$/;"	v
sparse6	genquarticg.c	/^boolean     sparse6;                        \/* presence of -s *\/$/;"	v
sparse6	gentourng.c	/^boolean sparse6;                \/* presence of -s *\/$/;"	v
sparseg_adjl_add_dir_edge	planarity.c	/^sparseg_adjl_add_dir_edge (t_ver_sparse_rep *V, int n,$/;"	f
sparseg_adjl_add_dir_edge_no_extend	planarity.c	/^sparseg_adjl_add_dir_edge_no_extend (t_ver_sparse_rep *V, int n,$/;"	f
sparseg_adjl_add_edge	planarity.c	/^sparseg_adjl_add_edge (t_ver_sparse_rep *V, int n, t_adjl_sparse_rep **A,$/;"	f
sparseg_adjl_add_edge_no_extend	planarity.c	/^sparseg_adjl_add_edge_no_extend (t_ver_sparse_rep *V, int n,$/;"	f
sparseg_adjl_add_vertices	planarity.c	/^sparseg_adjl_add_vertices (t_ver_sparse_rep **V, int n, int nmore)$/;"	f
sparseg_adjl_add_vertices_no_extend	planarity.c	/^sparseg_adjl_add_vertices_no_extend (t_ver_sparse_rep *V, int n, int nmore)$/;"	f
sparseg_adjl_dfs_preprocessing	planarity.c	/^sparseg_adjl_dfs_preprocessing ($/;"	f
sparseg_adjl_dir_edge_exists	planarity.c	/^sparseg_adjl_dir_edge_exists (t_ver_sparse_rep *V, int n,$/;"	f
sparseg_adjl_edges	planarity.c	/^sparseg_adjl_edges (t_ver_sparse_rep *V, int n, t_adjl_sparse_rep *A,$/;"	f
sparseg_adjl_embed_print	planarity.c	/^sparseg_adjl_embed_print (t_ver_sparse_rep *V_e, int n,$/;"	f
sparseg_adjl_eq	planarity.c	/^sparseg_adjl_eq (t_ver_sparse_rep *V1, int n1, t_adjl_sparse_rep *A1,$/;"	f
sparseg_adjl_footprint	planarity.c	/^sparseg_adjl_footprint (t_ver_sparse_rep *V, int n,$/;"	f
sparseg_adjl_is_planar	planarity.c	/^sparseg_adjl_is_planar ($/;"	f
sparseg_adjl_plan_and_iso	planarity.c	/^sparseg_adjl_plan_and_iso (t_ver_sparse_rep *V, int n, t_adjl_sparse_rep *A,$/;"	f
sparseg_adjl_print	planarity.c	/^sparseg_adjl_print (t_ver_sparse_rep *V, int n,$/;"	f
sparseg_adjl_relabel_vertex	planarity.c	/^sparseg_adjl_relabel_vertex (t_adjl_sparse_rep *A, int pos, int u)$/;"	f
sparseg_adjl_remove_all_dir_edge_no_red	planarity.c	/^sparseg_adjl_remove_all_dir_edge_no_red (t_ver_sparse_rep *V,$/;"	f
sparseg_adjl_remove_dir_edge_no_red	planarity.c	/^sparseg_adjl_remove_dir_edge_no_red (t_ver_sparse_rep *V,$/;"	f
sparseg_adjl_remove_edge_no_red	planarity.c	/^sparseg_adjl_remove_edge_no_red (t_ver_sparse_rep *V, t_adjl_sparse_rep *A,$/;"	f
sparseg_adjl_remove_vertex	planarity.c	/^sparseg_adjl_remove_vertex (t_ver_sparse_rep **V, int n,$/;"	f
sparseg_adjl_remove_vertex_no_red	planarity.c	/^sparseg_adjl_remove_vertex_no_red (t_ver_sparse_rep *V, int n,$/;"	f
sparseg_adjl_sub	planarity.c	/^sparseg_adjl_sub (t_ver_sparse_rep *V1, int n1, t_adjl_sparse_rep *A1,$/;"	f
sparseg_adjl_to_nauty_graph	planarity.c	/^sparseg_adjl_to_nauty_graph (t_ver_sparse_rep *V, int n, t_adjl_sparse_rep *A)$/;"	f
sparseg_adjl_u_adj_v	planarity.c	/^sparseg_adjl_u_adj_v (t_ver_sparse_rep *V, int n, t_adjl_sparse_rep *A,$/;"	f
sparseg_dlcl_append_to_neigh_list	planarity.c	/^sparseg_dlcl_append_to_neigh_list (t_dlcl **g, int n, int v, int u, int in_adjl)$/;"	f
sparseg_dlcl_delete	planarity.c	/^sparseg_dlcl_delete (t_dlcl **g, int n)$/;"	f
sparseg_dlcl_is_adjacent	planarity.c	/^sparseg_dlcl_is_adjacent (t_dlcl **g, int n, int v, int u, t_dlcl **p)$/;"	f
sparseg_dlcl_is_present	planarity.c	/^sparseg_dlcl_is_present (t_dlcl *l, int label, t_dlcl **p)$/;"	f	file:
sparseg_dlcl_print	planarity.c	/^sparseg_dlcl_print (t_dlcl **g, int n)$/;"	f
sparseg_dlcl_sub	planarity.c	/^sparseg_dlcl_sub (t_dlcl **g1, int n1, t_dlcl **g2, int n2)$/;"	f
sparseg_dlcl_to_sparseg	planarity.c	/^sparseg_dlcl_to_sparseg (t_dlcl **g, int n, int e,$/;"	f
sparsegraph	nausparse.h	/^} sparsegraph;$/;"	t	typeref:struct:__anon10
sparsenauty	nausparse.c	/^sparsenauty(sparsegraph *g, int *lab, int *ptn, int *orbits,$/;"	f
special	naucompare.c	/^static char* special[] =   \/* Make sure to use \\n *\/$/;"	v	file:
specialgens	traces.c	/^    int specialgens;$/;"	m	struct:TracesVars	file:
spinelementorbsize	traces.c	/^int spinelementorbsize(int *orbits, int *lab, int size, int elem) {$/;"	f
splay	sumlines.c	/^splay(countnode *p)$/;"	f	file:
splay_node	testg.c	/^} splay_node;$/;"	t	typeref:struct:splay_st	file:
splay_st	testg.c	/^typedef struct splay_st$/;"	s	file:
splitcases	directg.c	/^static unsigned long splitcases;$/;"	v	file:
splitcases	genbg.c	/^static unsigned long splitcases = 0;$/;"	v	file:
splitcount	directg.c	/^static int splitlevel,splitmod,splitres,splitcount;$/;"	v	file:
splitcount	genquarticg.c	/^static int  nmax, m, code, numcells, mod, res, splitlevel, splitcount;$/;"	v	file:
splitcount	gentreeg.c	/^static int splitlevel,splitcount,mod,res;   \/* -s res\/mod *\/$/;"	v	file:
splitlevel	directg.c	/^static int splitlevel,splitmod,splitres,splitcount;$/;"	v	file:
splitlevel	geng.c	/^static int min_splitlevel,odometer,splitlevel,multiplicity;$/;"	v	file:
splitlevel	genquarticg.c	/^static int  nmax, m, code, numcells, mod, res, splitlevel, splitcount;$/;"	v	file:
splitlevel	gentourng.c	/^static int min_splitlevel,odometer,splitlevel,multiplicity;$/;"	v	file:
splitlevel	gentreeg.c	/^static int splitlevel,splitcount,mod,res;   \/* -s res\/mod *\/$/;"	v	file:
splitmod	directg.c	/^static int splitlevel,splitmod,splitres,splitcount;$/;"	v	file:
splitres	directg.c	/^static int splitlevel,splitmod,splitres,splitcount;$/;"	v	file:
squarefree	geng.c	/^static boolean squarefree;      \/* presence of -f *\/$/;"	v	file:
stabvertex	nauty.c	/^    stabvertex,    \/* point fixed in ancestor of first leaf at level$/;"	v	file:
stack	cubhamg.c	/^static vertvec onstack,stack;       \/* stack contains vertex numbers *\/$/;"	v	file:
stacklev	cubhamg.c	/^static int *stackptr,stacklev;      \/* stackptr points above top *\/$/;"	v	file:
stackmark	traces.c	/^    int stackmark;$/;"	m	struct:TracesVars	file:
stackptr	cubhamg.c	/^static int *stackptr,stacklev;      \/* stackptr points above top *\/$/;"	v	file:
standard	cubhamg.c	/^static long standard[]$/;"	v	file:
start	planarity.h	/^    int          start, end;$/;"	m	struct:merge_queue
staticg	watercluster2.c	/^graph workg[MAXN], staticg[MAXN], canong[MAXN];$/;"	v
stats	dreadnaut.c	/^static statsblk stats;$/;"	v	file:
stats	nauty.c	/^static TLS_ATTR statsblk *stats;$/;"	v	file:
stats	traces.c	/^    TracesStats *stats;$/;"	m	struct:TracesVars	file:
stats	watercluster2.c	/^static statsblk stats;$/;"	v	file:
statsblk	nauty.h	/^} statsblk;$/;"	t	typeref:struct:__anon18
steps	traces.c	/^    int steps;$/;"	m	struct:TracesVars	file:
stnode	traces.c	/^    struct searchtrie *stnode;$/;"	m	struct:Candidate	typeref:struct:Candidate::searchtrie	file:
stpend	traces.c	/^    int stpend;$/;"	m	struct:TracesSpine	file:
stpstart	traces.c	/^    int stpstart;$/;"	m	struct:TracesSpine	file:
strategy	traces.c	/^    int strategy;$/;"	m	struct:TracesVars	file:
strategy	traces.h	/^	int strategy;    \/* Only the value 0 is supported in this version. *\/$/;"	m	struct:TracesOptions
strhaschar	gtools.c	/^strhaschar(char *s, int c)$/;"	f
strielist	traces.c	/^    trielist *strielist;$/;"	m	struct:TracesVars	file:
strienext	traces.c	/^    int strienext;$/;"	m	struct:TracesVars	file:
stringcopy	gtools.c	/^stringcopy(char *s)   \/* duplicate string *\/$/;"	f
stringcounts	gtools.c	/^stringcounts(char *s, int *pn, size_t *pe)$/;"	f
stringtograph	gtools.c	/^stringtograph(char *s, graph *g, int m)$/;"	f
stringtograph	showg.c	/^stringtograph(char *s, graph *g, int m)$/;"	f	file:
stringtograph_inc	gtools.c	/^stringtograph_inc(char *s, graph *g, int m,$/;"	f
stringtosparsegraph	gtools.c	/^stringtosparsegraph(char *s, sparsegraph *sg, int *nloops)$/;"	f
stronglyconnected	gutil2.c	/^stronglyconnected(graph *g, int m, int n)$/;"	f
subdivisiongraph	subdivideg.c	/^subdivisiongraph(sparsegraph *g, int k, sparsegraph *h)$/;"	f	file:
sublabel	naututil.c	/^sublabel(graph *g, int *perm, int nperm, graph *workg, int m, int n)$/;"	f
sublabel_sg	naututil.c	/^sublabel_sg(sparsegraph *sg, int *perm, int nperm, sparsegraph *workg)$/;"	f
subpartition	naututil.c	/^subpartition(int *lab, int *ptn, int n, int *perm, int nperm)$/;"	f
symbol	testg.c	/^    char symbol;$/;"	m	struct:constraint_st	file:
t_adjl_sparse_rep	planarity.h	/^} t_adjl_sparse_rep;$/;"	t	typeref:struct:adjl_sparse_rep
t_comp_sparse_rep	planarity.h	/^} t_comp_sparse_rep;$/;"	t	typeref:struct:comp_sparse_rep
t_dlcl	planarity.h	/^} t_dlcl;$/;"	t	typeref:struct:dlcl
t_edge_sparse_rep	planarity.h	/^} t_edge_sparse_rep;$/;"	t	typeref:struct:edge_sparse_rep
t_embed_sparse_rep	planarity.h	/^} t_embed_sparse_rep;$/;"	t	typeref:struct:embed_sparse_rep
t_graph_sparse_rep	planarity.h	/^} t_graph_sparse_rep;$/;"	t	typeref:struct:graph_sparse_rep
t_merge_queue	planarity.h	/^} t_merge_queue;$/;"	t	typeref:struct:merge_queue
t_ver_edge	planarity.h	/^} t_ver_edge;$/;"	t	typeref:struct:ver_edge
t_ver_sparse_rep	planarity.h	/^} t_ver_sparse_rep;$/;"	t	typeref:struct:ver_sparse_rep
targetcell	naugraph.c	/^targetcell(graph *g, int *lab, int *ptn, int level, int tc_level,$/;"	f
targetcell	nauty.h	/^    int     (*targetcell)     \/* decide which cell to split *\/$/;"	m	struct:__anon19
targetcell_sg	nausparse.c	/^targetcell_sg(graph *g, int *lab, int *ptn, int level, int tc_level,$/;"	f
tc_level	nauty.c	/^static TLS_ATTR int linelength,tc_level,mininvarlevel,maxinvarlevel,invararg;$/;"	v	file:
tc_level	nauty.h	/^    int tc_level;             \/* max level for smart target cell choosing *\/$/;"	m	struct:optionstruct
tcell	traces.c	/^    int tcell;$/;"	m	struct:TracesVars	file:
tcell_sz	traces.c	/^    int tcell_sz;$/;"	m	struct:TracesVars	file:
tcellevel	traces.c	/^    int tcellevel;$/;"	m	struct:TracesVars	file:
tcellexpath	traces.c	/^    int tcellexpath;$/;"	m	struct:TracesVars	file:
tcellexpath_sz	traces.c	/^    int tcellexpath_sz;$/;"	m	struct:TracesVars	file:
tcellptr	nauty.c	/^    set *tcellptr;$/;"	m	struct:tcnode_struct	file:
tcnode	nauty.c	/^} tcnode;$/;"	t	typeref:struct:tcnode_struct	file:
tcnode0	nauty.c	/^static TLS_ATTR tcnode tcnode0 = {NULL,NULL};$/;"	v	file:
tcnode_struct	nauty.c	/^typedef struct tcnode_struct$/;"	s	file:
tctotal	nauty.h	/^    unsigned long tctotal;       \/* total size of all target cells *\/$/;"	m	struct:__anon18
tempactive	dreadnaut.c	/^static int tempactive[MAXM];$/;"	v	file:
templab	dreadnaut.c	/^static int templab[MAXN];$/;"	v	file:
tempptn	dreadnaut.c	/^static int tempptn[MAXN];$/;"	v	file:
test_possible	watercluster2.c	/^int test_possible(graph globalg[],int globaldeg[], int n, int m, int min_direct_deg)$/;"	f
testcanlab	naugraph.c	/^testcanlab(graph *g, graph *canong, int *lab, int *samerows, int m, int n)$/;"	f
testcanlab	nauty.h	/^    int     (*testcanlab)     \/* test for better labelling *\/$/;"	m	struct:__anon19
testcanlab_sg	nausparse.c	/^testcanlab_sg(graph *g, graph *canong, int *lab, int *samerows, int m, int n)$/;"	f
testcanlab_tr	nausparse.c	/^testcanlab_tr(sparsegraph *g, sparsegraph *canong,$/;"	f
testispermutation	schreier.c	/^testispermutation(int id, int *p, int n)$/;"	f	file:
testmax	directg.c	/^testmax(int *p, int n, int *abort)$/;"	f
testmax	multig.c	/^testmax(int *p, int n, int *abort)$/;"	f	file:
testmax	vcolg.c	/^testmax(int *p, int n, int *abort)$/;"	f	file:
tg_canonise	gtnauty.c	/^tg_canonise(graph *g, graph *h, int m, int n)$/;"	f
tgtcell	traces.c	/^    int tgtcell;$/;"	m	struct:TracesSpine	file:
tgtend	traces.c	/^    int tgtend;$/;"	m	struct:TracesSpine	file:
tgtfrom	traces.c	/^    int tgtfrom;$/;"	m	struct:TracesSpine	file:
tgtpos	traces.c	/^    int tgtpos;$/;"	m	struct:TracesSpine	file:
tgtsize	traces.c	/^    int tgtsize;$/;"	m	struct:TracesSpine	file:
thegraphisparse	traces.c	/^    boolean thegraphisparse;$/;"	m	struct:TracesInfo	file:
thegrouphaschanged	traces.c	/^    boolean thegrouphaschanged;$/;"	m	struct:TracesInfo	file:
thereisnextlevel	traces.c	/^    boolean thereisnextlevel;$/;"	m	struct:TracesInfo	file:
thetracexists	traces.c	/^    boolean thetracexists;$/;"	m	struct:TracesSpine	file:
threshold	genquarticg.c	21;"	d	file:
time_current_user	planarity.h	47;"	d
timemac	poptest.c	/^timemac(setword *x, int n, int iters, int *sump)$/;"	f	file:
timenew	poptest.c	/^timenew(setword *x, int n, int iters, int *sump)$/;"	f	file:
timenull	poptest.c	/^timenull(setword *x, int n, int iters, int *sump)$/;"	f	file:
timeold	poptest.c	/^timeold(setword *x, int n, int iters, int *sump)$/;"	f	file:
timeout	cubhamg.c	/^static long timeout;$/;"	v	file:
tobedirected	watercluster2.c	/^int tobedirected[MAXN]={0}; \/* how many edges have still to be directed? This can$/;"	v
tolevel	traces.c	/^    int tolevel;$/;"	m	struct:TracesVars	file:
tolevel_tl	traces.c	/^    int tolevel_tl;$/;"	m	struct:TracesVars	file:
top	twohamg.c	/^static int *top;$/;"	v	file:
tosort	shortg.c	/^tosort(FILE *f, char *cdstr, char *dstr, nauty_counter index)$/;"	f	file:
total	sumlines.c	/^    number total[MAXVALUES];$/;"	m	struct:countrec	file:
total_position	sumlines.c	/^static integer total_position[MAXFORMATS];$/;"	v	file:
totalgraph	linegraphg.c	/^totalgraph(sparsegraph *g, sparsegraph *h)$/;"	f	file:
totallab	directg.c	/^static long long totallab;$/;"	v	file:
totallab	multig.c	/^static long long totallab;$/;"	v	file:
totallab	vcolg.c	/^static long long totallab;$/;"	v	file:
totallimit	twohamg.c	/^static nauty_counter nodes,limit,totallimit;$/;"	v	file:
totalnodes	cubhamg.c	/^static long nodecount,maxnodes,totalnodes;$/;"	v	file:
traces_freedyn	traces.c	/^void traces_freedyn(void) {$/;"	f
traces_opts	dreadnaut.c	/^DEFAULTOPTIONS_TRACES(traces_opts);$/;"	v
traces_opts	dretodot.c	/^DEFAULTOPTIONS_TRACES(traces_opts);$/;"	v
traces_refine	traces.c	/^int traces_refine(Candidate *Cand,$/;"	f
traces_refine_comptrie	traces.c	/^int traces_refine_comptrie(Candidate *Cand,$/;"	f
traces_refine_maketrie	traces.c	/^void traces_refine_maketrie(Candidate *Cand,$/;"	f
traces_refine_notrace	traces.c	/^void traces_refine_notrace(Candidate *Cand,$/;"	f
traces_refine_sametrace	traces.c	/^int traces_refine_sametrace(Candidate *Cand,$/;"	f
traces_stats	dreadnaut.c	/^static TracesStats traces_stats;$/;"	v	file:
traces_stats	dretodot.c	/^TracesStats traces_stats;$/;"	v
traces_vertexclass_refine	traces.c	/^int traces_vertexclass_refine (int n, int *lab, int *ptn, Candidate *Cand, Partition *Part, int *RefArray) {$/;"	f
trcend	traces.c	/^    int trcend;$/;"	m	struct:TracesSpine	file:
trcstart	traces.c	/^    int trcstart;$/;"	m	struct:TracesSpine	file:
treedepth	traces.c	/^    int treedepth;$/;"	m	struct:TracesVars	file:
treedepth	traces.h	/^	int treedepth;$/;"	m	struct:TracesStats
treemark	traces.c	/^    int treemark;$/;"	m	struct:TracesVars	file:
trianglefree	geng.c	/^static boolean trianglefree;    \/* presence of -t *\/$/;"	v	file:
triconnected_cub	cubhamg.c	/^triconnected_cub(cubgraph cub, int n)$/;"	f	file:
trie	traces.c	/^typedef struct trie {$/;"	s	file:
trie	traces.c	/^} trie;$/;"	t	typeref:struct:trie	file:
trie_class	traces.c	/^void  trie_class(trie *t, int *count) {$/;"	f
trie_classify	traces.c	/^int trie_classify(int n, TracesVars *tv) {$/;"	f
trie_comp	traces.c	/^struct trie *trie_comp(trie *t, int value) {$/;"	f
trie_dump	traces.c	/^void  trie_dump(trie *t) {$/;"	f
trie_make	traces.c	/^struct trie *trie_make(trie *t, int value, int n, struct TracesVars* tv) {$/;"	f
trie_new	traces.c	/^struct trie *trie_new(int n, struct TracesVars* tv) {$/;"	f
triearray	traces.c	/^    struct searchtrie *triearray;$/;"	m	struct:trielist	typeref:struct:trielist::searchtrie	file:
trielist	traces.c	/^typedef struct trielist {$/;"	s	file:
trielist	traces.c	/^} trielist;$/;"	t	typeref:struct:trielist	file:
trienext	traces.c	/^    int trienext;$/;"	m	struct:TracesVars	file:
triepos	traces.c	/^    int triepos;$/;"	m	struct:TracesVars	file:
trieref	traces.c	/^static TLS_ATTR trie *trieroot, *trieref;$/;"	v	file:
trieroot	traces.c	/^static TLS_ATTR trie *trieroot, *trieref;$/;"	v	file:
triples	nautinv.c	/^triples(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
trivlabels	watercluster2.c	/^ void trivlabels(BOOG *positie)$/;"	f
trivlabels_init	watercluster2.c	/^ void trivlabels_init(BOOG *positie)$/;"	f
trivlabels_nowrite	watercluster2.c	/^ void trivlabels_nowrite(BOOG *positie)$/;"	f
trivlabels_nowrite_nodouble	watercluster2.c	/^ void trivlabels_nowrite_nodouble(BOOG *positie)$/;"	f
trynextstep	watercluster2.c	/^void trynextstep()$/;"	f
trynextstep_par	watercluster2.c	/^void trynextstep_par() $/;"	f
trythisone	directg.c	/^trythisone(grouprec *group, int ne, int n)$/;"	f	file:
trythisone	multig.c	/^trythisone(grouprec *group,$/;"	f	file:
trythisone	vcolg.c	/^trythisone(grouprec *group, graph *g, int m, int n)$/;"	f	file:
twin_in_adjl	planarity.h	/^    int            twin_in_adjl; \/* if relevant, the pos in the adjl. list$/;"	m	struct:dlcl
twin_in_adjl	planarity.h	/^    int          twin_in_adjl; $/;"	m	struct:ver_edge
twocolouring	gutil1.c	/^twocolouring(graph *g, int *colour, int m, int n)$/;"	f
twopaths	nautinv.c	/^twopaths(graph *g, int *lab, int *ptn, int level, int numcells, int tvpos,$/;"	f
type	planarity.h	/^    int          type;$/;"	m	struct:ver_edge
ub	gentreeg.c	/^ ub;                          \/* upper bound on something *\/$/;"	v	file:
undef	genquarticg.c	/^{ accept,reject,undef } CHOISE;$/;"	e	enum:__anon9	file:
uniqinter	nautinv.c	/^uniqinter(set *s1, set *s2, int m)$/;"	f	file:
unitptn	naututil.c	/^unitptn(int *lab,int *ptn, int *numcells, int n)$/;"	f
unorbtotal	labelg.c	/^static double unorbtotal;$/;"	v	file:
unrank	genspecialg.c	/^unrank(int r, int k, int *a)$/;"	f	file:
unsetsigcatcher	dreadnaut.c	/^unsetsigcatcher(void)$/;"	f	file:
updatecan	naugraph.c	/^updatecan(graph *g, graph *canong, int *lab, int samerows, int m, int n)$/;"	f
updatecan	nauty.h	/^    void    (*updatecan)      \/* update canonical object *\/$/;"	m	struct:__anon19
updatecan_sg	nausparse.c	/^updatecan_sg(graph *g, graph *canong, int *lab, int samerows, int m, int n)$/;"	f
updatecan_tr	nausparse.c	/^updatecan_tr(sparsegraph *g, sparsegraph *canong,$/;"	f
updates	traces.c	/^    int updates;$/;"	m	struct:TracesSpine	file:
usage	watercluster2.c	/^void usage(char name[])$/;"	f
useTempOrbits1	traces.c	/^    boolean useTempOrbits1;$/;"	m	struct:TracesInfo	file:
useTempOrbits2	traces.c	/^    boolean useTempOrbits2;$/;"	m	struct:TracesInfo	file:
userautom	dreadnaut.c	/^userautom(int count, int *perm, int *orbits,$/;"	f	file:
userautom1	genquarticg.c	/^userautom1(int count, int *perm, int *orbits, int numorbits, int stabvertex, int n)$/;"	f	file:
userautom2	genquarticg.c	/^userautom2(int count, int *perm, int *orbits, int numorbits, int stabvertex, int n)$/;"	f	file:
userautom3	genquarticg.c	/^userautom3( int count, int *perm, int *orbits, int numorbits, int stabvertex, int n)$/;"	f	file:
userautomproc	genbg.c	/^userautomproc(int count, int *p, int *orbits, int numorbits,$/;"	f	file:
userautomproc	geng.c	/^userautomproc(int count, int *p, int *orbits,$/;"	f	file:
userautomproc	gentourng.c	/^userautomproc(int count, int *p, int *orbits,$/;"	f	file:
userautomproc	nauty.c	/^static TLS_ATTR void (*userautomproc)(int,int*,int*,int,int,int);$/;"	v	file:
userautomproc	nauty.h	/^    void (*userautomproc)     \/* procedure called for each automorphism *\/$/;"	m	struct:optionstruct
userautomproc	traces.h	/^    void (*userautomproc)(int,int*,int);$/;"	m	struct:TracesOptions
userautomprocb	geng.c	/^userautomprocb(int count, int *p, int *orbits,$/;"	f	file:
usercanon	dreadnaut.c	/^usercanon(graph *g, int *lab, graph *canong, int count, int code,$/;"	f	file:
usercanonproc	nauty.c	/^static TLS_ATTR int (*usercanonproc)$/;"	v	file:
usercanonproc	nauty.h	/^    int  (*usercanonproc)     \/* procedure called for better labellings *\/$/;"	m	struct:optionstruct
usercanonproc	traces.h	/^    int  (*usercanonproc)(graph*,int*,graph*,int,int,int,int);$/;"	m	struct:TracesOptions
userlevel	dreadnaut.c	/^userlevel(int *lab, int *ptn, int level, int *orbits, statsblk *stats,$/;"	f	file:
userlevel	gtnauty.c	/^userlevel(int *lab, int *ptn, int level, int *orbits, statsblk *stats,$/;"	f	file:
userlevelproc	nauty.c	/^static TLS_ATTR void (*userlevelproc)$/;"	v	file:
userlevelproc	nauty.h	/^    void (*userlevelproc)     \/* procedure called for each level *\/$/;"	m	struct:optionstruct
usernode	dreadnaut.c	/^usernode(graph *g, int *lab, int *ptn, int level, int numcells,$/;"	f	file:
usernodeproc	nauty.c	/^static TLS_ATTR void (*usernodeproc)(graph*,int*,int*,int,int,int,int,int,int);$/;"	v	file:
usernodeproc	nauty.h	/^    void (*usernodeproc)      \/* procedure called for each node *\/$/;"	m	struct:optionstruct
userrefproc	nauty.h	/^    void (*userrefproc)       \/* replacement for usual refine procedure *\/$/;"	m	struct:optionstruct
v	bliss2dre.c	/^   int v,w;$/;"	m	struct:__anon1	file:
v	blisstog.c	/^   int v,w;$/;"	m	struct:__anon5	file:
v	nausparse.h	/^    size_t *v;   \/* Array of indexes into e[*] *\/$/;"	m	struct:__anon10
v	planarity.h	/^    int          *v;      \/* the actual vertices *\/$/;"	m	struct:comp_sparse_rep
v0	directg.c	/^static int v0[MAXNE],v1[MAXNE];$/;"	v	file:
v0	multig.c	/^static int v0[MAXNE+MAXNV],v1[MAXNE+MAXNV];$/;"	v	file:
v1	directg.c	/^static int v0[MAXNE],v1[MAXNE];$/;"	v	file:
v1	multig.c	/^static int v0[MAXNE+MAXNV],v1[MAXNE+MAXNV];$/;"	v	file:
v1	naututil.c	/^ struct {int v1,v2; sg_weight wt;} edge[ECHUNKSIZE];} echunkw;$/;"	m	struct:echunkw::__anon12	file:
v1	twohamg.c	/^    int v1,v2,v3,v4;$/;"	m	struct:p4	file:
v2	naututil.c	/^ struct {int v1,v2; sg_weight wt;} edge[ECHUNKSIZE];} echunkw;$/;"	m	struct:echunkw::__anon12	file:
v2	twohamg.c	/^    int v1,v2,v3,v4;$/;"	m	struct:p4	file:
v3	twohamg.c	/^    int v1,v2,v3,v4;$/;"	m	struct:p4	file:
v4	twohamg.c	/^    int v1,v2,v3,v4;$/;"	m	struct:p4	file:
val	sumlines.c	/^    integer *val;$/;"	m	struct:__anon13	file:
val	testg.c	/^    long val;$/;"	m	struct:constraint_st	file:
val	testg.c	/^    long val[MAXKEYS];$/;"	m	struct:node_st	file:
val	traces.c	/^    int val;$/;"	m	struct:pair	file:
valstacktop	twohamg.c	/^static addrval *valstacktop;$/;"	v	file:
valtype	testg.c	/^    int valtype;$/;"	m	struct:constraint_st	file:
value	traces.c	/^    int value;$/;"	m	struct:trie	file:
value	twohamg.c	/^    int value;$/;"	m	struct:addrval_struct	file:
value_node	testg.c	/^} value_node;$/;"	t	typeref:struct:value_st	file:
value_root	testg.c	/^static splay_node *value_root = NULL;$/;"	v	file:
value_st	testg.c	/^typedef struct value_st    \/* variant for value tree *\/$/;"	s	file:
vc_nin	vcolg.c	/^nauty_counter vc_nin,vc_nout;$/;"	v
vc_nout	vcolg.c	/^nauty_counter vc_nin,vc_nout;$/;"	v
vec	schreier.h	/^    permnode **vec;                \/* vec[i]^pwr[i] is edge label, *\/$/;"	m	struct:schreierlevel
ver_edge	planarity.h	/^typedef struct ver_edge {$/;"	s
ver_sparse_rep	planarity.h	/^typedef struct ver_sparse_rep {$/;"	s
verbose	cubhamg.c	/^static int verbose;$/;"	v	file:
verbose	genbg.c	/^static boolean verbose;         \/* presence of -v *\/$/;"	v	file:
verbose	geng.c	/^static boolean verbose;         \/* presence of -v *\/$/;"	v	file:
verbosity	traces.h	/^	int verbosity;$/;"	m	struct:TracesOptions
vertex	traces.c	/^    int vertex;$/;"	m	struct:Candidate	file:
vertvec	cubhamg.c	/^typedef int vertvec[MAXN];$/;"	t	file:
virtual_gericht	watercluster2.c	/^int virtual_gericht[MAX_BOGEN][MAX_BOGEN]={{0}}; \/*  virtual_gericht[i][j]==1 als het al vastgelegd is dat {i,j} $/;"	v
virtual_indeg	watercluster2.c	/^int virtual_indeg[MAXN], virtual_outdeg[MAXN]; $/;"	v
virtual_outdeg	watercluster2.c	/^int virtual_indeg[MAXN], virtual_outdeg[MAXN]; $/;"	v
visited	planarity.h	/^    int          visited;$/;"	m	struct:ver_edge
vlen	nausparse.h	/^    size_t vlen,dlen,elen,wlen;  \/* Sizes of arrays in units of type *\/$/;"	m	struct:__anon10
vmark1	nausparse.c	/^static TLS_ATTR short vmark1[MAXN];$/;"	v	file:
vmark1_val	nausparse.c	/^static TLS_ATTR short vmark1_val = 32000;$/;"	v	file:
vmark2	nausparse.c	/^static TLS_ATTR short vmark2[MAXN];$/;"	v	file:
vmark2_val	nausparse.c	/^static TLS_ATTR short vmark2_val = 32000;$/;"	v	file:
vmark_val	genspecialg.c	/^static short vmark_val = 32000;$/;"	v	file:
vnumber	genspecialg.c	/^vnumber(long *dimen, int *index, int ndimen)$/;"	f	file:
vout	sumlines.c	/^static char *dout,*fout,*vout,*hmsout1,*hmsout2;$/;"	v	file:
vpair	bliss2dre.c	/^} vpair;$/;"	t	typeref:struct:__anon1	file:
vpair	blisstog.c	/^} vpair;$/;"	t	typeref:struct:__anon5	file:
vtx	dretodot.c	/^    int vtx;$/;"	m	struct:list	file:
vtx	traces.c	/^    int vtx;$/;"	m	struct:searchtrie	file:
vv	nautinv.c	/^static TLS_ATTR int vv[MAXN],ww[MAXN];$/;"	v	file:
w	bliss2dre.c	/^   int v,w;$/;"	m	struct:__anon1	file:
w	blisstog.c	/^   int v,w;$/;"	m	struct:__anon5	file:
w	nausparse.h	/^    sg_weight *w;      \/* Not implemented, should be NULL. *\/$/;"	m	struct:__anon10
w	traces.c	/^    int *w;$/;"	m	struct:grph_strct	file:
w01	nautinv.c	/^static TLS_ATTR set w01[MAXM],w02[MAXM],w03[MAXM],w12[MAXM],w13[MAXM],w23[MAXM];$/;"	v	file:
w02	nautinv.c	/^static TLS_ATTR set w01[MAXM],w02[MAXM],w03[MAXM],w12[MAXM],w13[MAXM],w23[MAXM];$/;"	v	file:
w03	nautinv.c	/^static TLS_ATTR set w01[MAXM],w02[MAXM],w03[MAXM],w12[MAXM],w13[MAXM],w23[MAXM];$/;"	v	file:
w12	nautinv.c	/^static TLS_ATTR set w01[MAXM],w02[MAXM],w03[MAXM],w12[MAXM],w13[MAXM],w23[MAXM];$/;"	v	file:
w13	nautinv.c	/^static TLS_ATTR set w01[MAXM],w02[MAXM],w03[MAXM],w12[MAXM],w13[MAXM],w23[MAXM];$/;"	v	file:
w23	nautinv.c	/^static TLS_ATTR set w01[MAXM],w02[MAXM],w03[MAXM],w12[MAXM],w13[MAXM],w23[MAXM];$/;"	v	file:
waterclusters	watercluster2.c	/^void waterclusters (graph g[], int n)$/;"	f
watermaxdeg	watercluster2.c	/^int watermaxdeg; \/* maxindeg+maxoutdeg *\/$/;"	v
watermaxedges	watercluster2.c	/^int watermaxedges; \/* what is the theoretical maximum for the number of edges which can$/;"	v
weight	traces.c	/^    int weight;$/;"	m	struct:weightwhere	file:
weighted	traces.h	/^    boolean weighted;$/;"	m	struct:TracesOptions
weightwhere	traces.c	/^typedef struct weightwhere {$/;"	s	file:
weightwhere	traces.c	/^} weightwhere;$/;"	t	typeref:struct:weightwhere	file:
wlen	nausparse.h	/^    size_t vlen,dlen,elen,wlen;  \/* Sizes of arrays in units of type *\/$/;"	m	struct:__anon10
work1	nausparse.c	/^static TLS_ATTR int work1[MAXN];$/;"	v	file:
work2	nausparse.c	/^static TLS_ATTR int work2[MAXN];$/;"	v	file:
work3	nausparse.c	/^static TLS_ATTR int work3[MAXN];$/;"	v	file:
work4	nausparse.c	/^static TLS_ATTR int work4[MAXN];$/;"	v	file:
workg	watercluster2.c	/^graph workg[MAXN], staticg[MAXN], canong[MAXN];$/;"	v
workperm	naugraph.c	/^static TLS_ATTR int workperm[MAXN];$/;"	v	file:
workperm	nautaux.c	/^static TLS_ATTR int workperm[MAXN+2];$/;"	v	file:
workperm	nautil.c	/^static TLS_ATTR int workperm[MAXN];$/;"	v	file:
workperm	nautinv.c	/^static TLS_ATTR int workperm[MAXN];$/;"	v	file:
workperm	naututil.c	/^static TLS_ATTR int workperm[MAXN+2];   \/* used for scratch purposes *\/$/;"	v	file:
workperm	nauty.c	/^static TLS_ATTR int workperm[MAXN];   \/* various scratch uses *\/$/;"	v	file:
workperm	schreier.c	/^static TLS_ATTR int workperm[MAXN];$/;"	v	file:
workperm2	schreier.c	/^static TLS_ATTR int workperm2[MAXN];$/;"	v	file:
workpermA	schreier.c	/^static TLS_ATTR int workpermA[MAXN];$/;"	v	file:
workpermB	schreier.c	/^static TLS_ATTR int workpermB[MAXN];$/;"	v	file:
workset	naugraph.c	/^static TLS_ATTR set workset[MAXM];   \/* used for scratch work *\/$/;"	v	file:
workset	nautaux.c	/^static TLS_ATTR set workset[MAXM];   \/* used for scratch work *\/$/;"	v	file:
workset	nautinv.c	/^static TLS_ATTR set workset[MAXM];$/;"	v	file:
workset	naututil.c	/^static TLS_ATTR set workset[MAXM];      \/* used for scratch purposes *\/$/;"	v	file:
workset	schreier.c	/^static TLS_ATTR set workset[MAXM];$/;"	v	file:
workset2	schreier.c	/^static TLS_ATTR set workset2[MAXM];$/;"	v	file:
workshort	nautinv.c	/^static TLS_ATTR int workshort[MAXN+2];$/;"	v	file:
workspace	dreadnaut.c	/^static setword workspace[MAXM*2L*WORKSIZE];$/;"	v	file:
workspace	genquarticg.c	/^static setword workspace[50];$/;"	v	file:
workspace	nauty.c	/^static TLS_ATTR set *workspace,*worktop;  \/* first and just-after-last$/;"	v	file:
workspace	watercluster2.c	/^setword workspace[100*MAXN];$/;"	v
worktop	nauty.c	/^static TLS_ATTR set *workspace,*worktop;  \/* first and just-after-last$/;"	v	file:
write12	genbg.c	/^write12(FILE *f, graph *g, int n1, int n2)$/;"	f	file:
writeBcode	watercluster2.c	/^ void writeBcode(graph *g, int aantal_toppen)$/;"	f
writeBcode_invers	watercluster2.c	/^ void writeBcode_invers(graph *g, int aantal_toppen)$/;"	f
writeTcode	watercluster2.c	/^ void writeTcode(graph *g, int aantal_toppen)$/;"	f
writeTcode_invers	watercluster2.c	/^ void writeTcode_invers(graph *g, int aantal_toppen)$/;"	f
write_ascii	gentourng.c	/^write_ascii(FILE *f, graph *g, int n)$/;"	f
write_group_size	testg.c	/^write_group_size(FILE *f, group_node *sz)$/;"	f	file:
write_planarcode	planarg.c	/^write_planarcode(FILE *f, t_ver_sparse_rep *VR, t_adjl_sparse_rep *A,$/;"	f	file:
writeautom	directg.c	/^writeautom(int *p, int n)$/;"	f
writeautom	multig.c	/^writeautom(int *p, int n)$/;"	f	file:
writeautom	nautyex3.c	/^writeautom(int *p, int n)$/;"	f
writeautom	vcolg.c	/^writeautom(int *p, int n)$/;"	f	file:
writeautoms	nauthread1.c	/^    boolean writeautoms;$/;"	m	struct:__anon4	file:
writeautoms	nauthread2.c	/^    boolean writeautoms;$/;"	m	struct:__anon11	file:
writeautoms	nauty.c	/^   boolean getcanon,digraph,writeautoms,domarkers,cartesian,doschreier;$/;"	v	file:
writeautoms	nauty.h	/^    boolean writeautoms;      \/* write automorphisms? *\/$/;"	m	struct:optionstruct
writeautoms	traces.h	/^	boolean writeautoms;$/;"	m	struct:TracesOptions
writed6	gtools.c	/^writed6(FILE *f, graph *g, int m, int n)$/;"	f
writed6_sg	gtools.c	/^writed6_sg(FILE *f, sparsegraph *g)$/;"	f
writed6x	gentourng.c	/^writed6x(FILE *f, graph *g, int n)$/;"	f
writedread	genspecialg.c	/^writedread(FILE *f, sparsegraph *sg, boolean digraph)$/;"	f	file:
writeg6	gtools.c	/^writeg6(FILE *f, graph *g, int m, int n)$/;"	f
writeg6_sg	gtools.c	/^writeg6_sg(FILE *f, sparsegraph *g)$/;"	f
writeg6x	genbg.c	/^writeg6x(FILE *f, graph *g, int n1, int n2)$/;"	f
writeg6x	geng.c	/^writeg6x(FILE *f, graph *g, int n)$/;"	f
writeg6x	genquarticg.c	/^writeg6x(FILE *f, graph *g, int n)$/;"	f	file:
writeg6x	gentourng.c	/^writeg6x(FILE *f, graph *g, int n)$/;"	f
writegraph	watercluster2.c	/^ void writegraph(graph *g)$/;"	f
writegraph_edgeorb	watercluster2.c	/^ void writegraph_edgeorb(graph *g, int aantal_toppen,int aantal_bogen, int aantal_gerichte_bogen)$/;"	f
writegre	genbg.c	/^writegre(FILE *f, graph *g, int n1, int n2)$/;"	f
writegroupsize	nautil.c	/^writegroupsize(FILE *f, double gpsize1, int gpsize2)$/;"	f
writeis6	gtools.c	/^writeis6(FILE *f, graph *g, graph *prevg, int m, int n)$/;"	f
writelab	watercluster2.c	/^void writelab(nvector ptn[], nvector lab[])$/;"	f
writelast	gtools.c	/^writelast(FILE *f)$/;"	f
writeline	gtools.c	/^writeline(FILE *f, char *s)$/;"	f
writeline	sumlines.c	/^writeline(char *outf, number *val, unsigned long count)$/;"	f	file:
writelist	watercluster2.c	/^void writelist(int list[])$/;"	f
writemarker	nauty.c	/^writemarker(int level, int tv, int index, int tcellsize,$/;"	f	file:
writemarkers	nauty.h	/^    boolean writemarkers;     \/* write stats on pts fixed, etc.? *\/$/;"	m	struct:optionstruct
writenauty	genbg.c	/^writenauty(FILE *f, graph *g, int n1, int n2)$/;"	f
writenauty	geng.c	/^writenauty(FILE *f, graph *g, int n)$/;"	f
writeny	genbg.c	/^writeny(FILE *f, graph *g, int n1, int n2) $/;"	f
writeny	geng.c	/^writeny(FILE *f, graph *g, int n)$/;"	f
writeone	delptg.c	/^writeone(graph *g, int m, int n, int *del, int ndel)$/;"	f	file:
writeop	watercluster2.c	/^void writeop(unsigned int op, BOOG orbit[], int length)$/;"	f
writeoperation	watercluster2.c	/^void writeoperation(unsigned char op[])$/;"	f
writepc_sg	gtools.c	/^writepc_sg(FILE *f, sparsegraph *sg)$/;"	f
writeperm	nautil.c	/^writeperm(FILE *f, int *perm, boolean cartesian, int linelength, int n)$/;"	f
writerange	gtools.c	/^writerange(FILE *f, int c, long lo, long hi)    \/* Write a range. *\/$/;"	f
writes6	gtools.c	/^writes6(FILE *f, graph *g, int m, int n)$/;"	f
writes6_sg	gtools.c	/^writes6_sg(FILE *f, sparsegraph *g)$/;"	f
writes6x	genbg.c	/^writes6x(FILE *f, graph *g, int n1, int n2)$/;"	f
writes6x	geng.c	/^writes6x(FILE *f, graph *g, int n)$/;"	f
writes6x	genquarticg.c	/^writes6x(FILE *f, graph *g, int n)$/;"	f	file:
writes6x	gentourng.c	/^writes6x(FILE *f, graph *g, int n)$/;"	f
writeset	watercluster2.c	/^void writeset(graph set)$/;"	f
ws1	nautinv.c	/^static TLS_ATTR set ws1[MAXM],ws2[MAXM];$/;"	v	file:
ws2	nautinv.c	/^static TLS_ATTR set ws1[MAXM],ws2[MAXM];$/;"	v	file:
wss	nautinv.c	/^static TLS_ATTR set wss[MAXCLIQUE-1][MAXM];$/;"	v	file:
wt	naututil.c	/^ struct {int v1,v2; sg_weight wt;} edge[ECHUNKSIZE];} echunkw;$/;"	m	struct:echunkw::__anon12	file:
ww	nautinv.c	/^static TLS_ATTR int vv[MAXN],ww[MAXN];$/;"	v	file:
x	directg.c	/^static set x[MAXME];$/;"	v	file:
xbit	genbg.c	/^static int xbit[] = {0x00000001,0x00000002,0x00000004,0x00000008,$/;"	v	file:
xbit	genbg.c	/^static int xbit[] = {0x000001,0x000002,0x000004,0x000008,$/;"	v	file:
xbit	genbg.c	/^static int xbit[] = {0x0001,0x0002,0x0004,0x0008,$/;"	v	file:
xbit	geng.c	/^static xword xbit[] = {0x00000001,0x00000002,0x00000004,0x00000008,$/;"	v	file:
xbit	geng.c	/^static xword xbit[] = {0x000001,0x000002,0x000004,0x000008,$/;"	v	file:
xbit	geng.c	/^static xword xbit[] = {0x0001,0x0002,0x0004,0x0008,$/;"	v	file:
xbit	gentourng.c	/^static xword xbit[] = {0x00000001,0x00000002,0x00000004,0x00000008,$/;"	v	file:
xbit	gentourng.c	/^static xword xbit[] = {0x000001,0x000002,0x000004,0x000008,$/;"	v	file:
xbit	gentourng.c	/^static xword xbit[] = {0x0001,0x0002,0x0004,0x0008,$/;"	v	file:
xbnds	genbg.c	/^xbnds(int n2, int ne, int dmax)$/;"	f	file:
xbnds	geng.c	/^xbnds(int n, int ne, int dmax)$/;"	f	file:
xcard	genbg.c	/^static int *xcard;          \/* cardinalities of all x-sets *\/$/;"	v	file:
xcard	geng.c	/^    xword *xcard;         \/* cardinalities of all x-sets *\/$/;"	m	struct:__anon17	file:
xcard	gentourng.c	/^    xword *xcard;         \/* cardinalities of all x-sets *\/$/;"	m	struct:__anon15	file:
xinv	genbg.c	/^static int *xinv;           \/* map from x-set to index in xset *\/$/;"	v	file:
xinv	geng.c	/^    xword *xinv;          \/* map from x-set to index in xset *\/$/;"	m	struct:__anon17	file:
xinv	gentourng.c	/^    xword *xinv;          \/* map from x-set to index in xset *\/$/;"	m	struct:__anon15	file:
xlb	genbg.c	/^    int xlb,xub;         \/* saved bounds on extension degree *\/$/;"	m	struct:__anon3	file:
xlb	geng.c	/^    int xlb,xub;          \/* saved bounds on extension degree *\/$/;"	m	struct:__anon17	file:
xlim	geng.c	/^    xword xlim;           \/* number of x-sets in xx[] *\/$/;"	m	struct:__anon17	file:
xorb	genbg.c	/^    int *xorb;           \/* min orbit representative *\/$/;"	m	struct:__anon3	file:
xorb	geng.c	/^    xword *xorb;          \/* min orbit representative *\/$/;"	m	struct:__anon17	file:
xorb	gentourng.c	/^    xword *xorb;          \/* min orbit representative *\/$/;"	m	struct:__anon15	file:
xset	genbg.c	/^static int *xset;           \/* array of all x-sets in card order *\/$/;"	v	file:
xset	geng.c	/^    xword *xset;          \/* array of all x-sets in card order *\/$/;"	m	struct:__anon17	file:
xset	gentourng.c	/^    xword *xset;          \/* array of all x-sets in card order *\/$/;"	m	struct:__anon15	file:
xstart	genbg.c	/^static int xstart[MAXN+1];  \/* index into xset[] for each cardinality *\/$/;"	v	file:
xstart	geng.c	/^    xword xstart[MAXN+1]; \/* index into xset[] for each cardinality *\/$/;"	m	struct:__anon17	file:
xstart	gentourng.c	/^    xword xstart[MAXN+1]; \/* index into xset[] for each cardinality *\/$/;"	m	struct:__anon15	file:
xub	genbg.c	/^    int xlb,xub;         \/* saved bounds on extension degree *\/$/;"	m	struct:__anon3	file:
xub	geng.c	/^    int xlb,xub;          \/* saved bounds on extension degree *\/$/;"	m	struct:__anon17	file:
xval	genbg.c	/^static int xval[MAXN];   \/* x-bit version of second class, xval[0..] *\/$/;"	v	file:
xword	geng.c	/^typedef int xword;   \/* Must be as large as MAXN bits, and$/;"	t	file:
xword	geng.c	/^typedef unsigned int xword;$/;"	t	file:
xword	gentourng.c	/^typedef unsigned int xword;$/;"	t	file:
xx	geng.c	/^    xword *xx;            \/* (-b, -t, -s, -m) candidate x-sets *\/$/;"	m	struct:__anon17	file:
yformat	geng.c	/^boolean yformat;                \/* presence of -y *\/$/;"	v
